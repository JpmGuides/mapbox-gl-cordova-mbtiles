{"version":3,"file":"mapbox-gl-cordova-offline.js","sources":["../node_modules/mapbox-gl/src/style/zoom_history.js","../node_modules/mapbox-gl/src/util/is_char_in_unicode_block.js","../node_modules/mapbox-gl/src/util/script_detection.js","../node_modules/mapbox-gl/src/source/rtl_text_plugin.js","../node_modules/mapbox-gl/src/style/evaluation_parameters.js","../node_modules/mapbox-gl/src/style/properties.js","../node_modules/mapbox-gl/src/style-spec/expression/index.js","../node_modules/gl-matrix/esm/vec4.js","../node_modules/mapbox-gl/src/style/style_layer/symbol_style_layer_properties.js","../node_modules/mapbox-gl/src/style-spec/expression/definitions/format_section_override.js","../node_modules/mapbox-gl/src/style/style_layer/symbol_style_layer.js","../node_modules/mapbox-gl/src/util/resolve_tokens.js","../node_modules/mapbox-gl/src/style/style_layer/background_style_layer_properties.js","../node_modules/mapbox-gl/src/style/style_layer/background_style_layer.js","../node_modules/mapbox-gl/src/style/style_layer/raster_style_layer_properties.js","../node_modules/mapbox-gl/src/style/style_layer/raster_style_layer.js","../node_modules/mapbox-gl/src/style/style_layer/custom_style_layer.js","../node_modules/mapbox-gl/src/style/create_style_layer.js","../node_modules/potpack/index.mjs","../node_modules/mapbox-gl/src/render/image_atlas.js","../node_modules/mapbox-gl/src/render/texture.js","../node_modules/ieee754/index.js","../node_modules/mapbox-gl/src/symbol/symbol_layout.js","../node_modules/mapbox-gl/src/symbol/shaping.js","../node_modules/mapbox-gl/src/symbol/clip_line.js","../node_modules/mapbox-gl/src/util/tile_request_cache.js","../node_modules/mapbox-gl/src/style-spec/group_by_layout.js","../node_modules/mapbox-gl/src/style/style_layer_index.js","../node_modules/mapbox-gl/src/render/glyph_atlas.js","../node_modules/mapbox-gl/src/source/worker_tile.js","../node_modules/mapbox-gl/src/util/performance.js","../node_modules/mapbox-gl/src/source/vector_tile_worker_source.js","../node_modules/mapbox-gl/src/source/raster_dem_tile_worker_source.js","../node_modules/wgs84/index.js","../node_modules/@mapbox/geojson-area/index.js","../node_modules/@mapbox/geojson-rewind/index.js","../node_modules/mapbox-gl/src/source/geojson_wrapper.js","../node_modules/vt-pbf/lib/geojson_wrapper.js","../node_modules/vt-pbf/index.js","../node_modules/kdbush/src/sort.js","../node_modules/kdbush/src/within.js","../node_modules/kdbush/src/index.js","../node_modules/kdbush/src/range.js","../node_modules/supercluster/index.js","../node_modules/geojson-vt/src/simplify.js","../node_modules/geojson-vt/src/feature.js","../node_modules/geojson-vt/src/convert.js","../node_modules/geojson-vt/src/clip.js","../node_modules/geojson-vt/src/wrap.js","../node_modules/geojson-vt/src/transform.js","../node_modules/geojson-vt/src/tile.js","../node_modules/geojson-vt/src/index.js","../node_modules/mapbox-gl/src/source/geojson_worker_source.js","../node_modules/mapbox-gl/src/style-spec/deref.js","../node_modules/mapbox-gl/src/util/worker_pool.js","../node_modules/mapbox-gl/src/style-spec/diff.js","../node_modules/mapbox-gl/src/symbol/grid_index.js","../node_modules/mapbox-gl/src/symbol/projection.js","../node_modules/mapbox-gl/src/render/draw_debug.js","../node_modules/mapbox-gl/src/ui/camera.js","../node_modules/mapbox-gl/src/ui/control/attribution_control.js","../node_modules/mapbox-gl/src/ui/control/logo_control.js","../node_modules/mapbox-gl/src/util/task_queue.js","../node_modules/mapbox-gl/src/ui/map.js","../node_modules/mapbox-gl/src/ui/bind_handlers.js","../node_modules/pako/lib/zlib/inflate.js","../node_modules/pako/lib/utils/strings.js","../node_modules/pako/lib/zlib/constants.js","../node_modules/pako/lib/zlib/messages.js","../node_modules/pako/lib/zlib/zstream.js","../node_modules/pako/lib/zlib/gzheader.js","../node_modules/pako/lib/inflate.js","../node_modules/base64-js/index.js","../src/mbtiles_source.js","../src/offline_map.js","../src/openmaptiles-language.js","../src/index.js","../rollup/mapboxgl.js"],"sourcesContent":["// @flow\n\nclass ZoomHistory {\n    lastZoom: number;\n    lastFloorZoom: number;\n    lastIntegerZoom: number;\n    lastIntegerZoomTime: number;\n    first: boolean;\n\n    constructor() {\n        this.first = true;\n    }\n\n    update(z: number, now: number) {\n        const floorZ = Math.floor(z);\n\n        if (this.first) {\n            this.first = false;\n            this.lastIntegerZoom = floorZ;\n            this.lastIntegerZoomTime = 0;\n            this.lastZoom = z;\n            this.lastFloorZoom = floorZ;\n            return true;\n        }\n\n        if (this.lastFloorZoom > floorZ) {\n            this.lastIntegerZoom = floorZ + 1;\n            this.lastIntegerZoomTime = now;\n        } else if (this.lastFloorZoom < floorZ) {\n            this.lastIntegerZoom = floorZ;\n            this.lastIntegerZoomTime = now;\n        }\n\n        if (z !== this.lastZoom) {\n            this.lastZoom = z;\n            this.lastFloorZoom = floorZ;\n            return true;\n        }\n\n        return false;\n    }\n}\n\nexport default ZoomHistory;\n","// @flow\n\n// The following table comes from <http://www.unicode.org/Public/12.0.0/ucd/Blocks.txt>.\n// Keep it synchronized with <http://www.unicode.org/Public/UCD/latest/ucd/Blocks.txt>.\n\ntype UnicodeBlockLookup = {[key: string]: (char: number) => boolean};\n\nconst unicodeBlockLookup: UnicodeBlockLookup = {\n    // 'Basic Latin': (char) => char >= 0x0000 && char <= 0x007F,\n    'Latin-1 Supplement': (char) => char >= 0x0080 && char <= 0x00FF,\n    // 'Latin Extended-A': (char) => char >= 0x0100 && char <= 0x017F,\n    // 'Latin Extended-B': (char) => char >= 0x0180 && char <= 0x024F,\n    // 'IPA Extensions': (char) => char >= 0x0250 && char <= 0x02AF,\n    // 'Spacing Modifier Letters': (char) => char >= 0x02B0 && char <= 0x02FF,\n    // 'Combining Diacritical Marks': (char) => char >= 0x0300 && char <= 0x036F,\n    // 'Greek and Coptic': (char) => char >= 0x0370 && char <= 0x03FF,\n    // 'Cyrillic': (char) => char >= 0x0400 && char <= 0x04FF,\n    // 'Cyrillic Supplement': (char) => char >= 0x0500 && char <= 0x052F,\n    // 'Armenian': (char) => char >= 0x0530 && char <= 0x058F,\n    //'Hebrew': (char) => char >= 0x0590 && char <= 0x05FF,\n    'Arabic': (char) => char >= 0x0600 && char <= 0x06FF,\n    //'Syriac': (char) => char >= 0x0700 && char <= 0x074F,\n    'Arabic Supplement': (char) => char >= 0x0750 && char <= 0x077F,\n    // 'Thaana': (char) => char >= 0x0780 && char <= 0x07BF,\n    // 'NKo': (char) => char >= 0x07C0 && char <= 0x07FF,\n    // 'Samaritan': (char) => char >= 0x0800 && char <= 0x083F,\n    // 'Mandaic': (char) => char >= 0x0840 && char <= 0x085F,\n    // 'Syriac Supplement': (char) => char >= 0x0860 && char <= 0x086F,\n    'Arabic Extended-A': (char) => char >= 0x08A0 && char <= 0x08FF,\n    // 'Devanagari': (char) => char >= 0x0900 && char <= 0x097F,\n    // 'Bengali': (char) => char >= 0x0980 && char <= 0x09FF,\n    // 'Gurmukhi': (char) => char >= 0x0A00 && char <= 0x0A7F,\n    // 'Gujarati': (char) => char >= 0x0A80 && char <= 0x0AFF,\n    // 'Oriya': (char) => char >= 0x0B00 && char <= 0x0B7F,\n    // 'Tamil': (char) => char >= 0x0B80 && char <= 0x0BFF,\n    // 'Telugu': (char) => char >= 0x0C00 && char <= 0x0C7F,\n    // 'Kannada': (char) => char >= 0x0C80 && char <= 0x0CFF,\n    // 'Malayalam': (char) => char >= 0x0D00 && char <= 0x0D7F,\n    // 'Sinhala': (char) => char >= 0x0D80 && char <= 0x0DFF,\n    // 'Thai': (char) => char >= 0x0E00 && char <= 0x0E7F,\n    // 'Lao': (char) => char >= 0x0E80 && char <= 0x0EFF,\n    // 'Tibetan': (char) => char >= 0x0F00 && char <= 0x0FFF,\n    // 'Myanmar': (char) => char >= 0x1000 && char <= 0x109F,\n    // 'Georgian': (char) => char >= 0x10A0 && char <= 0x10FF,\n    'Hangul Jamo': (char) => char >= 0x1100 && char <= 0x11FF,\n    // 'Ethiopic': (char) => char >= 0x1200 && char <= 0x137F,\n    // 'Ethiopic Supplement': (char) => char >= 0x1380 && char <= 0x139F,\n    // 'Cherokee': (char) => char >= 0x13A0 && char <= 0x13FF,\n    'Unified Canadian Aboriginal Syllabics': (char) => char >= 0x1400 && char <= 0x167F,\n    // 'Ogham': (char) => char >= 0x1680 && char <= 0x169F,\n    // 'Runic': (char) => char >= 0x16A0 && char <= 0x16FF,\n    // 'Tagalog': (char) => char >= 0x1700 && char <= 0x171F,\n    // 'Hanunoo': (char) => char >= 0x1720 && char <= 0x173F,\n    // 'Buhid': (char) => char >= 0x1740 && char <= 0x175F,\n    // 'Tagbanwa': (char) => char >= 0x1760 && char <= 0x177F,\n    'Khmer': (char) => char >= 0x1780 && char <= 0x17FF,\n    // 'Mongolian': (char) => char >= 0x1800 && char <= 0x18AF,\n    'Unified Canadian Aboriginal Syllabics Extended': (char) => char >= 0x18B0 && char <= 0x18FF,\n    // 'Limbu': (char) => char >= 0x1900 && char <= 0x194F,\n    // 'Tai Le': (char) => char >= 0x1950 && char <= 0x197F,\n    // 'New Tai Lue': (char) => char >= 0x1980 && char <= 0x19DF,\n    // 'Khmer Symbols': (char) => char >= 0x19E0 && char <= 0x19FF,\n    // 'Buginese': (char) => char >= 0x1A00 && char <= 0x1A1F,\n    // 'Tai Tham': (char) => char >= 0x1A20 && char <= 0x1AAF,\n    // 'Combining Diacritical Marks Extended': (char) => char >= 0x1AB0 && char <= 0x1AFF,\n    // 'Balinese': (char) => char >= 0x1B00 && char <= 0x1B7F,\n    // 'Sundanese': (char) => char >= 0x1B80 && char <= 0x1BBF,\n    // 'Batak': (char) => char >= 0x1BC0 && char <= 0x1BFF,\n    // 'Lepcha': (char) => char >= 0x1C00 && char <= 0x1C4F,\n    // 'Ol Chiki': (char) => char >= 0x1C50 && char <= 0x1C7F,\n    // 'Cyrillic Extended-C': (char) => char >= 0x1C80 && char <= 0x1C8F,\n    // 'Georgian Extended': (char) => char >= 0x1C90 && char <= 0x1CBF,\n    // 'Sundanese Supplement': (char) => char >= 0x1CC0 && char <= 0x1CCF,\n    // 'Vedic Extensions': (char) => char >= 0x1CD0 && char <= 0x1CFF,\n    // 'Phonetic Extensions': (char) => char >= 0x1D00 && char <= 0x1D7F,\n    // 'Phonetic Extensions Supplement': (char) => char >= 0x1D80 && char <= 0x1DBF,\n    // 'Combining Diacritical Marks Supplement': (char) => char >= 0x1DC0 && char <= 0x1DFF,\n    // 'Latin Extended Additional': (char) => char >= 0x1E00 && char <= 0x1EFF,\n    // 'Greek Extended': (char) => char >= 0x1F00 && char <= 0x1FFF,\n    'General Punctuation': (char) => char >= 0x2000 && char <= 0x206F,\n    // 'Superscripts and Subscripts': (char) => char >= 0x2070 && char <= 0x209F,\n    // 'Currency Symbols': (char) => char >= 0x20A0 && char <= 0x20CF,\n    // 'Combining Diacritical Marks for Symbols': (char) => char >= 0x20D0 && char <= 0x20FF,\n    'Letterlike Symbols': (char) => char >= 0x2100 && char <= 0x214F,\n    'Number Forms': (char) => char >= 0x2150 && char <= 0x218F,\n    // 'Arrows': (char) => char >= 0x2190 && char <= 0x21FF,\n    // 'Mathematical Operators': (char) => char >= 0x2200 && char <= 0x22FF,\n    'Miscellaneous Technical': (char) => char >= 0x2300 && char <= 0x23FF,\n    'Control Pictures': (char) => char >= 0x2400 && char <= 0x243F,\n    'Optical Character Recognition': (char) => char >= 0x2440 && char <= 0x245F,\n    'Enclosed Alphanumerics': (char) => char >= 0x2460 && char <= 0x24FF,\n    // 'Box Drawing': (char) => char >= 0x2500 && char <= 0x257F,\n    // 'Block Elements': (char) => char >= 0x2580 && char <= 0x259F,\n    'Geometric Shapes': (char) => char >= 0x25A0 && char <= 0x25FF,\n    'Miscellaneous Symbols': (char) => char >= 0x2600 && char <= 0x26FF,\n    // 'Dingbats': (char) => char >= 0x2700 && char <= 0x27BF,\n    // 'Miscellaneous Mathematical Symbols-A': (char) => char >= 0x27C0 && char <= 0x27EF,\n    // 'Supplemental Arrows-A': (char) => char >= 0x27F0 && char <= 0x27FF,\n    // 'Braille Patterns': (char) => char >= 0x2800 && char <= 0x28FF,\n    // 'Supplemental Arrows-B': (char) => char >= 0x2900 && char <= 0x297F,\n    // 'Miscellaneous Mathematical Symbols-B': (char) => char >= 0x2980 && char <= 0x29FF,\n    // 'Supplemental Mathematical Operators': (char) => char >= 0x2A00 && char <= 0x2AFF,\n    'Miscellaneous Symbols and Arrows': (char) => char >= 0x2B00 && char <= 0x2BFF,\n    // 'Glagolitic': (char) => char >= 0x2C00 && char <= 0x2C5F,\n    // 'Latin Extended-C': (char) => char >= 0x2C60 && char <= 0x2C7F,\n    // 'Coptic': (char) => char >= 0x2C80 && char <= 0x2CFF,\n    // 'Georgian Supplement': (char) => char >= 0x2D00 && char <= 0x2D2F,\n    // 'Tifinagh': (char) => char >= 0x2D30 && char <= 0x2D7F,\n    // 'Ethiopic Extended': (char) => char >= 0x2D80 && char <= 0x2DDF,\n    // 'Cyrillic Extended-A': (char) => char >= 0x2DE0 && char <= 0x2DFF,\n    // 'Supplemental Punctuation': (char) => char >= 0x2E00 && char <= 0x2E7F,\n    'CJK Radicals Supplement': (char) => char >= 0x2E80 && char <= 0x2EFF,\n    'Kangxi Radicals': (char) => char >= 0x2F00 && char <= 0x2FDF,\n    'Ideographic Description Characters': (char) => char >= 0x2FF0 && char <= 0x2FFF,\n    'CJK Symbols and Punctuation': (char) => char >= 0x3000 && char <= 0x303F,\n    'Hiragana': (char) => char >= 0x3040 && char <= 0x309F,\n    'Katakana': (char) => char >= 0x30A0 && char <= 0x30FF,\n    'Bopomofo': (char) => char >= 0x3100 && char <= 0x312F,\n    'Hangul Compatibility Jamo': (char) => char >= 0x3130 && char <= 0x318F,\n    'Kanbun': (char) => char >= 0x3190 && char <= 0x319F,\n    'Bopomofo Extended': (char) => char >= 0x31A0 && char <= 0x31BF,\n    'CJK Strokes': (char) => char >= 0x31C0 && char <= 0x31EF,\n    'Katakana Phonetic Extensions': (char) => char >= 0x31F0 && char <= 0x31FF,\n    'Enclosed CJK Letters and Months': (char) => char >= 0x3200 && char <= 0x32FF,\n    'CJK Compatibility': (char) => char >= 0x3300 && char <= 0x33FF,\n    'CJK Unified Ideographs Extension A': (char) => char >= 0x3400 && char <= 0x4DBF,\n    'Yijing Hexagram Symbols': (char) => char >= 0x4DC0 && char <= 0x4DFF,\n    'CJK Unified Ideographs': (char) => char >= 0x4E00 && char <= 0x9FFF,\n    'Yi Syllables': (char) => char >= 0xA000 && char <= 0xA48F,\n    'Yi Radicals': (char) => char >= 0xA490 && char <= 0xA4CF,\n    // 'Lisu': (char) => char >= 0xA4D0 && char <= 0xA4FF,\n    // 'Vai': (char) => char >= 0xA500 && char <= 0xA63F,\n    // 'Cyrillic Extended-B': (char) => char >= 0xA640 && char <= 0xA69F,\n    // 'Bamum': (char) => char >= 0xA6A0 && char <= 0xA6FF,\n    // 'Modifier Tone Letters': (char) => char >= 0xA700 && char <= 0xA71F,\n    // 'Latin Extended-D': (char) => char >= 0xA720 && char <= 0xA7FF,\n    // 'Syloti Nagri': (char) => char >= 0xA800 && char <= 0xA82F,\n    // 'Common Indic Number Forms': (char) => char >= 0xA830 && char <= 0xA83F,\n    // 'Phags-pa': (char) => char >= 0xA840 && char <= 0xA87F,\n    // 'Saurashtra': (char) => char >= 0xA880 && char <= 0xA8DF,\n    // 'Devanagari Extended': (char) => char >= 0xA8E0 && char <= 0xA8FF,\n    // 'Kayah Li': (char) => char >= 0xA900 && char <= 0xA92F,\n    // 'Rejang': (char) => char >= 0xA930 && char <= 0xA95F,\n    'Hangul Jamo Extended-A': (char) => char >= 0xA960 && char <= 0xA97F,\n    // 'Javanese': (char) => char >= 0xA980 && char <= 0xA9DF,\n    // 'Myanmar Extended-B': (char) => char >= 0xA9E0 && char <= 0xA9FF,\n    // 'Cham': (char) => char >= 0xAA00 && char <= 0xAA5F,\n    // 'Myanmar Extended-A': (char) => char >= 0xAA60 && char <= 0xAA7F,\n    // 'Tai Viet': (char) => char >= 0xAA80 && char <= 0xAADF,\n    // 'Meetei Mayek Extensions': (char) => char >= 0xAAE0 && char <= 0xAAFF,\n    // 'Ethiopic Extended-A': (char) => char >= 0xAB00 && char <= 0xAB2F,\n    // 'Latin Extended-E': (char) => char >= 0xAB30 && char <= 0xAB6F,\n    // 'Cherokee Supplement': (char) => char >= 0xAB70 && char <= 0xABBF,\n    // 'Meetei Mayek': (char) => char >= 0xABC0 && char <= 0xABFF,\n    'Hangul Syllables': (char) => char >= 0xAC00 && char <= 0xD7AF,\n    'Hangul Jamo Extended-B': (char) => char >= 0xD7B0 && char <= 0xD7FF,\n    // 'High Surrogates': (char) => char >= 0xD800 && char <= 0xDB7F,\n    // 'High Private Use Surrogates': (char) => char >= 0xDB80 && char <= 0xDBFF,\n    // 'Low Surrogates': (char) => char >= 0xDC00 && char <= 0xDFFF,\n    'Private Use Area': (char) => char >= 0xE000 && char <= 0xF8FF,\n    'CJK Compatibility Ideographs': (char) => char >= 0xF900 && char <= 0xFAFF,\n    // 'Alphabetic Presentation Forms': (char) => char >= 0xFB00 && char <= 0xFB4F,\n    'Arabic Presentation Forms-A': (char) => char >= 0xFB50 && char <= 0xFDFF,\n    // 'Variation Selectors': (char) => char >= 0xFE00 && char <= 0xFE0F,\n    'Vertical Forms': (char) => char >= 0xFE10 && char <= 0xFE1F,\n    // 'Combining Half Marks': (char) => char >= 0xFE20 && char <= 0xFE2F,\n    'CJK Compatibility Forms': (char) => char >= 0xFE30 && char <= 0xFE4F,\n    'Small Form Variants': (char) => char >= 0xFE50 && char <= 0xFE6F,\n    'Arabic Presentation Forms-B': (char) => char >= 0xFE70 && char <= 0xFEFF,\n    'Halfwidth and Fullwidth Forms': (char) => char >= 0xFF00 && char <= 0xFFEF\n    // 'Specials': (char) => char >= 0xFFF0 && char <= 0xFFFF,\n    // 'Linear B Syllabary': (char) => char >= 0x10000 && char <= 0x1007F,\n    // 'Linear B Ideograms': (char) => char >= 0x10080 && char <= 0x100FF,\n    // 'Aegean Numbers': (char) => char >= 0x10100 && char <= 0x1013F,\n    // 'Ancient Greek Numbers': (char) => char >= 0x10140 && char <= 0x1018F,\n    // 'Ancient Symbols': (char) => char >= 0x10190 && char <= 0x101CF,\n    // 'Phaistos Disc': (char) => char >= 0x101D0 && char <= 0x101FF,\n    // 'Lycian': (char) => char >= 0x10280 && char <= 0x1029F,\n    // 'Carian': (char) => char >= 0x102A0 && char <= 0x102DF,\n    // 'Coptic Epact Numbers': (char) => char >= 0x102E0 && char <= 0x102FF,\n    // 'Old Italic': (char) => char >= 0x10300 && char <= 0x1032F,\n    // 'Gothic': (char) => char >= 0x10330 && char <= 0x1034F,\n    // 'Old Permic': (char) => char >= 0x10350 && char <= 0x1037F,\n    // 'Ugaritic': (char) => char >= 0x10380 && char <= 0x1039F,\n    // 'Old Persian': (char) => char >= 0x103A0 && char <= 0x103DF,\n    // 'Deseret': (char) => char >= 0x10400 && char <= 0x1044F,\n    // 'Shavian': (char) => char >= 0x10450 && char <= 0x1047F,\n    // 'Osmanya': (char) => char >= 0x10480 && char <= 0x104AF,\n    // 'Osage': (char) => char >= 0x104B0 && char <= 0x104FF,\n    // 'Elbasan': (char) => char >= 0x10500 && char <= 0x1052F,\n    // 'Caucasian Albanian': (char) => char >= 0x10530 && char <= 0x1056F,\n    // 'Linear A': (char) => char >= 0x10600 && char <= 0x1077F,\n    // 'Cypriot Syllabary': (char) => char >= 0x10800 && char <= 0x1083F,\n    // 'Imperial Aramaic': (char) => char >= 0x10840 && char <= 0x1085F,\n    // 'Palmyrene': (char) => char >= 0x10860 && char <= 0x1087F,\n    // 'Nabataean': (char) => char >= 0x10880 && char <= 0x108AF,\n    // 'Hatran': (char) => char >= 0x108E0 && char <= 0x108FF,\n    // 'Phoenician': (char) => char >= 0x10900 && char <= 0x1091F,\n    // 'Lydian': (char) => char >= 0x10920 && char <= 0x1093F,\n    // 'Meroitic Hieroglyphs': (char) => char >= 0x10980 && char <= 0x1099F,\n    // 'Meroitic Cursive': (char) => char >= 0x109A0 && char <= 0x109FF,\n    // 'Kharoshthi': (char) => char >= 0x10A00 && char <= 0x10A5F,\n    // 'Old South Arabian': (char) => char >= 0x10A60 && char <= 0x10A7F,\n    // 'Old North Arabian': (char) => char >= 0x10A80 && char <= 0x10A9F,\n    // 'Manichaean': (char) => char >= 0x10AC0 && char <= 0x10AFF,\n    // 'Avestan': (char) => char >= 0x10B00 && char <= 0x10B3F,\n    // 'Inscriptional Parthian': (char) => char >= 0x10B40 && char <= 0x10B5F,\n    // 'Inscriptional Pahlavi': (char) => char >= 0x10B60 && char <= 0x10B7F,\n    // 'Psalter Pahlavi': (char) => char >= 0x10B80 && char <= 0x10BAF,\n    // 'Old Turkic': (char) => char >= 0x10C00 && char <= 0x10C4F,\n    // 'Old Hungarian': (char) => char >= 0x10C80 && char <= 0x10CFF,\n    // 'Hanifi Rohingya': (char) => char >= 0x10D00 && char <= 0x10D3F,\n    // 'Rumi Numeral Symbols': (char) => char >= 0x10E60 && char <= 0x10E7F,\n    // 'Old Sogdian': (char) => char >= 0x10F00 && char <= 0x10F2F,\n    // 'Sogdian': (char) => char >= 0x10F30 && char <= 0x10F6F,\n    // 'Elymaic': (char) => char >= 0x10FE0 && char <= 0x10FFF,\n    // 'Brahmi': (char) => char >= 0x11000 && char <= 0x1107F,\n    // 'Kaithi': (char) => char >= 0x11080 && char <= 0x110CF,\n    // 'Sora Sompeng': (char) => char >= 0x110D0 && char <= 0x110FF,\n    // 'Chakma': (char) => char >= 0x11100 && char <= 0x1114F,\n    // 'Mahajani': (char) => char >= 0x11150 && char <= 0x1117F,\n    // 'Sharada': (char) => char >= 0x11180 && char <= 0x111DF,\n    // 'Sinhala Archaic Numbers': (char) => char >= 0x111E0 && char <= 0x111FF,\n    // 'Khojki': (char) => char >= 0x11200 && char <= 0x1124F,\n    // 'Multani': (char) => char >= 0x11280 && char <= 0x112AF,\n    // 'Khudawadi': (char) => char >= 0x112B0 && char <= 0x112FF,\n    // 'Grantha': (char) => char >= 0x11300 && char <= 0x1137F,\n    // 'Newa': (char) => char >= 0x11400 && char <= 0x1147F,\n    // 'Tirhuta': (char) => char >= 0x11480 && char <= 0x114DF,\n    // 'Siddham': (char) => char >= 0x11580 && char <= 0x115FF,\n    // 'Modi': (char) => char >= 0x11600 && char <= 0x1165F,\n    // 'Mongolian Supplement': (char) => char >= 0x11660 && char <= 0x1167F,\n    // 'Takri': (char) => char >= 0x11680 && char <= 0x116CF,\n    // 'Ahom': (char) => char >= 0x11700 && char <= 0x1173F,\n    // 'Dogra': (char) => char >= 0x11800 && char <= 0x1184F,\n    // 'Warang Citi': (char) => char >= 0x118A0 && char <= 0x118FF,\n    // 'Nandinagari': (char) => char >= 0x119A0 && char <= 0x119FF,\n    // 'Zanabazar Square': (char) => char >= 0x11A00 && char <= 0x11A4F,\n    // 'Soyombo': (char) => char >= 0x11A50 && char <= 0x11AAF,\n    // 'Pau Cin Hau': (char) => char >= 0x11AC0 && char <= 0x11AFF,\n    // 'Bhaiksuki': (char) => char >= 0x11C00 && char <= 0x11C6F,\n    // 'Marchen': (char) => char >= 0x11C70 && char <= 0x11CBF,\n    // 'Masaram Gondi': (char) => char >= 0x11D00 && char <= 0x11D5F,\n    // 'Gunjala Gondi': (char) => char >= 0x11D60 && char <= 0x11DAF,\n    // 'Makasar': (char) => char >= 0x11EE0 && char <= 0x11EFF,\n    // 'Tamil Supplement': (char) => char >= 0x11FC0 && char <= 0x11FFF,\n    // 'Cuneiform': (char) => char >= 0x12000 && char <= 0x123FF,\n    // 'Cuneiform Numbers and Punctuation': (char) => char >= 0x12400 && char <= 0x1247F,\n    // 'Early Dynastic Cuneiform': (char) => char >= 0x12480 && char <= 0x1254F,\n    // 'Egyptian Hieroglyphs': (char) => char >= 0x13000 && char <= 0x1342F,\n    // 'Egyptian Hieroglyph Format Controls': (char) => char >= 0x13430 && char <= 0x1343F,\n    // 'Anatolian Hieroglyphs': (char) => char >= 0x14400 && char <= 0x1467F,\n    // 'Bamum Supplement': (char) => char >= 0x16800 && char <= 0x16A3F,\n    // 'Mro': (char) => char >= 0x16A40 && char <= 0x16A6F,\n    // 'Bassa Vah': (char) => char >= 0x16AD0 && char <= 0x16AFF,\n    // 'Pahawh Hmong': (char) => char >= 0x16B00 && char <= 0x16B8F,\n    // 'Medefaidrin': (char) => char >= 0x16E40 && char <= 0x16E9F,\n    // 'Miao': (char) => char >= 0x16F00 && char <= 0x16F9F,\n    // 'Ideographic Symbols and Punctuation': (char) => char >= 0x16FE0 && char <= 0x16FFF,\n    // 'Tangut': (char) => char >= 0x17000 && char <= 0x187FF,\n    // 'Tangut Components': (char) => char >= 0x18800 && char <= 0x18AFF,\n    // 'Kana Supplement': (char) => char >= 0x1B000 && char <= 0x1B0FF,\n    // 'Kana Extended-A': (char) => char >= 0x1B100 && char <= 0x1B12F,\n    // 'Small Kana Extension': (char) => char >= 0x1B130 && char <= 0x1B16F,\n    // 'Nushu': (char) => char >= 0x1B170 && char <= 0x1B2FF,\n    // 'Duployan': (char) => char >= 0x1BC00 && char <= 0x1BC9F,\n    // 'Shorthand Format Controls': (char) => char >= 0x1BCA0 && char <= 0x1BCAF,\n    // 'Byzantine Musical Symbols': (char) => char >= 0x1D000 && char <= 0x1D0FF,\n    // 'Musical Symbols': (char) => char >= 0x1D100 && char <= 0x1D1FF,\n    // 'Ancient Greek Musical Notation': (char) => char >= 0x1D200 && char <= 0x1D24F,\n    // 'Mayan Numerals': (char) => char >= 0x1D2E0 && char <= 0x1D2FF,\n    // 'Tai Xuan Jing Symbols': (char) => char >= 0x1D300 && char <= 0x1D35F,\n    // 'Counting Rod Numerals': (char) => char >= 0x1D360 && char <= 0x1D37F,\n    // 'Mathematical Alphanumeric Symbols': (char) => char >= 0x1D400 && char <= 0x1D7FF,\n    // 'Sutton SignWriting': (char) => char >= 0x1D800 && char <= 0x1DAAF,\n    // 'Glagolitic Supplement': (char) => char >= 0x1E000 && char <= 0x1E02F,\n    // 'Nyiakeng Puachue Hmong': (char) => char >= 0x1E100 && char <= 0x1E14F,\n    // 'Wancho': (char) => char >= 0x1E2C0 && char <= 0x1E2FF,\n    // 'Mende Kikakui': (char) => char >= 0x1E800 && char <= 0x1E8DF,\n    // 'Adlam': (char) => char >= 0x1E900 && char <= 0x1E95F,\n    // 'Indic Siyaq Numbers': (char) => char >= 0x1EC70 && char <= 0x1ECBF,\n    // 'Ottoman Siyaq Numbers': (char) => char >= 0x1ED00 && char <= 0x1ED4F,\n    // 'Arabic Mathematical Alphabetic Symbols': (char) => char >= 0x1EE00 && char <= 0x1EEFF,\n    // 'Mahjong Tiles': (char) => char >= 0x1F000 && char <= 0x1F02F,\n    // 'Domino Tiles': (char) => char >= 0x1F030 && char <= 0x1F09F,\n    // 'Playing Cards': (char) => char >= 0x1F0A0 && char <= 0x1F0FF,\n    // 'Enclosed Alphanumeric Supplement': (char) => char >= 0x1F100 && char <= 0x1F1FF,\n    // 'Enclosed Ideographic Supplement': (char) => char >= 0x1F200 && char <= 0x1F2FF,\n    // 'Miscellaneous Symbols and Pictographs': (char) => char >= 0x1F300 && char <= 0x1F5FF,\n    // 'Emoticons': (char) => char >= 0x1F600 && char <= 0x1F64F,\n    // 'Ornamental Dingbats': (char) => char >= 0x1F650 && char <= 0x1F67F,\n    // 'Transport and Map Symbols': (char) => char >= 0x1F680 && char <= 0x1F6FF,\n    // 'Alchemical Symbols': (char) => char >= 0x1F700 && char <= 0x1F77F,\n    // 'Geometric Shapes Extended': (char) => char >= 0x1F780 && char <= 0x1F7FF,\n    // 'Supplemental Arrows-C': (char) => char >= 0x1F800 && char <= 0x1F8FF,\n    // 'Supplemental Symbols and Pictographs': (char) => char >= 0x1F900 && char <= 0x1F9FF,\n    // 'Chess Symbols': (char) => char >= 0x1FA00 && char <= 0x1FA6F,\n    // 'Symbols and Pictographs Extended-A': (char) => char >= 0x1FA70 && char <= 0x1FAFF,\n    // 'CJK Unified Ideographs Extension B': (char) => char >= 0x20000 && char <= 0x2A6DF,\n    // 'CJK Unified Ideographs Extension C': (char) => char >= 0x2A700 && char <= 0x2B73F,\n    // 'CJK Unified Ideographs Extension D': (char) => char >= 0x2B740 && char <= 0x2B81F,\n    // 'CJK Unified Ideographs Extension E': (char) => char >= 0x2B820 && char <= 0x2CEAF,\n    // 'CJK Unified Ideographs Extension F': (char) => char >= 0x2CEB0 && char <= 0x2EBEF,\n    // 'CJK Compatibility Ideographs Supplement': (char) => char >= 0x2F800 && char <= 0x2FA1F,\n    // 'Tags': (char) => char >= 0xE0000 && char <= 0xE007F,\n    // 'Variation Selectors Supplement': (char) => char >= 0xE0100 && char <= 0xE01EF,\n    // 'Supplementary Private Use Area-A': (char) => char >= 0xF0000 && char <= 0xFFFFF,\n    // 'Supplementary Private Use Area-B': (char) => char >= 0x100000 && char <= 0x10FFFF,\n};\n\nexport default unicodeBlockLookup;\n","// @flow\n\n/* eslint-disable new-cap */\n\nimport isChar from './is_char_in_unicode_block';\n\nexport function allowsIdeographicBreaking(chars: string) {\n    for (const char of chars) {\n        if (!charAllowsIdeographicBreaking(char.charCodeAt(0))) return false;\n    }\n    return true;\n}\n\nexport function allowsVerticalWritingMode(chars: string) {\n    for (const char of chars) {\n        if (charHasUprightVerticalOrientation(char.charCodeAt(0))) return true;\n    }\n    return false;\n}\n\nexport function allowsLetterSpacing(chars: string) {\n    for (const char of chars) {\n        if (!charAllowsLetterSpacing(char.charCodeAt(0))) return false;\n    }\n    return true;\n}\n\nexport function charAllowsLetterSpacing(char: number) {\n    if (isChar['Arabic'](char)) return false;\n    if (isChar['Arabic Supplement'](char)) return false;\n    if (isChar['Arabic Extended-A'](char)) return false;\n    if (isChar['Arabic Presentation Forms-A'](char)) return false;\n    if (isChar['Arabic Presentation Forms-B'](char)) return false;\n\n    return true;\n}\n\nexport function charAllowsIdeographicBreaking(char: number) {\n    // Return early for characters outside all ideographic ranges.\n    if (char < 0x2E80) return false;\n\n    if (isChar['Bopomofo Extended'](char)) return true;\n    if (isChar['Bopomofo'](char)) return true;\n    if (isChar['CJK Compatibility Forms'](char)) return true;\n    if (isChar['CJK Compatibility Ideographs'](char)) return true;\n    if (isChar['CJK Compatibility'](char)) return true;\n    if (isChar['CJK Radicals Supplement'](char)) return true;\n    if (isChar['CJK Strokes'](char)) return true;\n    if (isChar['CJK Symbols and Punctuation'](char)) return true;\n    if (isChar['CJK Unified Ideographs Extension A'](char)) return true;\n    if (isChar['CJK Unified Ideographs'](char)) return true;\n    if (isChar['Enclosed CJK Letters and Months'](char)) return true;\n    if (isChar['Halfwidth and Fullwidth Forms'](char)) return true;\n    if (isChar['Hiragana'](char)) return true;\n    if (isChar['Ideographic Description Characters'](char)) return true;\n    if (isChar['Kangxi Radicals'](char)) return true;\n    if (isChar['Katakana Phonetic Extensions'](char)) return true;\n    if (isChar['Katakana'](char)) return true;\n    if (isChar['Vertical Forms'](char)) return true;\n    if (isChar['Yi Radicals'](char)) return true;\n    if (isChar['Yi Syllables'](char)) return true;\n\n    return false;\n}\n\n// The following logic comes from\n// <http://www.unicode.org/Public/12.0.0/ucd/VerticalOrientation.txt>.\n// Keep it synchronized with\n// <http://www.unicode.org/Public/UCD/latest/ucd/VerticalOrientation.txt>.\n// The data file denotes with âUâ or âTuâ any codepoint that may be drawn\n// upright in vertical text but does not distinguish between upright and\n// âneutralâ characters.\n\n// Blocks in the Unicode supplementary planes are excluded from this module due\n// to <https://github.com/mapbox/mapbox-gl/issues/29>.\n\n/**\n * Returns true if the given Unicode codepoint identifies a character with\n * upright orientation.\n *\n * A character has upright orientation if it is drawn upright (unrotated)\n * whether the line is oriented horizontally or vertically, even if both\n * adjacent characters can be rotated. For example, a Chinese character is\n * always drawn upright. An uprightly oriented character causes an adjacent\n * âneutralâ character to be drawn upright as well.\n * @private\n */\nexport function charHasUprightVerticalOrientation(char: number) {\n    if (char === 0x02EA /* modifier letter yin departing tone mark */ ||\n        char === 0x02EB /* modifier letter yang departing tone mark */) {\n        return true;\n    }\n\n    // Return early for characters outside all ranges whose characters remain\n    // upright in vertical writing mode.\n    if (char < 0x1100) return false;\n\n    if (isChar['Bopomofo Extended'](char)) return true;\n    if (isChar['Bopomofo'](char)) return true;\n    if (isChar['CJK Compatibility Forms'](char)) {\n        if (!((char >= 0xFE49 /* dashed overline */ && char <= 0xFE4F) /* wavy low line */)) {\n            return true;\n        }\n    }\n    if (isChar['CJK Compatibility Ideographs'](char)) return true;\n    if (isChar['CJK Compatibility'](char)) return true;\n    if (isChar['CJK Radicals Supplement'](char)) return true;\n    if (isChar['CJK Strokes'](char)) return true;\n    if (isChar['CJK Symbols and Punctuation'](char)) {\n        if (!((char >= 0x3008 /* left angle bracket */ && char <= 0x3011) /* right black lenticular bracket */) &&\n            !((char >= 0x3014 /* left tortoise shell bracket */ && char <= 0x301F) /* low double prime quotation mark */) &&\n            char !== 0x3030 /* wavy dash */) {\n            return true;\n        }\n    }\n    if (isChar['CJK Unified Ideographs Extension A'](char)) return true;\n    if (isChar['CJK Unified Ideographs'](char)) return true;\n    if (isChar['Enclosed CJK Letters and Months'](char)) return true;\n    if (isChar['Hangul Compatibility Jamo'](char)) return true;\n    if (isChar['Hangul Jamo Extended-A'](char)) return true;\n    if (isChar['Hangul Jamo Extended-B'](char)) return true;\n    if (isChar['Hangul Jamo'](char)) return true;\n    if (isChar['Hangul Syllables'](char)) return true;\n    if (isChar['Hiragana'](char)) return true;\n    if (isChar['Ideographic Description Characters'](char)) return true;\n    if (isChar['Kanbun'](char)) return true;\n    if (isChar['Kangxi Radicals'](char)) return true;\n    if (isChar['Katakana Phonetic Extensions'](char)) return true;\n    if (isChar['Katakana'](char)) {\n        if (char !== 0x30FC /* katakana-hiragana prolonged sound mark */) {\n            return true;\n        }\n    }\n    if (isChar['Halfwidth and Fullwidth Forms'](char)) {\n        if (char !== 0xFF08 /* fullwidth left parenthesis */ &&\n            char !== 0xFF09 /* fullwidth right parenthesis */ &&\n            char !== 0xFF0D /* fullwidth hyphen-minus */ &&\n            !((char >= 0xFF1A /* fullwidth colon */ && char <= 0xFF1E) /* fullwidth greater-than sign */) &&\n            char !== 0xFF3B /* fullwidth left square bracket */ &&\n            char !== 0xFF3D /* fullwidth right square bracket */ &&\n            char !== 0xFF3F /* fullwidth low line */ &&\n            !(char >= 0xFF5B /* fullwidth left curly bracket */ && char <= 0xFFDF) &&\n            char !== 0xFFE3 /* fullwidth macron */ &&\n            !(char >= 0xFFE8 /* halfwidth forms light vertical */ && char <= 0xFFEF)) {\n            return true;\n        }\n    }\n    if (isChar['Small Form Variants'](char)) {\n        if (!((char >= 0xFE58 /* small em dash */ && char <= 0xFE5E) /* small right tortoise shell bracket */) &&\n            !((char >= 0xFE63 /* small hyphen-minus */ && char <= 0xFE66) /* small equals sign */)) {\n            return true;\n        }\n    }\n    if (isChar['Unified Canadian Aboriginal Syllabics'](char)) return true;\n    if (isChar['Unified Canadian Aboriginal Syllabics Extended'](char)) return true;\n    if (isChar['Vertical Forms'](char)) return true;\n    if (isChar['Yijing Hexagram Symbols'](char)) return true;\n    if (isChar['Yi Syllables'](char)) return true;\n    if (isChar['Yi Radicals'](char)) return true;\n\n    return false;\n}\n\n/**\n * Returns true if the given Unicode codepoint identifies a character with\n * neutral orientation.\n *\n * A character has neutral orientation if it may be drawn rotated or unrotated\n * when the line is oriented vertically, depending on the orientation of the\n * adjacent characters. For example, along a verticlly oriented line, the vulgar\n * fraction Â½ is drawn upright among Chinese characters but rotated among Latin\n * letters. A neutrally oriented character does not influence whether an\n * adjacent character is drawn upright or rotated.\n * @private\n */\nexport function charHasNeutralVerticalOrientation(char: number) {\n    if (isChar['Latin-1 Supplement'](char)) {\n        if (char === 0x00A7 /* section sign */ ||\n            char === 0x00A9 /* copyright sign */ ||\n            char === 0x00AE /* registered sign */ ||\n            char === 0x00B1 /* plus-minus sign */ ||\n            char === 0x00BC /* vulgar fraction one quarter */ ||\n            char === 0x00BD /* vulgar fraction one half */ ||\n            char === 0x00BE /* vulgar fraction three quarters */ ||\n            char === 0x00D7 /* multiplication sign */ ||\n            char === 0x00F7 /* division sign */) {\n            return true;\n        }\n    }\n    if (isChar['General Punctuation'](char)) {\n        if (char === 0x2016 /* double vertical line */ ||\n            char === 0x2020 /* dagger */ ||\n            char === 0x2021 /* double dagger */ ||\n            char === 0x2030 /* per mille sign */ ||\n            char === 0x2031 /* per ten thousand sign */ ||\n            char === 0x203B /* reference mark */ ||\n            char === 0x203C /* double exclamation mark */ ||\n            char === 0x2042 /* asterism */ ||\n            char === 0x2047 /* double question mark */ ||\n            char === 0x2048 /* question exclamation mark */ ||\n            char === 0x2049 /* exclamation question mark */ ||\n            char === 0x2051 /* two asterisks aligned vertically */) {\n            return true;\n        }\n    }\n    if (isChar['Letterlike Symbols'](char)) return true;\n    if (isChar['Number Forms'](char)) return true;\n    if (isChar['Miscellaneous Technical'](char)) {\n        if ((char >= 0x2300 /* diameter sign */ && char <= 0x2307 /* wavy line */) ||\n            (char >= 0x230C /* bottom right crop */ && char <= 0x231F /* bottom right corner */) ||\n            (char >= 0x2324 /* up arrowhead between two horizontal bars */ && char <= 0x2328 /* keyboard */) ||\n            char === 0x232B /* erase to the left */ ||\n            (char >= 0x237D /* shouldered open box */ && char <= 0x239A /* clear screen symbol */) ||\n            (char >= 0x23BE /* dentistry symbol light vertical and top right */ && char <= 0x23CD /* square foot */) ||\n            char === 0x23CF /* eject symbol */ ||\n            (char >= 0x23D1 /* metrical breve */ && char <= 0x23DB /* fuse */) ||\n            (char >= 0x23E2 /* white trapezium */ && char <= 0x23FF)) {\n            return true;\n        }\n    }\n    if (isChar['Control Pictures'](char) && char !== 0x2423 /* open box */) return true;\n    if (isChar['Optical Character Recognition'](char)) return true;\n    if (isChar['Enclosed Alphanumerics'](char)) return true;\n    if (isChar['Geometric Shapes'](char)) return true;\n    if (isChar['Miscellaneous Symbols'](char)) {\n        if (!((char >= 0x261A /* black left pointing index */ && char <= 0x261F) /* white down pointing index */)) {\n            return true;\n        }\n    }\n    if (isChar['Miscellaneous Symbols and Arrows'](char)) {\n        if ((char >= 0x2B12 /* square with top half black */ && char <= 0x2B2F /* white vertical ellipse */) ||\n            (char >= 0x2B50 /* white medium star */ && char <= 0x2B59 /* heavy circled saltire */) ||\n            (char >= 0x2BB8 /* upwards white arrow from bar with horizontal bar */ && char <= 0x2BEB)) {\n            return true;\n        }\n    }\n    if (isChar['CJK Symbols and Punctuation'](char)) return true;\n    if (isChar['Katakana'](char)) return true;\n    if (isChar['Private Use Area'](char)) return true;\n    if (isChar['CJK Compatibility Forms'](char)) return true;\n    if (isChar['Small Form Variants'](char)) return true;\n    if (isChar['Halfwidth and Fullwidth Forms'](char)) return true;\n\n    if (char === 0x221E /* infinity */ ||\n        char === 0x2234 /* therefore */ ||\n        char === 0x2235 /* because */ ||\n        (char >= 0x2700 /* black safety scissors */ && char <= 0x2767 /* rotated floral heart bullet */) ||\n        (char >= 0x2776 /* dingbat negative circled digit one */ && char <= 0x2793 /* dingbat negative circled sans-serif number ten */) ||\n        char === 0xFFFC /* object replacement character */ ||\n        char === 0xFFFD /* replacement character */) {\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Returns true if the given Unicode codepoint identifies a character with\n * rotated orientation.\n *\n * A character has rotated orientation if it is drawn rotated when the line is\n * oriented vertically, even if both adjacent characters are upright. For\n * example, a Latin letter is drawn rotated along a vertical line. A rotated\n * character causes an adjacent âneutralâ character to be drawn rotated as well.\n * @private\n */\nexport function charHasRotatedVerticalOrientation(char: number) {\n    return !(charHasUprightVerticalOrientation(char) ||\n             charHasNeutralVerticalOrientation(char));\n}\n\nexport function charInComplexShapingScript(char: number) {\n    return isChar['Arabic'](char) ||\n           isChar['Arabic Supplement'](char) ||\n           isChar['Arabic Extended-A'](char) ||\n           isChar['Arabic Presentation Forms-A'](char) ||\n           isChar['Arabic Presentation Forms-B'](char);\n}\n\nexport function charInSupportedScript(char: number, canRenderRTL: boolean) {\n    // This is a rough heuristic: whether we \"can render\" a script\n    // actually depends on the properties of the font being used\n    // and whether differences from the ideal rendering are considered\n    // semantically significant.\n\n    // Even in Latin script, we \"can't render\" combinations such as the fi\n    // ligature, but we don't consider that semantically significant.\n    if (!canRenderRTL &&\n        ((char >= 0x0590 && char <= 0x08FF) ||\n         isChar['Arabic Presentation Forms-A'](char) ||\n         isChar['Arabic Presentation Forms-B'](char))) {\n        // Main blocks for Hebrew, Arabic, Thaana and other RTL scripts\n        return false;\n    }\n    if ((char >= 0x0900 && char <= 0x0DFF) ||\n        // Main blocks for Indic scripts and Sinhala\n        (char >= 0x0F00 && char <= 0x109F) ||\n        // Main blocks for Tibetan and Myanmar\n        isChar['Khmer'](char)) {\n        // These blocks cover common scripts that require\n        // complex text shaping, based on unicode script metadata:\n        // http://www.unicode.org/repos/cldr/trunk/common/properties/scriptMetadata.txt\n        // where \"Web Rank <= 32\" \"Shaping Required = YES\"\n        return false;\n    }\n    return true;\n}\n\nexport function isStringInSupportedScript(chars: string, canRenderRTL: boolean) {\n    for (const char of chars) {\n        if (!charInSupportedScript(char.charCodeAt(0), canRenderRTL)) {\n            return false;\n        }\n    }\n    return true;\n}\n","// @flow\n\nimport {Event, Evented} from '../util/evented';\nimport browser from '../util/browser';\n\nconst status = {\n    unavailable: 'unavailable',\n    loading: 'loading',\n    loaded: 'loaded',\n    error: 'error'\n};\nlet pluginStatus = status.unavailable;\nlet pluginURL = null;\n\nexport const evented = new Evented();\n\ntype CompletionCallback = (error?: Error) => void;\ntype ErrorCallback = (error: Error) => void;\n\nlet _completionCallback;\n\nexport const getRTLTextPluginStatus = function () {\n    return pluginStatus;\n};\n\nexport const registerForPluginAvailability = function(\n    callback: (args: {pluginURL: string, completionCallback: CompletionCallback}) => void\n) {\n    if (pluginURL) {\n        callback({pluginURL, completionCallback: _completionCallback});\n    } else {\n        evented.once('pluginAvailable', callback);\n    }\n    return callback;\n};\n\nexport const clearRTLTextPlugin = function() {\n    pluginStatus = status.unavailable;\n    pluginURL = null;\n};\n\nexport const setRTLTextPlugin = function(url: string, callback: ErrorCallback) {\n    if (pluginStatus === status.loading || pluginStatus === status.loaded) {\n        throw new Error('setRTLTextPlugin cannot be called multiple times.');\n    }\n    pluginStatus = status.loading;\n    pluginURL = browser.resolveURL(url);\n    _completionCallback = (error?: Error) => {\n        if (error) {\n            // Clear loaded state to allow retries\n            clearRTLTextPlugin();\n            pluginStatus = status.error;\n            if (callback) {\n                callback(error);\n            }\n        } else {\n            // Called once for each worker\n            pluginStatus = status.loaded;\n        }\n    };\n    evented.fire(new Event('pluginAvailable', {pluginURL, completionCallback: _completionCallback}));\n};\n\nexport const plugin: {\n    applyArabicShaping: ?Function,\n    processBidirectionalText: ?(string, Array<number>) => Array<string>,\n    processStyledBidirectionalText: ?(string, Array<number>, Array<number>) => Array<[string, Array<number>]>,\n    isLoaded: () => boolean\n} = {\n    applyArabicShaping: null,\n    processBidirectionalText: null,\n    processStyledBidirectionalText: null,\n    isLoaded() {\n        return pluginStatus === status.loaded ||       // Foreground: loaded if the completion callback returned successfully\n            plugin.applyArabicShaping != null; // Background: loaded if the plugin functions have been compiled\n    }\n};\n","// @flow\n\nimport ZoomHistory from './zoom_history';\nimport {isStringInSupportedScript} from '../util/script_detection';\nimport {plugin as rtlTextPlugin} from '../source/rtl_text_plugin';\n\nimport type {TransitionSpecification} from '../style-spec/types';\n\nexport type CrossfadeParameters = {\n    fromScale: number,\n    toScale: number,\n    t: number\n};\n\nclass EvaluationParameters {\n    zoom: number;\n    now: number;\n    fadeDuration: number;\n    zoomHistory: ZoomHistory;\n    transition: TransitionSpecification;\n\n    // \"options\" may also be another EvaluationParameters to copy, see CrossFadedProperty.possiblyEvaluate\n    constructor(zoom: number, options?: *) {\n        this.zoom = zoom;\n\n        if (options) {\n            this.now = options.now;\n            this.fadeDuration = options.fadeDuration;\n            this.zoomHistory = options.zoomHistory;\n            this.transition = options.transition;\n        } else {\n            this.now = 0;\n            this.fadeDuration = 0;\n            this.zoomHistory = new ZoomHistory();\n            this.transition = {};\n        }\n    }\n\n    isSupportedScript(str: string): boolean {\n        return isStringInSupportedScript(str, rtlTextPlugin.isLoaded());\n    }\n\n    crossFadingFactor() {\n        if (this.fadeDuration === 0) {\n            return 1;\n        } else {\n            return Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);\n        }\n    }\n\n    getCrossfadeParameters(): CrossfadeParameters {\n        const z = this.zoom;\n        const fraction = z - Math.floor(z);\n        const t = this.crossFadingFactor();\n\n        return z > this.zoomHistory.lastIntegerZoom ?\n            {fromScale: 2, toScale: 1, t: fraction + (1 - fraction) * t} :\n            {fromScale: 0.5, toScale: 1, t: 1 - (1 - t) * fraction};\n    }\n}\n\nexport default EvaluationParameters;\n","// @flow\n\nimport assert from 'assert';\n\nimport {clone, extend, easeCubicInOut} from '../util/util';\nimport * as interpolate from '../style-spec/util/interpolate';\nimport {normalizePropertyExpression} from '../style-spec/expression';\nimport Color from '../style-spec/util/color';\nimport {register} from '../util/web_worker_transfer';\nimport EvaluationParameters from './evaluation_parameters';\n\nimport type {StylePropertySpecification} from '../style-spec/style-spec';\nimport type {\n    TransitionSpecification,\n    PropertyValueSpecification\n} from '../style-spec/types';\n\nimport type {\n    Feature,\n    FeatureState,\n    StylePropertyExpression,\n    SourceExpression,\n    CompositeExpression\n} from '../style-spec/expression';\n\ntype TimePoint = number;\n\nexport type CrossFaded<T> = {\n    to: T,\n    from: T\n};\n\n/**\n * Implements a number of classes that define state and behavior for paint and layout properties, most\n * importantly their respective evaluation chains:\n *\n *       Transitionable paint property value\n *     â Transitioning paint property value\n *     â Possibly evaluated paint property value\n *     â Fully evaluated paint property value\n *\n *       Layout property value\n *     â Possibly evaluated layout property value\n *     â Fully evaluated layout property value\n *\n * @module\n * @private\n */\n\n/**\n *  Implementations of the `Property` interface:\n *\n *  * Hold metadata about a property that's independent of any specific value: stuff like the type of the value,\n *    the default value, etc. This comes from the style specification JSON.\n *  * Define behavior that needs to be polymorphic across different properties: \"possibly evaluating\"\n *    an input value (see below), and interpolating between two possibly-evaluted values.\n *\n *  The type `T` is the fully-evaluated value type (e.g. `number`, `string`, `Color`).\n *  The type `R` is the intermediate \"possibly evaluated\" value type. See below.\n *\n *  There are two main implementations of the interface -- one for properties that allow data-driven values,\n *  and one for properties that don't. There are a few \"special case\" implementations as well: one for properties\n *  which cross-fade between two values rather than interpolating, one for `heatmap-color` and `line-gradient`,\n *  and one for `light-position`.\n *\n * @private\n */\nexport interface Property<T, R> {\n    specification: StylePropertySpecification;\n    possiblyEvaluate(value: PropertyValue<T, R>, parameters: EvaluationParameters, availableImages?: Array<string>): R;\n    interpolate(a: R, b: R, t: number): R;\n}\n\n/**\n *  `PropertyValue` represents the value part of a property key-value unit. It's used to represent both\n *  paint and layout property values, and regardless of whether or not their property supports data-driven\n *  expressions.\n *\n *  `PropertyValue` stores the raw input value as seen in a style or a runtime styling API call, i.e. one of the\n *  following:\n *\n *    * A constant value of the type appropriate for the property\n *    * A function which produces a value of that type (but functions are quasi-deprecated in favor of expressions)\n *    * An expression which produces a value of that type\n *    * \"undefined\"/\"not present\", in which case the property is assumed to take on its default value.\n *\n *  In addition to storing the original input value, `PropertyValue` also stores a normalized representation,\n *  effectively treating functions as if they are expressions, and constant or default values as if they are\n *  (constant) expressions.\n *\n *  @private\n */\nexport class PropertyValue<T, R> {\n    property: Property<T, R>;\n    value: PropertyValueSpecification<T> | void;\n    expression: StylePropertyExpression;\n\n    constructor(property: Property<T, R>, value: PropertyValueSpecification<T> | void) {\n        this.property = property;\n        this.value = value;\n        this.expression = normalizePropertyExpression(value === undefined ? property.specification.default : value, property.specification);\n    }\n\n    isDataDriven(): boolean {\n        return this.expression.kind === 'source' || this.expression.kind === 'composite';\n    }\n\n    possiblyEvaluate(parameters: EvaluationParameters, availableImages?: Array<string>): R {\n        return this.property.possiblyEvaluate(this, parameters, availableImages);\n    }\n}\n\n// ------- Transitionable -------\n\nexport type TransitionParameters = {\n    now: TimePoint,\n    transition: TransitionSpecification\n};\n\n/**\n * Paint properties are _transitionable_: they can change in a fluid manner, interpolating or cross-fading between\n * old and new value. The duration of the transition, and the delay before it begins, is configurable.\n *\n * `TransitionablePropertyValue` is a compositional class that stores both the property value and that transition\n * configuration.\n *\n * A `TransitionablePropertyValue` can calculate the next step in the evaluation chain for paint property values:\n * `TransitioningPropertyValue`.\n *\n * @private\n */\nclass TransitionablePropertyValue<T, R> {\n    property: Property<T, R>;\n    value: PropertyValue<T, R>;\n    transition: TransitionSpecification | void;\n\n    constructor(property: Property<T, R>) {\n        this.property = property;\n        this.value = new PropertyValue(property, undefined);\n    }\n\n    transitioned(parameters: TransitionParameters,\n                 prior: TransitioningPropertyValue<T, R>): TransitioningPropertyValue<T, R> {\n        return new TransitioningPropertyValue(this.property, this.value, prior, // eslint-disable-line no-use-before-define\n            extend({}, parameters.transition, this.transition), parameters.now);\n    }\n\n    untransitioned(): TransitioningPropertyValue<T, R> {\n        return new TransitioningPropertyValue(this.property, this.value, null, {}, 0); // eslint-disable-line no-use-before-define\n    }\n}\n\n/**\n * A helper type: given an object type `Properties` whose values are each of type `Property<T, R>`, it calculates\n * an object type with the same keys and values of type `TransitionablePropertyValue<T, R>`.\n *\n * @private\n */\ntype TransitionablePropertyValues<Props: Object>\n    = $Exact<$ObjMap<Props, <T, R>(p: Property<T, R>) => TransitionablePropertyValue<T, R>>>\n\n/**\n * `Transitionable` stores a map of all (property name, `TransitionablePropertyValue`) pairs for paint properties of a\n * given layer type. It can calculate the `TransitioningPropertyValue`s for all of them at once, producing a\n * `Transitioning` instance for the same set of properties.\n *\n * @private\n */\nexport class Transitionable<Props: Object> {\n    _properties: Properties<Props>;\n    _values: TransitionablePropertyValues<Props>;\n\n    constructor(properties: Properties<Props>) {\n        this._properties = properties;\n        this._values = (Object.create(properties.defaultTransitionablePropertyValues): any);\n    }\n\n    getValue<S: string, T>(name: S): PropertyValueSpecification<T> | void {\n        return clone(this._values[name].value.value);\n    }\n\n    setValue<S: string, T>(name: S, value: PropertyValueSpecification<T> | void) {\n        if (!this._values.hasOwnProperty(name)) {\n            this._values[name] = new TransitionablePropertyValue(this._values[name].property);\n        }\n        // Note that we do not _remove_ an own property in the case where a value is being reset\n        // to the default: the transition might still be non-default.\n        this._values[name].value = new PropertyValue(this._values[name].property, value === null ? undefined : clone(value));\n    }\n\n    getTransition<S: string>(name: S): TransitionSpecification | void {\n        return clone(this._values[name].transition);\n    }\n\n    setTransition<S: string>(name: S, value: TransitionSpecification | void) {\n        if (!this._values.hasOwnProperty(name)) {\n            this._values[name] = new TransitionablePropertyValue(this._values[name].property);\n        }\n        this._values[name].transition = clone(value) || undefined;\n    }\n\n    serialize() {\n        const result: any = {};\n        for (const property of Object.keys(this._values)) {\n            const value = this.getValue(property);\n            if (value !== undefined) {\n                result[property] = value;\n            }\n\n            const transition = this.getTransition(property);\n            if (transition !== undefined) {\n                result[`${property}-transition`] = transition;\n            }\n        }\n        return result;\n    }\n\n    transitioned(parameters: TransitionParameters, prior: Transitioning<Props>): Transitioning<Props> {\n        const result = new Transitioning(this._properties); // eslint-disable-line no-use-before-define\n        for (const property of Object.keys(this._values)) {\n            result._values[property] = this._values[property].transitioned(parameters, prior._values[property]);\n        }\n        return result;\n    }\n\n    untransitioned(): Transitioning<Props> {\n        const result = new Transitioning(this._properties); // eslint-disable-line no-use-before-define\n        for (const property of Object.keys(this._values)) {\n            result._values[property] = this._values[property].untransitioned();\n        }\n        return result;\n    }\n}\n\n// ------- Transitioning -------\n\n/**\n * `TransitioningPropertyValue` implements the first of two intermediate steps in the evaluation chain of a paint\n * property value. In this step, transitions between old and new values are handled: as long as the transition is in\n * progress, `TransitioningPropertyValue` maintains a reference to the prior value, and interpolates between it and\n * the new value based on the current time and the configured transition duration and delay. The product is the next\n * step in the evaluation chain: the \"possibly evaluated\" result type `R`. See below for more on this concept.\n *\n * @private\n */\nclass TransitioningPropertyValue<T, R> {\n    property: Property<T, R>;\n    value: PropertyValue<T, R>;\n    prior: ?TransitioningPropertyValue<T, R>;\n    begin: TimePoint;\n    end: TimePoint;\n\n    constructor(property: Property<T, R>,\n                value: PropertyValue<T, R>,\n                prior: ?TransitioningPropertyValue<T, R>,\n                transition: TransitionSpecification,\n                now: TimePoint) {\n        this.property = property;\n        this.value = value;\n        this.begin = now + transition.delay || 0;\n        this.end = this.begin + transition.duration || 0;\n        if (property.specification.transition && (transition.delay || transition.duration)) {\n            this.prior = prior;\n        }\n    }\n\n    possiblyEvaluate(parameters: EvaluationParameters, availableImages: Array<string>): R {\n        const now = parameters.now || 0;\n        const finalValue = this.value.possiblyEvaluate(parameters, availableImages);\n        const prior = this.prior;\n        if (!prior) {\n            // No prior value.\n            return finalValue;\n        } else if (now > this.end) {\n            // Transition from prior value is now complete.\n            this.prior = null;\n            return finalValue;\n        } else if (this.value.isDataDriven()) {\n            // Transitions to data-driven properties are not supported.\n            // We snap immediately to the data-driven value so that, when we perform layout,\n            // we see the data-driven function and can use it to populate vertex buffers.\n            this.prior = null;\n            return finalValue;\n        } else if (now < this.begin) {\n            // Transition hasn't started yet.\n            return prior.possiblyEvaluate(parameters, availableImages);\n        } else {\n            // Interpolate between recursively-calculated prior value and final.\n            const t = (now - this.begin) / (this.end - this.begin);\n            return this.property.interpolate(prior.possiblyEvaluate(parameters, availableImages), finalValue, easeCubicInOut(t));\n        }\n    }\n}\n\n/**\n * A helper type: given an object type `Properties` whose values are each of type `Property<T, R>`, it calculates\n * an object type with the same keys and values of type `TransitioningPropertyValue<T, R>`.\n *\n * @private\n */\ntype TransitioningPropertyValues<Props: Object>\n    = $Exact<$ObjMap<Props, <T, R>(p: Property<T, R>) => TransitioningPropertyValue<T, R>>>\n\n/**\n * `Transitioning` stores a map of all (property name, `TransitioningPropertyValue`) pairs for paint properties of a\n * given layer type. It can calculate the possibly-evaluated values for all of them at once, producing a\n * `PossiblyEvaluated` instance for the same set of properties.\n *\n * @private\n */\nexport class Transitioning<Props: Object> {\n    _properties: Properties<Props>;\n    _values: TransitioningPropertyValues<Props>;\n\n    constructor(properties: Properties<Props>) {\n        this._properties = properties;\n        this._values = (Object.create(properties.defaultTransitioningPropertyValues): any);\n    }\n\n    possiblyEvaluate(parameters: EvaluationParameters, availableImages?: Array<string>): PossiblyEvaluated<Props> {\n        const result = new PossiblyEvaluated(this._properties); // eslint-disable-line no-use-before-define\n        for (const property of Object.keys(this._values)) {\n            result._values[property] = this._values[property].possiblyEvaluate(parameters, availableImages);\n        }\n        return result;\n    }\n\n    hasTransition() {\n        for (const property of Object.keys(this._values)) {\n            if (this._values[property].prior) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n// ------- Layout -------\n\n/**\n * A helper type: given an object type `Properties` whose values are each of type `Property<T, R>`, it calculates\n * an object type with the same keys and values of type `PropertyValue<T, R>`.\n *\n * @private\n */\ntype PropertyValues<Props: Object>\n    = $Exact<$ObjMap<Props, <T, R>(p: Property<T, R>) => PropertyValue<T, R>>>\n\n/**\n * Because layout properties are not transitionable, they have a simpler representation and evaluation chain than\n * paint properties: `PropertyValue`s are possibly evaluated, producing possibly evaluated values, which are then\n * fully evaluated.\n *\n * `Layout` stores a map of all (property name, `PropertyValue`) pairs for layout properties of a\n * given layer type. It can calculate the possibly-evaluated values for all of them at once, producing a\n * `PossiblyEvaluated` instance for the same set of properties.\n *\n * @private\n */\nexport class Layout<Props: Object> {\n    _properties: Properties<Props>;\n    _values: PropertyValues<Props>;\n\n    constructor(properties: Properties<Props>) {\n        this._properties = properties;\n        this._values = (Object.create(properties.defaultPropertyValues): any);\n    }\n\n    getValue<S: string>(name: S) {\n        return clone(this._values[name].value);\n    }\n\n    setValue<S: string>(name: S, value: *) {\n        this._values[name] = new PropertyValue(this._values[name].property, value === null ? undefined : clone(value));\n    }\n\n    serialize() {\n        const result: any = {};\n        for (const property of Object.keys(this._values)) {\n            const value = this.getValue(property);\n            if (value !== undefined) {\n                result[property] = value;\n            }\n        }\n        return result;\n    }\n\n    possiblyEvaluate(parameters: EvaluationParameters, availableImages?: Array<string>): PossiblyEvaluated<Props> {\n        const result = new PossiblyEvaluated(this._properties); // eslint-disable-line no-use-before-define\n        for (const property of Object.keys(this._values)) {\n            result._values[property] = this._values[property].possiblyEvaluate(parameters, availableImages);\n        }\n        return result;\n    }\n}\n\n// ------- PossiblyEvaluated -------\n\n/**\n * \"Possibly evaluated value\" is an intermediate stage in the evaluation chain for both paint and layout property\n * values. The purpose of this stage is to optimize away unnecessary recalculations for data-driven properties. Code\n * which uses data-driven property values must assume that the value is dependent on feature data, and request that it\n * be evaluated for each feature. But when that property value is in fact a constant or camera function, the calculation\n * will not actually depend on the feature, and we can benefit from returning the prior result of having done the\n * evaluation once, ahead of time, in an intermediate step whose inputs are just the value and \"global\" parameters\n * such as current zoom level.\n *\n * `PossiblyEvaluatedValue` represents the three possible outcomes of this step: if the input value was a constant or\n * camera expression, then the \"possibly evaluated\" result is a constant value. Otherwise, the input value was either\n * a source or composite expression, and we must defer final evaluation until supplied a feature. We separate\n * the source and composite cases because they are handled differently when generating GL attributes, buffers, and\n * uniforms.\n *\n * Note that `PossiblyEvaluatedValue` (and `PossiblyEvaluatedPropertyValue`, below) are _not_ used for properties that\n * do not allow data-driven values. For such properties, we know that the \"possibly evaluated\" result is always a constant\n * scalar value. See below.\n *\n * @private\n */\ntype PossiblyEvaluatedValue<T> =\n    | {kind: 'constant', value: T}\n    | SourceExpression\n    | CompositeExpression;\n\n/**\n * `PossiblyEvaluatedPropertyValue` is used for data-driven paint and layout property values. It holds a\n * `PossiblyEvaluatedValue` and the `GlobalProperties` that were used to generate it. You're not allowed to supply\n * a different set of `GlobalProperties` when performing the final evaluation because they would be ignored in the\n * case where the input value was a constant or camera function.\n *\n * @private\n */\nexport class PossiblyEvaluatedPropertyValue<T> {\n    property: DataDrivenProperty<T>;\n    value: PossiblyEvaluatedValue<T>;\n    parameters: EvaluationParameters;\n\n    constructor(property: DataDrivenProperty<T>, value: PossiblyEvaluatedValue<T>, parameters: EvaluationParameters) {\n        this.property = property;\n        this.value = value;\n        this.parameters = parameters;\n    }\n\n    isConstant(): boolean {\n        return this.value.kind === 'constant';\n    }\n\n    constantOr(value: T): T {\n        if (this.value.kind === 'constant') {\n            return this.value.value;\n        } else {\n            return value;\n        }\n    }\n\n    evaluate(feature: Feature, featureState: FeatureState, availableImages?: Array<string>): T {\n        return this.property.evaluate(this.value, this.parameters, feature, featureState, availableImages);\n    }\n}\n\n/**\n * A helper type: given an object type `Properties` whose values are each of type `Property<T, R>`, it calculates\n * an object type with the same keys, and values of type `R`.\n *\n * For properties that don't allow data-driven values, `R` is a scalar type such as `number`, `string`, or `Color`.\n * For data-driven properties, it is `PossiblyEvaluatedPropertyValue`. Critically, the type definitions are set up\n * in a way that allows flow to know which of these two cases applies for any given property name, and if you attempt\n * to use a `PossiblyEvaluatedPropertyValue` as if it was a scalar, or vice versa, you will get a type error. (However,\n * there's at least one case in which flow fails to produce a type error that you should be aware of: in a context such\n * as `layer.paint.get('foo-opacity') === 0`, if `foo-opacity` is data-driven, than the left-hand side is of type\n * `PossiblyEvaluatedPropertyValue<number>`, but flow will not complain about comparing this to a number using `===`.\n * See https://github.com/facebook/flow/issues/2359.)\n *\n * There's also a third, special case possiblity for `R`: for cross-faded properties, it's `?CrossFaded<T>`.\n *\n * @private\n */\ntype PossiblyEvaluatedPropertyValues<Props: Object>\n    = $Exact<$ObjMap<Props, <T, R>(p: Property<T, R>) => R>>\n\n/**\n * `PossiblyEvaluated` stores a map of all (property name, `R`) pairs for paint or layout properties of a\n * given layer type.\n * @private\n */\nexport class PossiblyEvaluated<Props: Object> {\n    _properties: Properties<Props>;\n    _values: PossiblyEvaluatedPropertyValues<Props>;\n\n    constructor(properties: Properties<Props>) {\n        this._properties = properties;\n        this._values = (Object.create(properties.defaultPossiblyEvaluatedValues): any);\n    }\n\n    get<S: string>(name: S): $ElementType<PossiblyEvaluatedPropertyValues<Props>, S> {\n        return this._values[name];\n    }\n}\n\n/**\n * An implementation of `Property` for properties that do not permit data-driven (source or composite) expressions.\n * This restriction allows us to declare statically that the result of possibly evaluating this kind of property\n * is in fact always the scalar type `T`, and can be used without further evaluating the value on a per-feature basis.\n *\n * @private\n */\nexport class DataConstantProperty<T> implements Property<T, T> {\n    specification: StylePropertySpecification;\n\n    constructor(specification: StylePropertySpecification) {\n        this.specification = specification;\n    }\n\n    possiblyEvaluate(value: PropertyValue<T, T>, parameters: EvaluationParameters): T {\n        assert(!value.isDataDriven());\n        return value.expression.evaluate(parameters);\n    }\n\n    interpolate(a: T, b: T, t: number): T {\n        const interp: ?(a: T, b: T, t: number) => T = (interpolate: any)[this.specification.type];\n        if (interp) {\n            return interp(a, b, t);\n        } else {\n            return a;\n        }\n    }\n}\n\n/**\n * An implementation of `Property` for properties that permit data-driven (source or composite) expressions.\n * The result of possibly evaluating this kind of property is `PossiblyEvaluatedPropertyValue<T>`; obtaining\n * a scalar value `T` requires further evaluation on a per-feature basis.\n *\n * @private\n */\nexport class DataDrivenProperty<T> implements Property<T, PossiblyEvaluatedPropertyValue<T>> {\n    specification: StylePropertySpecification;\n    overrides: ?Object;\n\n    constructor(specification: StylePropertySpecification, overrides?: Object) {\n        this.specification = specification;\n        this.overrides = overrides;\n    }\n\n    possiblyEvaluate(value: PropertyValue<T, PossiblyEvaluatedPropertyValue<T>>, parameters: EvaluationParameters, availableImages?: Array<string>): PossiblyEvaluatedPropertyValue<T> {\n        if (value.expression.kind === 'constant' || value.expression.kind === 'camera') {\n            return new PossiblyEvaluatedPropertyValue(this, {kind: 'constant', value: value.expression.evaluate(parameters, (null: any), {}, availableImages)}, parameters);\n        } else {\n            return new PossiblyEvaluatedPropertyValue(this, value.expression, parameters);\n        }\n    }\n\n    interpolate(a: PossiblyEvaluatedPropertyValue<T>,\n                b: PossiblyEvaluatedPropertyValue<T>,\n                t: number): PossiblyEvaluatedPropertyValue<T> {\n        // If either possibly-evaluated value is non-constant, give up: we aren't able to interpolate data-driven values.\n        if (a.value.kind !== 'constant' || b.value.kind !== 'constant') {\n            return a;\n        }\n\n        // Special case hack solely for fill-outline-color. The undefined value is subsequently handled in\n        // FillStyleLayer#recalculate, which sets fill-outline-color to the fill-color value if the former\n        // is a PossiblyEvaluatedPropertyValue containing a constant undefined value. In addition to the\n        // return value here, the other source of a PossiblyEvaluatedPropertyValue containing a constant\n        // undefined value is the \"default value\" for fill-outline-color held in\n        // `Properties#defaultPossiblyEvaluatedValues`, which serves as the prototype of\n        // `PossiblyEvaluated#_values`.\n        if (a.value.value === undefined || b.value.value === undefined) {\n            return new PossiblyEvaluatedPropertyValue(this, {kind: 'constant', value: (undefined: any)}, a.parameters);\n        }\n\n        const interp: ?(a: T, b: T, t: number) => T = (interpolate: any)[this.specification.type];\n        if (interp) {\n            return new PossiblyEvaluatedPropertyValue(this, {kind: 'constant', value: interp(a.value.value, b.value.value, t)}, a.parameters);\n        } else {\n            return a;\n        }\n    }\n\n    evaluate(value: PossiblyEvaluatedValue<T>, parameters: EvaluationParameters, feature: Feature, featureState: FeatureState, availableImages?: Array<string>): T {\n        if (value.kind === 'constant') {\n            return value.value;\n        } else {\n            return value.evaluate(parameters, feature, featureState, availableImages);\n        }\n    }\n}\n\n/**\n * An implementation of `Property` for  data driven `line-pattern` which are transitioned by cross-fading\n * rather than interpolation.\n *\n * @private\n */\n\nexport class CrossFadedDataDrivenProperty<T> extends DataDrivenProperty<?CrossFaded<T>> {\n\n    possiblyEvaluate(value: PropertyValue<?CrossFaded<T>, PossiblyEvaluatedPropertyValue<?CrossFaded<T>>>, parameters: EvaluationParameters, availableImages?: Array<string>): PossiblyEvaluatedPropertyValue<?CrossFaded<T>> {\n        if (value.value === undefined) {\n            return new PossiblyEvaluatedPropertyValue(this, {kind: 'constant', value: undefined}, parameters);\n        } else if (value.expression.kind === 'constant') {\n            const evaluatedValue = value.expression.evaluate(parameters, (null: any), {}, availableImages);\n            const isImageExpression = value.property.specification.type === 'resolvedImage';\n            const constantValue = isImageExpression && typeof evaluatedValue !== 'string' ? evaluatedValue.name : evaluatedValue;\n            const constant = this._calculate(constantValue, constantValue, constantValue, parameters);\n            return new PossiblyEvaluatedPropertyValue(this, {kind: 'constant', value: constant}, parameters);\n        } else if (value.expression.kind === 'camera') {\n            const cameraVal = this._calculate(\n                    value.expression.evaluate({zoom: parameters.zoom - 1.0}),\n                    value.expression.evaluate({zoom: parameters.zoom}),\n                    value.expression.evaluate({zoom: parameters.zoom + 1.0}),\n                    parameters);\n            return new PossiblyEvaluatedPropertyValue(this, {kind: 'constant', value: cameraVal}, parameters);\n        } else {\n            // source or composite expression\n            return new PossiblyEvaluatedPropertyValue(this, value.expression, parameters);\n        }\n    }\n\n    evaluate(value: PossiblyEvaluatedValue<?CrossFaded<T>>, globals: EvaluationParameters, feature: Feature, featureState: FeatureState, availableImages?: Array<string>): ?CrossFaded<T> {\n        if (value.kind === 'source') {\n            const constant = value.evaluate(globals, feature, featureState, availableImages);\n            return this._calculate(constant, constant, constant, globals);\n        } else if (value.kind === 'composite') {\n            return this._calculate(\n                value.evaluate({zoom: Math.floor(globals.zoom) - 1.0}, feature, featureState),\n                value.evaluate({zoom: Math.floor(globals.zoom)}, feature, featureState),\n                value.evaluate({zoom: Math.floor(globals.zoom) + 1.0}, feature, featureState),\n                globals);\n        } else {\n            return value.value;\n        }\n    }\n\n    _calculate(min: T, mid: T, max: T, parameters: EvaluationParameters): CrossFaded<T> {\n        const z = parameters.zoom;\n        return z > parameters.zoomHistory.lastIntegerZoom ? {from: min, to: mid} : {from: max, to: mid};\n    }\n\n    interpolate(a: PossiblyEvaluatedPropertyValue<?CrossFaded<T>>): PossiblyEvaluatedPropertyValue<?CrossFaded<T>> {\n        return a;\n    }\n}\n/**\n * An implementation of `Property` for `*-pattern` and `line-dasharray`, which are transitioned by cross-fading\n * rather than interpolation.\n *\n * @private\n */\nexport class CrossFadedProperty<T> implements Property<T, ?CrossFaded<T>> {\n    specification: StylePropertySpecification;\n\n    constructor(specification: StylePropertySpecification) {\n        this.specification = specification;\n    }\n\n    possiblyEvaluate(value: PropertyValue<T, ?CrossFaded<T>>, parameters: EvaluationParameters, availableImages?: Array<string>): ?CrossFaded<T> {\n        if (value.value === undefined) {\n            return undefined;\n        } else if (value.expression.kind === 'constant') {\n            const constant = value.expression.evaluate(parameters, (null: any), {}, availableImages);\n            return this._calculate(constant, constant, constant, parameters);\n        } else {\n            assert(!value.isDataDriven());\n            return this._calculate(\n                value.expression.evaluate(new EvaluationParameters(Math.floor(parameters.zoom - 1.0), parameters)),\n                value.expression.evaluate(new EvaluationParameters(Math.floor(parameters.zoom), parameters)),\n                value.expression.evaluate(new EvaluationParameters(Math.floor(parameters.zoom + 1.0), parameters)),\n                parameters);\n        }\n    }\n\n    _calculate(min: T, mid: T, max: T, parameters: EvaluationParameters): ?CrossFaded<T> {\n        const z = parameters.zoom;\n        return z > parameters.zoomHistory.lastIntegerZoom ? {from: min, to: mid} : {from: max, to: mid};\n    }\n\n    interpolate(a: ?CrossFaded<T>): ?CrossFaded<T> {\n        return a;\n    }\n}\n\n/**\n * An implementation of `Property` for `heatmap-color` and `line-gradient`. Interpolation is a no-op, and\n * evaluation returns a boolean value in order to indicate its presence, but the real\n * evaluation happens in StyleLayer classes.\n *\n * @private\n */\n\nexport class ColorRampProperty implements Property<Color, boolean> {\n    specification: StylePropertySpecification;\n\n    constructor(specification: StylePropertySpecification) {\n        this.specification = specification;\n    }\n\n    possiblyEvaluate(value: PropertyValue<Color, boolean>, parameters: EvaluationParameters, availableImages?: Array<string>): boolean {\n        return !!value.expression.evaluate(parameters, (null: any), {}, availableImages);\n    }\n\n    interpolate(): boolean { return false; }\n}\n\n/**\n * `Properties` holds objects containing default values for the layout or paint property set of a given\n * layer type. These objects are immutable, and they are used as the prototypes for the `_values` members of\n * `Transitionable`, `Transitioning`, `Layout`, and `PossiblyEvaluated`. This allows these classes to avoid\n * doing work in the common case where a property has no explicit value set and should be considered to take\n * on the default value: using `for (const property of Object.keys(this._values))`, they can iterate over\n * only the _own_ properties of `_values`, skipping repeated calculation of transitions and possible/final\n * evaluations for defaults, the result of which will always be the same.\n *\n * @private\n */\nexport class Properties<Props: Object> {\n    properties: Props;\n    defaultPropertyValues: PropertyValues<Props>;\n    defaultTransitionablePropertyValues: TransitionablePropertyValues<Props>;\n    defaultTransitioningPropertyValues: TransitioningPropertyValues<Props>;\n    defaultPossiblyEvaluatedValues: PossiblyEvaluatedPropertyValues<Props>;\n    overridableProperties: Array<string>;\n\n    constructor(properties: Props) {\n        this.properties = properties;\n        this.defaultPropertyValues = ({}: any);\n        this.defaultTransitionablePropertyValues = ({}: any);\n        this.defaultTransitioningPropertyValues = ({}: any);\n        this.defaultPossiblyEvaluatedValues = ({}: any);\n        this.overridableProperties = ([]: any);\n\n        for (const property in properties) {\n            const prop = properties[property];\n            if (prop.specification.overridable) {\n                this.overridableProperties.push(property);\n            }\n            const defaultPropertyValue = this.defaultPropertyValues[property] =\n                new PropertyValue(prop, undefined);\n            const defaultTransitionablePropertyValue = this.defaultTransitionablePropertyValues[property] =\n                new TransitionablePropertyValue(prop);\n            this.defaultTransitioningPropertyValues[property] =\n                defaultTransitionablePropertyValue.untransitioned();\n            this.defaultPossiblyEvaluatedValues[property] =\n                defaultPropertyValue.possiblyEvaluate(({}: any));\n        }\n    }\n}\n\nregister('DataDrivenProperty', DataDrivenProperty);\nregister('DataConstantProperty', DataConstantProperty);\nregister('CrossFadedDataDrivenProperty', CrossFadedDataDrivenProperty);\nregister('CrossFadedProperty', CrossFadedProperty);\nregister('ColorRampProperty', ColorRampProperty);\n","// @flow\n\nimport assert from 'assert';\n\nimport extend from '../util/extend';\nimport ParsingError from './parsing_error';\nimport ParsingContext from './parsing_context';\nimport EvaluationContext from './evaluation_context';\nimport CompoundExpression from './compound_expression';\nimport Step from './definitions/step';\nimport Interpolate from './definitions/interpolate';\nimport Coalesce from './definitions/coalesce';\nimport Let from './definitions/let';\nimport definitions from './definitions';\nimport * as isConstant from './is_constant';\nimport RuntimeError from './runtime_error';\nimport {success, error} from '../util/result';\nimport {supportsPropertyExpression, supportsZoomExpression, supportsInterpolation} from '../util/properties';\n\nimport type {Type, EvaluationKind} from './types';\nimport type {Value} from './values';\nimport type {Expression} from './expression';\nimport type {StylePropertySpecification} from '../style-spec';\nimport type {Result} from '../util/result';\nimport type {InterpolationType} from './definitions/interpolate';\nimport type {PropertyValueSpecification} from '../types';\nimport type {FormattedSection} from './types/formatted';\n\nexport type Feature = {\n    +type: 1 | 2 | 3 | 'Unknown' | 'Point' | 'MultiPoint' | 'LineString' | 'MultiLineString' | 'Polygon' | 'MultiPolygon',\n    +id?: any,\n    +properties: {[string]: any},\n    +patterns?: {[string]: {\"min\": string, \"mid\": string, \"max\": string}}\n};\n\nexport type FeatureState = {[string]: any};\n\nexport type GlobalProperties = $ReadOnly<{\n    zoom: number,\n    heatmapDensity?: number,\n    lineProgress?: number,\n    isSupportedScript?: (string) => boolean,\n    accumulated?: Value\n}>;\n\nexport class StyleExpression {\n    expression: Expression;\n\n    _evaluator: EvaluationContext;\n    _defaultValue: Value;\n    _warningHistory: {[key: string]: boolean};\n    _enumValues: ?{[string]: any};\n\n    constructor(expression: Expression, propertySpec: ?StylePropertySpecification) {\n        this.expression = expression;\n        this._warningHistory = {};\n        this._evaluator = new EvaluationContext();\n        this._defaultValue = propertySpec ? getDefaultValue(propertySpec) : null;\n        this._enumValues = propertySpec && propertySpec.type === 'enum' ? propertySpec.values : null;\n    }\n\n    evaluateWithoutErrorHandling(globals: GlobalProperties, feature?: Feature, featureState?: FeatureState, availableImages?: Array<string>, formattedSection?: FormattedSection): any {\n        this._evaluator.globals = globals;\n        this._evaluator.feature = feature;\n        this._evaluator.featureState = featureState;\n        this._evaluator.availableImages = availableImages || null;\n        this._evaluator.formattedSection = formattedSection;\n\n        return this.expression.evaluate(this._evaluator);\n    }\n\n    evaluate(globals: GlobalProperties, feature?: Feature, featureState?: FeatureState, availableImages?: Array<string>, formattedSection?: FormattedSection): any {\n        this._evaluator.globals = globals;\n        this._evaluator.feature = feature || null;\n        this._evaluator.featureState = featureState || null;\n        this._evaluator.availableImages = availableImages || null;\n        this._evaluator.formattedSection = formattedSection || null;\n\n        try {\n            const val = this.expression.evaluate(this._evaluator);\n            if (val === null || val === undefined) {\n                return this._defaultValue;\n            }\n            if (this._enumValues && !(val in this._enumValues)) {\n                throw new RuntimeError(`Expected value to be one of ${Object.keys(this._enumValues).map(v => JSON.stringify(v)).join(', ')}, but found ${JSON.stringify(val)} instead.`);\n            }\n            return val;\n        } catch (e) {\n            if (!this._warningHistory[e.message]) {\n                this._warningHistory[e.message] = true;\n                if (typeof console !== 'undefined') {\n                    console.warn(e.message);\n                }\n            }\n            return this._defaultValue;\n        }\n    }\n}\n\nexport function isExpression(expression: mixed) {\n    return Array.isArray(expression) && expression.length > 0 &&\n        typeof expression[0] === 'string' && expression[0] in definitions;\n}\n\n/**\n * Parse and typecheck the given style spec JSON expression.  If\n * options.defaultValue is provided, then the resulting StyleExpression's\n * `evaluate()` method will handle errors by logging a warning (once per\n * message) and returning the default value.  Otherwise, it will throw\n * evaluation errors.\n *\n * @private\n */\nexport function createExpression(expression: mixed, propertySpec: ?StylePropertySpecification): Result<StyleExpression, Array<ParsingError>> {\n    const parser = new ParsingContext(definitions, [], propertySpec ? getExpectedType(propertySpec) : undefined);\n\n    // For string-valued properties, coerce to string at the top level rather than asserting.\n    const parsed = parser.parse(expression, undefined, undefined, undefined,\n        propertySpec && propertySpec.type === 'string' ? {typeAnnotation: 'coerce'} : undefined);\n\n    if (!parsed) {\n        assert(parser.errors.length > 0);\n        return error(parser.errors);\n    }\n\n    return success(new StyleExpression(parsed, propertySpec));\n}\n\nexport class ZoomConstantExpression<Kind: EvaluationKind> {\n    kind: Kind;\n    isStateDependent: boolean;\n    _styleExpression: StyleExpression;\n\n    constructor(kind: Kind, expression: StyleExpression) {\n        this.kind = kind;\n        this._styleExpression = expression;\n        this.isStateDependent = kind !== ('constant': EvaluationKind) && !isConstant.isStateConstant(expression.expression);\n    }\n\n    evaluateWithoutErrorHandling(globals: GlobalProperties, feature?: Feature, featureState?: FeatureState, availableImages?: Array<string>, formattedSection?: FormattedSection): any {\n        return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, availableImages, formattedSection);\n    }\n\n    evaluate(globals: GlobalProperties, feature?: Feature, featureState?: FeatureState, availableImages?: Array<string>, formattedSection?: FormattedSection): any {\n        return this._styleExpression.evaluate(globals, feature, featureState, availableImages, formattedSection);\n    }\n}\n\nexport class ZoomDependentExpression<Kind: EvaluationKind> {\n    kind: Kind;\n    zoomStops: Array<number>;\n    isStateDependent: boolean;\n\n    _styleExpression: StyleExpression;\n    interpolationType: ?InterpolationType;\n\n    constructor(kind: Kind, expression: StyleExpression, zoomStops: Array<number>, interpolationType?: InterpolationType) {\n        this.kind = kind;\n        this.zoomStops = zoomStops;\n        this._styleExpression = expression;\n        this.isStateDependent = kind !== ('camera': EvaluationKind) && !isConstant.isStateConstant(expression.expression);\n        this.interpolationType = interpolationType;\n    }\n\n    evaluateWithoutErrorHandling(globals: GlobalProperties, feature?: Feature, featureState?: FeatureState, availableImages?: Array<string>, formattedSection?: FormattedSection): any {\n        return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, availableImages, formattedSection);\n    }\n\n    evaluate(globals: GlobalProperties, feature?: Feature, featureState?: FeatureState, availableImages?: Array<string>, formattedSection?: FormattedSection): any {\n        return this._styleExpression.evaluate(globals, feature, featureState, availableImages, formattedSection);\n    }\n\n    interpolationFactor(input: number, lower: number, upper: number): number {\n        if (this.interpolationType) {\n            return Interpolate.interpolationFactor(this.interpolationType, input, lower, upper);\n        } else {\n            return 0;\n        }\n    }\n}\n\nexport type ConstantExpression = {\n    kind: 'constant',\n    +evaluate: (globals: GlobalProperties, feature?: Feature, featureState?: FeatureState, availableImages?: Array<string>) => any,\n}\n\nexport type SourceExpression = {\n    kind: 'source',\n    isStateDependent: boolean,\n    +evaluate: (globals: GlobalProperties, feature?: Feature, featureState?: FeatureState, availableImages?: Array<string>, formattedSection?: FormattedSection) => any,\n};\n\nexport type CameraExpression = {\n    kind: 'camera',\n    +evaluate: (globals: GlobalProperties, feature?: Feature, featureState?: FeatureState, availableImages?: Array<string>) => any,\n    +interpolationFactor: (input: number, lower: number, upper: number) => number,\n    zoomStops: Array<number>,\n    interpolationType: ?InterpolationType\n};\n\nexport type CompositeExpression = {\n    kind: 'composite',\n    isStateDependent: boolean,\n    +evaluate: (globals: GlobalProperties, feature?: Feature, featureState?: FeatureState, availableImages?: Array<string>, formattedSection?: FormattedSection) => any,\n    +interpolationFactor: (input: number, lower: number, upper: number) => number,\n    zoomStops: Array<number>,\n    interpolationType: ?InterpolationType\n};\n\nexport type StylePropertyExpression =\n    | ConstantExpression\n    | SourceExpression\n    | CameraExpression\n    | CompositeExpression;\n\nexport function createPropertyExpression(expression: mixed, propertySpec: StylePropertySpecification): Result<StylePropertyExpression, Array<ParsingError>> {\n    expression = createExpression(expression, propertySpec);\n    if (expression.result === 'error') {\n        return expression;\n    }\n\n    const parsed = expression.value.expression;\n\n    const isFeatureConstant = isConstant.isFeatureConstant(parsed);\n    if (!isFeatureConstant && !supportsPropertyExpression(propertySpec)) {\n        return error([new ParsingError('', 'data expressions not supported')]);\n    }\n\n    const isZoomConstant = isConstant.isGlobalPropertyConstant(parsed, ['zoom']);\n    if (!isZoomConstant && !supportsZoomExpression(propertySpec)) {\n        return error([new ParsingError('', 'zoom expressions not supported')]);\n    }\n\n    const zoomCurve = findZoomCurve(parsed);\n    if (!zoomCurve && !isZoomConstant) {\n        return error([new ParsingError('', '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.')]);\n    } else if (zoomCurve instanceof ParsingError) {\n        return error([zoomCurve]);\n    } else if (zoomCurve instanceof Interpolate && !supportsInterpolation(propertySpec)) {\n        return error([new ParsingError('', '\"interpolate\" expressions cannot be used with this property')]);\n    }\n\n    if (!zoomCurve) {\n        return success(isFeatureConstant ?\n            (new ZoomConstantExpression('constant', expression.value): ConstantExpression) :\n            (new ZoomConstantExpression('source', expression.value): SourceExpression));\n    }\n\n    const interpolationType = zoomCurve instanceof Interpolate ? zoomCurve.interpolation : undefined;\n\n    return success(isFeatureConstant ?\n        (new ZoomDependentExpression('camera', expression.value, zoomCurve.labels, interpolationType): CameraExpression) :\n        (new ZoomDependentExpression('composite', expression.value, zoomCurve.labels, interpolationType): CompositeExpression));\n}\n\nimport {isFunction, createFunction} from '../function';\nimport {Color} from './values';\n\n// serialization wrapper for old-style stop functions normalized to the\n// expression interface\nexport class StylePropertyFunction<T> {\n    _parameters: PropertyValueSpecification<T>;\n    _specification: StylePropertySpecification;\n\n    kind: EvaluationKind;\n    evaluate: (globals: GlobalProperties, feature?: Feature) => any;\n    interpolationFactor: ?(input: number, lower: number, upper: number) => number;\n    zoomStops: ?Array<number>;\n\n    constructor(parameters: PropertyValueSpecification<T>, specification: StylePropertySpecification) {\n        this._parameters = parameters;\n        this._specification = specification;\n        extend(this, createFunction(this._parameters, this._specification));\n    }\n\n    static deserialize(serialized: {_parameters: PropertyValueSpecification<T>, _specification: StylePropertySpecification}) {\n        return ((new StylePropertyFunction(serialized._parameters, serialized._specification)): StylePropertyFunction<T>);\n    }\n\n    static serialize(input: StylePropertyFunction<T>) {\n        return {\n            _parameters: input._parameters,\n            _specification: input._specification\n        };\n    }\n}\n\nexport function normalizePropertyExpression<T>(value: PropertyValueSpecification<T>, specification: StylePropertySpecification): StylePropertyExpression {\n    if (isFunction(value)) {\n        return (new StylePropertyFunction(value, specification): any);\n\n    } else if (isExpression(value)) {\n        const expression = createPropertyExpression(value, specification);\n        if (expression.result === 'error') {\n            // this should have been caught in validation\n            throw new Error(expression.value.map(err => `${err.key}: ${err.message}`).join(', '));\n        }\n        return expression.value;\n\n    } else {\n        let constant: any = value;\n        if (typeof value === 'string' && specification.type === 'color') {\n            constant = Color.parse(value);\n        }\n        return {\n            kind: 'constant',\n            evaluate: () => constant\n        };\n    }\n}\n\n// Zoom-dependent expressions may only use [\"zoom\"] as the input to a top-level \"step\" or \"interpolate\"\n// expression (collectively referred to as a \"curve\"). The curve may be wrapped in one or more \"let\" or\n// \"coalesce\" expressions.\nfunction findZoomCurve(expression: Expression): Step | Interpolate | ParsingError | null {\n    let result = null;\n    if (expression instanceof Let) {\n        result = findZoomCurve(expression.result);\n\n    } else if (expression instanceof Coalesce) {\n        for (const arg of expression.args) {\n            result = findZoomCurve(arg);\n            if (result) {\n                break;\n            }\n        }\n\n    } else if ((expression instanceof Step || expression instanceof Interpolate) &&\n        expression.input instanceof CompoundExpression &&\n        expression.input.name === 'zoom') {\n\n        result = expression;\n    }\n\n    if (result instanceof ParsingError) {\n        return result;\n    }\n\n    expression.eachChild((child) => {\n        const childResult = findZoomCurve(child);\n        if (childResult instanceof ParsingError) {\n            result = childResult;\n        } else if (!result && childResult) {\n            result = new ParsingError('', '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.');\n        } else if (result && childResult && result !== childResult) {\n            result = new ParsingError('', 'Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression.');\n        }\n    });\n\n    return result;\n}\n\nimport {ColorType, StringType, NumberType, BooleanType, ValueType, FormattedType, ResolvedImageType, array} from './types';\n\nfunction getExpectedType(spec: StylePropertySpecification): Type {\n    const types = {\n        color: ColorType,\n        string: StringType,\n        number: NumberType,\n        enum: StringType,\n        boolean: BooleanType,\n        formatted: FormattedType,\n        resolvedImage: ResolvedImageType\n    };\n\n    if (spec.type === 'array') {\n        return array(types[spec.value] || ValueType, spec.length);\n    }\n\n    return types[spec.type];\n}\n\nfunction getDefaultValue(spec: StylePropertySpecification): Value {\n    if (spec.type === 'color' && isFunction(spec.default)) {\n        // Special case for heatmap-color: it uses the 'default:' to define a\n        // default color ramp, but createExpression expects a simple value to fall\n        // back to in case of runtime errors\n        return new Color(0, 0, 0, 0);\n    } else if (spec.type === 'color') {\n        return Color.parse(spec.default) || null;\n    } else if (spec.default === undefined) {\n        return null;\n    } else {\n        return spec.default;\n    }\n}\n","import * as glMatrix from \"./common.js\";\n/**\r\n * 4 Dimensional Vector\r\n * @module vec4\r\n */\n\n/**\r\n * Creates a new, empty vec4\r\n *\r\n * @returns {vec4} a new 4D vector\r\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n  }\n\n  return out;\n}\n/**\r\n * Creates a new vec4 initialized with values from an existing vector\r\n *\r\n * @param {vec4} a vector to clone\r\n * @returns {vec4} a new 4D vector\r\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Creates a new vec4 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {vec4} a new 4D vector\r\n */\n\nexport function fromValues(x, y, z, w) {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\r\n * Copy the values from one vec4 to another\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the source vector\r\n * @returns {vec4} out\r\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Set the components of a vec4 to the given values\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {vec4} out\r\n */\n\nexport function set(out, x, y, z, w) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = w;\n  return out;\n}\n/**\r\n * Adds two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  out[3] = a[3] + b[3];\n  return out;\n}\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  out[3] = a[3] - b[3];\n  return out;\n}\n/**\r\n * Multiplies two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  out[3] = a[3] * b[3];\n  return out;\n}\n/**\r\n * Divides two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  out[3] = a[3] / b[3];\n  return out;\n}\n/**\r\n * Math.ceil the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to ceil\r\n * @returns {vec4} out\r\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  out[3] = Math.ceil(a[3]);\n  return out;\n}\n/**\r\n * Math.floor the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to floor\r\n * @returns {vec4} out\r\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  out[3] = Math.floor(a[3]);\n  return out;\n}\n/**\r\n * Returns the minimum of two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  out[3] = Math.min(a[3], b[3]);\n  return out;\n}\n/**\r\n * Returns the maximum of two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  out[3] = Math.max(a[3], b[3]);\n  return out;\n}\n/**\r\n * Math.round the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to round\r\n * @returns {vec4} out\r\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  out[3] = Math.round(a[3]);\n  return out;\n}\n/**\r\n * Scales a vec4 by a scalar number\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec4} out\r\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  out[3] = a[3] * b;\n  return out;\n}\n/**\r\n * Adds two vec4's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec4} out\r\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  out[3] = a[3] + b[3] * scale;\n  return out;\n}\n/**\r\n * Calculates the euclidian distance between two vec4's\r\n *\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\r\n * Calculates the squared euclidian distance between two vec4's\r\n *\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  var w = b[3] - a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\r\n * Calculates the length of a vec4\r\n *\r\n * @param {vec4} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return Math.hypot(x, y, z, w);\n}\n/**\r\n * Calculates the squared length of a vec4\r\n *\r\n * @param {vec4} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  return x * x + y * y + z * z + w * w;\n}\n/**\r\n * Negates the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to negate\r\n * @returns {vec4} out\r\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = -a[3];\n  return out;\n}\n/**\r\n * Returns the inverse of the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to invert\r\n * @returns {vec4} out\r\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n}\n/**\r\n * Normalize a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to normalize\r\n * @returns {vec4} out\r\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var w = a[3];\n  var len = x * x + y * y + z * z + w * w;\n\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = x * len;\n  out[1] = y * len;\n  out[2] = z * len;\n  out[3] = w * len;\n  return out;\n}\n/**\r\n * Calculates the dot product of two vec4's\r\n *\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n/**\r\n * Returns the cross-product of three vectors in a 4-dimensional space\r\n *\r\n * @param {vec4} result the receiving vector\r\n * @param {vec4} U the first vector\r\n * @param {vec4} V the second vector\r\n * @param {vec4} W the third vector\r\n * @returns {vec4} result\r\n */\n\nexport function cross(out, u, v, w) {\n  var A = v[0] * w[1] - v[1] * w[0],\n      B = v[0] * w[2] - v[2] * w[0],\n      C = v[0] * w[3] - v[3] * w[0],\n      D = v[1] * w[2] - v[2] * w[1],\n      E = v[1] * w[3] - v[3] * w[1],\n      F = v[2] * w[3] - v[3] * w[2];\n  var G = u[0];\n  var H = u[1];\n  var I = u[2];\n  var J = u[3];\n  out[0] = H * F - I * E + J * D;\n  out[1] = -(G * F) + I * C - J * B;\n  out[2] = G * E - H * C + J * A;\n  out[3] = -(G * D) + H * B - I * A;\n  return out;\n}\n;\n/**\r\n * Performs a linear interpolation between two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec4} out\r\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  var aw = a[3];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  out[3] = aw + t * (b[3] - aw);\n  return out;\n}\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec4} out\r\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\n  // http://projecteuclid.org/euclid.aoms/1177692644;\n\n  var v1, v2, v3, v4;\n  var s1, s2;\n\n  do {\n    v1 = glMatrix.RANDOM() * 2 - 1;\n    v2 = glMatrix.RANDOM() * 2 - 1;\n    s1 = v1 * v1 + v2 * v2;\n  } while (s1 >= 1);\n\n  do {\n    v3 = glMatrix.RANDOM() * 2 - 1;\n    v4 = glMatrix.RANDOM() * 2 - 1;\n    s2 = v3 * v3 + v4 * v4;\n  } while (s2 >= 1);\n\n  var d = Math.sqrt((1 - s1) / s2);\n  out[0] = scale * v1;\n  out[1] = scale * v2;\n  out[2] = scale * v3 * d;\n  out[3] = scale * v4 * d;\n  return out;\n}\n/**\r\n * Transforms the vec4 with a mat4.\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the vector to transform\r\n * @param {mat4} m matrix to transform with\r\n * @returns {vec4} out\r\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2],\n      w = a[3];\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n  return out;\n}\n/**\r\n * Transforms the vec4 with a quat\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the vector to transform\r\n * @param {quat} q quaternion to transform with\r\n * @returns {vec4} out\r\n */\n\nexport function transformQuat(out, a, q) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3]; // calculate quat * vec\n\n  var ix = qw * x + qy * z - qz * y;\n  var iy = qw * y + qz * x - qx * z;\n  var iz = qw * z + qx * y - qy * x;\n  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat\n\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n  out[3] = a[3];\n  return out;\n}\n/**\r\n * Set the components of a vec4 to zero\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @returns {vec4} out\r\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  out[3] = 0.0;\n  return out;\n}\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {vec4} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\n\nexport function str(a) {\n  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n}\n/**\r\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {vec4} a The first vector.\r\n * @param {vec4} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n}\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {vec4} a The first vector.\r\n * @param {vec4} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2],\n      a3 = a[3];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2],\n      b3 = b[3];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3));\n}\n/**\r\n * Alias for {@link vec4.subtract}\r\n * @function\r\n */\n\nexport var sub = subtract;\n/**\r\n * Alias for {@link vec4.multiply}\r\n * @function\r\n */\n\nexport var mul = multiply;\n/**\r\n * Alias for {@link vec4.divide}\r\n * @function\r\n */\n\nexport var div = divide;\n/**\r\n * Alias for {@link vec4.distance}\r\n * @function\r\n */\n\nexport var dist = distance;\n/**\r\n * Alias for {@link vec4.squaredDistance}\r\n * @function\r\n */\n\nexport var sqrDist = squaredDistance;\n/**\r\n * Alias for {@link vec4.length}\r\n * @function\r\n */\n\nexport var len = length;\n/**\r\n * Alias for {@link vec4.squaredLength}\r\n * @function\r\n */\n\nexport var sqrLen = squaredLength;\n/**\r\n * Perform some operation over an array of vec4s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 4;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      vec[3] = a[i + 3];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n      a[i + 3] = vec[3];\n    }\n\n    return a;\n  };\n}();","// This file is generated. Edit build/generate-style-code.js, then run `yarn run codegen`.\n// @flow\n/* eslint-disable */\n\nimport styleSpec from '../../style-spec/reference/latest';\n\nimport {\n    Properties,\n    DataConstantProperty,\n    DataDrivenProperty,\n    CrossFadedDataDrivenProperty,\n    CrossFadedProperty,\n    ColorRampProperty\n} from '../properties';\n\nimport type Color from '../../style-spec/util/color';\n\nimport type Formatted from '../../style-spec/expression/types/formatted';\n\nimport type ResolvedImage from '../../style-spec/expression/types/resolved_image';\n\nimport {\n    ColorType\n} from '../../style-spec/expression/types';\n\nexport type LayoutProps = {|\n    \"symbol-placement\": DataConstantProperty<\"point\" | \"line\" | \"line-center\">,\n    \"symbol-spacing\": DataConstantProperty<number>,\n    \"symbol-avoid-edges\": DataConstantProperty<boolean>,\n    \"symbol-sort-key\": DataDrivenProperty<number>,\n    \"symbol-z-order\": DataConstantProperty<\"auto\" | \"viewport-y\" | \"source\">,\n    \"icon-allow-overlap\": DataConstantProperty<boolean>,\n    \"icon-ignore-placement\": DataConstantProperty<boolean>,\n    \"icon-optional\": DataConstantProperty<boolean>,\n    \"icon-rotation-alignment\": DataConstantProperty<\"map\" | \"viewport\" | \"auto\">,\n    \"icon-size\": DataDrivenProperty<number>,\n    \"icon-text-fit\": DataConstantProperty<\"none\" | \"width\" | \"height\" | \"both\">,\n    \"icon-text-fit-padding\": DataConstantProperty<[number, number, number, number]>,\n    \"icon-image\": DataDrivenProperty<ResolvedImage>,\n    \"icon-rotate\": DataDrivenProperty<number>,\n    \"icon-padding\": DataConstantProperty<number>,\n    \"icon-keep-upright\": DataConstantProperty<boolean>,\n    \"icon-offset\": DataDrivenProperty<[number, number]>,\n    \"icon-anchor\": DataDrivenProperty<\"center\" | \"left\" | \"right\" | \"top\" | \"bottom\" | \"top-left\" | \"top-right\" | \"bottom-left\" | \"bottom-right\">,\n    \"icon-pitch-alignment\": DataConstantProperty<\"map\" | \"viewport\" | \"auto\">,\n    \"text-pitch-alignment\": DataConstantProperty<\"map\" | \"viewport\" | \"auto\">,\n    \"text-rotation-alignment\": DataConstantProperty<\"map\" | \"viewport\" | \"auto\">,\n    \"text-field\": DataDrivenProperty<Formatted>,\n    \"text-font\": DataDrivenProperty<Array<string>>,\n    \"text-size\": DataDrivenProperty<number>,\n    \"text-max-width\": DataDrivenProperty<number>,\n    \"text-line-height\": DataConstantProperty<number>,\n    \"text-letter-spacing\": DataDrivenProperty<number>,\n    \"text-justify\": DataDrivenProperty<\"auto\" | \"left\" | \"center\" | \"right\">,\n    \"text-radial-offset\": DataDrivenProperty<number>,\n    \"text-variable-anchor\": DataConstantProperty<Array<\"center\" | \"left\" | \"right\" | \"top\" | \"bottom\" | \"top-left\" | \"top-right\" | \"bottom-left\" | \"bottom-right\">>,\n    \"text-anchor\": DataDrivenProperty<\"center\" | \"left\" | \"right\" | \"top\" | \"bottom\" | \"top-left\" | \"top-right\" | \"bottom-left\" | \"bottom-right\">,\n    \"text-max-angle\": DataConstantProperty<number>,\n    \"text-writing-mode\": DataConstantProperty<Array<\"horizontal\" | \"vertical\">>,\n    \"text-rotate\": DataDrivenProperty<number>,\n    \"text-padding\": DataConstantProperty<number>,\n    \"text-keep-upright\": DataConstantProperty<boolean>,\n    \"text-transform\": DataDrivenProperty<\"none\" | \"uppercase\" | \"lowercase\">,\n    \"text-offset\": DataDrivenProperty<[number, number]>,\n    \"text-allow-overlap\": DataConstantProperty<boolean>,\n    \"text-ignore-placement\": DataConstantProperty<boolean>,\n    \"text-optional\": DataConstantProperty<boolean>,\n|};\n\nconst layout: Properties<LayoutProps> = new Properties({\n    \"symbol-placement\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"symbol-placement\"]),\n    \"symbol-spacing\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"symbol-spacing\"]),\n    \"symbol-avoid-edges\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"symbol-avoid-edges\"]),\n    \"symbol-sort-key\": new DataDrivenProperty(styleSpec[\"layout_symbol\"][\"symbol-sort-key\"]),\n    \"symbol-z-order\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"symbol-z-order\"]),\n    \"icon-allow-overlap\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"icon-allow-overlap\"]),\n    \"icon-ignore-placement\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"icon-ignore-placement\"]),\n    \"icon-optional\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"icon-optional\"]),\n    \"icon-rotation-alignment\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"icon-rotation-alignment\"]),\n    \"icon-size\": new DataDrivenProperty(styleSpec[\"layout_symbol\"][\"icon-size\"]),\n    \"icon-text-fit\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"icon-text-fit\"]),\n    \"icon-text-fit-padding\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"icon-text-fit-padding\"]),\n    \"icon-image\": new DataDrivenProperty(styleSpec[\"layout_symbol\"][\"icon-image\"]),\n    \"icon-rotate\": new DataDrivenProperty(styleSpec[\"layout_symbol\"][\"icon-rotate\"]),\n    \"icon-padding\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"icon-padding\"]),\n    \"icon-keep-upright\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"icon-keep-upright\"]),\n    \"icon-offset\": new DataDrivenProperty(styleSpec[\"layout_symbol\"][\"icon-offset\"]),\n    \"icon-anchor\": new DataDrivenProperty(styleSpec[\"layout_symbol\"][\"icon-anchor\"]),\n    \"icon-pitch-alignment\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"icon-pitch-alignment\"]),\n    \"text-pitch-alignment\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"text-pitch-alignment\"]),\n    \"text-rotation-alignment\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"text-rotation-alignment\"]),\n    \"text-field\": new DataDrivenProperty(styleSpec[\"layout_symbol\"][\"text-field\"]),\n    \"text-font\": new DataDrivenProperty(styleSpec[\"layout_symbol\"][\"text-font\"]),\n    \"text-size\": new DataDrivenProperty(styleSpec[\"layout_symbol\"][\"text-size\"]),\n    \"text-max-width\": new DataDrivenProperty(styleSpec[\"layout_symbol\"][\"text-max-width\"]),\n    \"text-line-height\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"text-line-height\"]),\n    \"text-letter-spacing\": new DataDrivenProperty(styleSpec[\"layout_symbol\"][\"text-letter-spacing\"]),\n    \"text-justify\": new DataDrivenProperty(styleSpec[\"layout_symbol\"][\"text-justify\"]),\n    \"text-radial-offset\": new DataDrivenProperty(styleSpec[\"layout_symbol\"][\"text-radial-offset\"]),\n    \"text-variable-anchor\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"text-variable-anchor\"]),\n    \"text-anchor\": new DataDrivenProperty(styleSpec[\"layout_symbol\"][\"text-anchor\"]),\n    \"text-max-angle\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"text-max-angle\"]),\n    \"text-writing-mode\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"text-writing-mode\"]),\n    \"text-rotate\": new DataDrivenProperty(styleSpec[\"layout_symbol\"][\"text-rotate\"]),\n    \"text-padding\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"text-padding\"]),\n    \"text-keep-upright\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"text-keep-upright\"]),\n    \"text-transform\": new DataDrivenProperty(styleSpec[\"layout_symbol\"][\"text-transform\"]),\n    \"text-offset\": new DataDrivenProperty(styleSpec[\"layout_symbol\"][\"text-offset\"]),\n    \"text-allow-overlap\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"text-allow-overlap\"]),\n    \"text-ignore-placement\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"text-ignore-placement\"]),\n    \"text-optional\": new DataConstantProperty(styleSpec[\"layout_symbol\"][\"text-optional\"]),\n});\n\nexport type PaintProps = {|\n    \"icon-opacity\": DataDrivenProperty<number>,\n    \"icon-color\": DataDrivenProperty<Color>,\n    \"icon-halo-color\": DataDrivenProperty<Color>,\n    \"icon-halo-width\": DataDrivenProperty<number>,\n    \"icon-halo-blur\": DataDrivenProperty<number>,\n    \"icon-translate\": DataConstantProperty<[number, number]>,\n    \"icon-translate-anchor\": DataConstantProperty<\"map\" | \"viewport\">,\n    \"text-opacity\": DataDrivenProperty<number>,\n    \"text-color\": DataDrivenProperty<Color>,\n    \"text-halo-color\": DataDrivenProperty<Color>,\n    \"text-halo-width\": DataDrivenProperty<number>,\n    \"text-halo-blur\": DataDrivenProperty<number>,\n    \"text-translate\": DataConstantProperty<[number, number]>,\n    \"text-translate-anchor\": DataConstantProperty<\"map\" | \"viewport\">,\n|};\n\nconst paint: Properties<PaintProps> = new Properties({\n    \"icon-opacity\": new DataDrivenProperty(styleSpec[\"paint_symbol\"][\"icon-opacity\"]),\n    \"icon-color\": new DataDrivenProperty(styleSpec[\"paint_symbol\"][\"icon-color\"]),\n    \"icon-halo-color\": new DataDrivenProperty(styleSpec[\"paint_symbol\"][\"icon-halo-color\"]),\n    \"icon-halo-width\": new DataDrivenProperty(styleSpec[\"paint_symbol\"][\"icon-halo-width\"]),\n    \"icon-halo-blur\": new DataDrivenProperty(styleSpec[\"paint_symbol\"][\"icon-halo-blur\"]),\n    \"icon-translate\": new DataConstantProperty(styleSpec[\"paint_symbol\"][\"icon-translate\"]),\n    \"icon-translate-anchor\": new DataConstantProperty(styleSpec[\"paint_symbol\"][\"icon-translate-anchor\"]),\n    \"text-opacity\": new DataDrivenProperty(styleSpec[\"paint_symbol\"][\"text-opacity\"]),\n    \"text-color\": new DataDrivenProperty(styleSpec[\"paint_symbol\"][\"text-color\"], { runtimeType: ColorType, getOverride: (o) => o.textColor, hasOverride: (o) => !!o.textColor }),\n    \"text-halo-color\": new DataDrivenProperty(styleSpec[\"paint_symbol\"][\"text-halo-color\"]),\n    \"text-halo-width\": new DataDrivenProperty(styleSpec[\"paint_symbol\"][\"text-halo-width\"]),\n    \"text-halo-blur\": new DataDrivenProperty(styleSpec[\"paint_symbol\"][\"text-halo-blur\"]),\n    \"text-translate\": new DataConstantProperty(styleSpec[\"paint_symbol\"][\"text-translate\"]),\n    \"text-translate-anchor\": new DataConstantProperty(styleSpec[\"paint_symbol\"][\"text-translate-anchor\"]),\n});\n\n// Note: without adding the explicit type annotation, Flow infers weaker types\n// for these objects from their use in the constructor to StyleLayer, as\n// {layout?: Properties<...>, paint: Properties<...>}\nexport default ({ paint, layout }: $Exact<{\n  paint: Properties<PaintProps>, layout: Properties<LayoutProps>\n}>);\n","// @flow\n\nimport assert from 'assert';\nimport type {Expression} from '../expression';\nimport type EvaluationContext from '../evaluation_context';\nimport type {Value} from '../values';\nimport type {Type} from '../types';\nimport type {ZoomConstantExpression} from '../../expression';\nimport {NullType} from '../types';\nimport {PossiblyEvaluatedPropertyValue} from '../../../style/properties';\nimport {register} from '../../../util/web_worker_transfer';\n\nexport default class FormatSectionOverride<T> implements Expression {\n    type: Type;\n    defaultValue: PossiblyEvaluatedPropertyValue<T>;\n\n    constructor(defaultValue: PossiblyEvaluatedPropertyValue<T>) {\n        assert(defaultValue.property.overrides !== undefined);\n        this.type = defaultValue.property.overrides ? defaultValue.property.overrides.runtimeType : NullType;\n        this.defaultValue = defaultValue;\n    }\n\n    evaluate(ctx: EvaluationContext) {\n        if (ctx.formattedSection) {\n            const overrides = this.defaultValue.property.overrides;\n            if (overrides && overrides.hasOverride(ctx.formattedSection)) {\n                return overrides.getOverride(ctx.formattedSection);\n            }\n        }\n\n        if (ctx.feature && ctx.featureState) {\n            return this.defaultValue.evaluate(ctx.feature, ctx.featureState);\n        }\n\n        return this.defaultValue.property.specification.default;\n    }\n\n    eachChild(fn: (Expression) => void) {\n        if (!this.defaultValue.isConstant()) {\n            const expr: ZoomConstantExpression<'source'> = ((this.defaultValue.value): any);\n            fn(expr._styleExpression.expression);\n        }\n    }\n\n    // Cannot be statically evaluated, as the output depends on the evaluation context.\n    possibleOutputs(): Array<Value | void> {\n        return [undefined];\n    }\n\n    serialize() {\n        return null;\n    }\n}\n\nregister('FormatSectionOverride', FormatSectionOverride, {omit: ['defaultValue']});\n","// @flow\n\nimport StyleLayer from '../style_layer';\n\nimport assert from 'assert';\nimport SymbolBucket from '../../data/bucket/symbol_bucket';\nimport resolveTokens from '../../util/resolve_tokens';\nimport properties from './symbol_style_layer_properties';\n\nimport {\n    Transitionable,\n    Transitioning,\n    Layout,\n    PossiblyEvaluated,\n    PossiblyEvaluatedPropertyValue,\n    PropertyValue\n} from '../properties';\n\nimport {\n    isExpression,\n    StyleExpression,\n    ZoomConstantExpression,\n    ZoomDependentExpression\n} from '../../style-spec/expression';\n\nimport type {BucketParameters} from '../../data/bucket';\nimport type {LayoutProps, PaintProps} from './symbol_style_layer_properties';\nimport type EvaluationParameters from '../evaluation_parameters';\nimport type {LayerSpecification} from '../../style-spec/types';\nimport type {Feature, SourceExpression, CompositeExpression} from '../../style-spec/expression';\nimport type {Expression} from '../../style-spec/expression/expression';\nimport {FormattedType} from '../../style-spec/expression/types';\nimport {typeOf} from '../../style-spec/expression/values';\nimport Formatted from '../../style-spec/expression/types/formatted';\nimport FormatSectionOverride from '../../style-spec/expression/definitions/format_section_override';\nimport FormatExpression from '../../style-spec/expression/definitions/format';\nimport Literal from '../../style-spec/expression/definitions/literal';\n\nclass SymbolStyleLayer extends StyleLayer {\n    _unevaluatedLayout: Layout<LayoutProps>;\n    layout: PossiblyEvaluated<LayoutProps>;\n\n    _transitionablePaint: Transitionable<PaintProps>;\n    _transitioningPaint: Transitioning<PaintProps>;\n    paint: PossiblyEvaluated<PaintProps>;\n\n    constructor(layer: LayerSpecification) {\n        super(layer, properties);\n    }\n\n    recalculate(parameters: EvaluationParameters, availableImages: Array<string>) {\n        super.recalculate(parameters, availableImages);\n\n        if (this.layout.get('icon-rotation-alignment') === 'auto') {\n            if (this.layout.get('symbol-placement') !== 'point') {\n                this.layout._values['icon-rotation-alignment'] = 'map';\n            } else {\n                this.layout._values['icon-rotation-alignment'] = 'viewport';\n            }\n        }\n\n        if (this.layout.get('text-rotation-alignment') === 'auto') {\n            if (this.layout.get('symbol-placement') !== 'point') {\n                this.layout._values['text-rotation-alignment'] = 'map';\n            } else {\n                this.layout._values['text-rotation-alignment'] = 'viewport';\n            }\n        }\n\n        // If unspecified, `*-pitch-alignment` inherits `*-rotation-alignment`\n        if (this.layout.get('text-pitch-alignment') === 'auto') {\n            this.layout._values['text-pitch-alignment'] = this.layout.get('text-rotation-alignment');\n        }\n        if (this.layout.get('icon-pitch-alignment') === 'auto') {\n            this.layout._values['icon-pitch-alignment'] = this.layout.get('icon-rotation-alignment');\n        }\n\n        if (this.layout.get('symbol-placement') === 'point') {\n            const writingModes = this.layout.get('text-writing-mode');\n            if (writingModes) {\n                // remove duplicates, preserving order\n                const deduped = [];\n                for (const m of writingModes) {\n                    if (deduped.indexOf(m) < 0) deduped.push(m);\n                }\n                this.layout._values['text-writing-mode'] = deduped;\n            } else {\n                this.layout._values['text-writing-mode'] = ['horizontal'];\n            }\n        }\n\n        this._setPaintOverrides();\n    }\n\n    getValueAndResolveTokens(name: *, feature: Feature, availableImages: Array<string>) {\n        const value = this.layout.get(name).evaluate(feature, {}, availableImages);\n        const unevaluated = this._unevaluatedLayout._values[name];\n        if (!unevaluated.isDataDriven() && !isExpression(unevaluated.value) && value) {\n            return resolveTokens(feature.properties, value);\n        }\n\n        return value;\n    }\n\n    createBucket(parameters: BucketParameters<*>) {\n        return new SymbolBucket(parameters);\n    }\n\n    queryRadius(): number {\n        return 0;\n    }\n\n    queryIntersectsFeature(): boolean {\n        assert(false); // Should take a different path in FeatureIndex\n        return false;\n    }\n\n    _setPaintOverrides() {\n        for (const overridable of properties.paint.overridableProperties) {\n            if (!SymbolStyleLayer.hasPaintOverride(this.layout, overridable)) {\n                continue;\n            }\n            const overriden = this.paint.get(overridable);\n            const override = new FormatSectionOverride(overriden);\n            const styleExpression = new StyleExpression(override, overriden.property.specification);\n            let expression = null;\n            if (overriden.value.kind === 'constant' || overriden.value.kind === 'source') {\n                expression = (new ZoomConstantExpression('source', styleExpression): SourceExpression);\n            } else {\n                expression = (new ZoomDependentExpression('composite',\n                                                          styleExpression,\n                                                          overriden.value.zoomStops,\n                                                          overriden.value._interpolationType): CompositeExpression);\n            }\n            this.paint._values[overridable] = new PossiblyEvaluatedPropertyValue(overriden.property,\n                                                                                 expression,\n                                                                                 overriden.parameters);\n        }\n    }\n\n    _handleOverridablePaintPropertyUpdate<T, R>(name: string, oldValue: PropertyValue<T, R>, newValue: PropertyValue<T, R>): boolean {\n        if (!this.layout || oldValue.isDataDriven() || newValue.isDataDriven()) {\n            return false;\n        }\n        return SymbolStyleLayer.hasPaintOverride(this.layout, name);\n    }\n\n    static hasPaintOverride(layout: PossiblyEvaluated<LayoutProps>, propertyName: string): boolean {\n        const textField = layout.get('text-field');\n        const property = properties.paint.properties[propertyName];\n        let hasOverrides = false;\n\n        const checkSections = (sections) => {\n            for (const section of sections) {\n                if (property.overrides && property.overrides.hasOverride(section)) {\n                    hasOverrides = true;\n                    return;\n                }\n            }\n        };\n\n        if (textField.value.kind === 'constant' && textField.value.value instanceof Formatted) {\n            checkSections(textField.value.value.sections);\n        } else if (textField.value.kind === 'source') {\n\n            const checkExpression = (expression: Expression) => {\n                if (hasOverrides) return;\n\n                if (expression instanceof Literal && typeOf(expression.value) === FormattedType) {\n                    const formatted: Formatted = ((expression.value): any);\n                    checkSections(formatted.sections);\n                } else if (expression instanceof FormatExpression) {\n                    checkSections(expression.sections);\n                } else {\n                    expression.eachChild(checkExpression);\n                }\n            };\n\n            const expr: ZoomConstantExpression<'source'> = ((textField.value): any);\n            if (expr._styleExpression) {\n                checkExpression(expr._styleExpression.expression);\n            }\n        }\n\n        return hasOverrides;\n    }\n\n    static hasPaintOverrides(layout: PossiblyEvaluated<LayoutProps>): boolean {\n        for (const overridable of properties.paint.overridableProperties) {\n            if (SymbolStyleLayer.hasPaintOverride(layout, overridable)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\nexport default SymbolStyleLayer;\n","// @flow\nexport default resolveTokens;\n\n/**\n * Replace tokens in a string template with values in an object\n *\n * @param properties a key/value relationship between tokens and replacements\n * @param text the template string\n * @returns the template with tokens replaced\n * @private\n */\nfunction resolveTokens(properties: {+[string]: mixed}, text: string): string {\n    return text.replace(/{([^{}]+)}/g, (match, key: string) => {\n        return key in properties ? String(properties[key]) : '';\n    });\n}\n","// This file is generated. Edit build/generate-style-code.js, then run `yarn run codegen`.\n// @flow\n/* eslint-disable */\n\nimport styleSpec from '../../style-spec/reference/latest';\n\nimport {\n    Properties,\n    DataConstantProperty,\n    DataDrivenProperty,\n    CrossFadedDataDrivenProperty,\n    CrossFadedProperty,\n    ColorRampProperty\n} from '../properties';\n\nimport type Color from '../../style-spec/util/color';\n\nimport type Formatted from '../../style-spec/expression/types/formatted';\n\nimport type ResolvedImage from '../../style-spec/expression/types/resolved_image';\n\n\nexport type PaintProps = {|\n    \"background-color\": DataConstantProperty<Color>,\n    \"background-pattern\": CrossFadedProperty<ResolvedImage>,\n    \"background-opacity\": DataConstantProperty<number>,\n|};\n\nconst paint: Properties<PaintProps> = new Properties({\n    \"background-color\": new DataConstantProperty(styleSpec[\"paint_background\"][\"background-color\"]),\n    \"background-pattern\": new CrossFadedProperty(styleSpec[\"paint_background\"][\"background-pattern\"]),\n    \"background-opacity\": new DataConstantProperty(styleSpec[\"paint_background\"][\"background-opacity\"]),\n});\n\n// Note: without adding the explicit type annotation, Flow infers weaker types\n// for these objects from their use in the constructor to StyleLayer, as\n// {layout?: Properties<...>, paint: Properties<...>}\nexport default ({ paint }: $Exact<{\n  paint: Properties<PaintProps>\n}>);\n","// @flow\n\nimport StyleLayer from '../style_layer';\n\nimport properties from './background_style_layer_properties';\nimport {Transitionable, Transitioning, PossiblyEvaluated} from '../properties';\n\nimport type {PaintProps} from './background_style_layer_properties';\nimport type {LayerSpecification} from '../../style-spec/types';\n\nclass BackgroundStyleLayer extends StyleLayer {\n    _transitionablePaint: Transitionable<PaintProps>;\n    _transitioningPaint: Transitioning<PaintProps>;\n    paint: PossiblyEvaluated<PaintProps>;\n\n    constructor(layer: LayerSpecification) {\n        super(layer, properties);\n    }\n}\n\nexport default BackgroundStyleLayer;\n","// This file is generated. Edit build/generate-style-code.js, then run `yarn run codegen`.\n// @flow\n/* eslint-disable */\n\nimport styleSpec from '../../style-spec/reference/latest';\n\nimport {\n    Properties,\n    DataConstantProperty,\n    DataDrivenProperty,\n    CrossFadedDataDrivenProperty,\n    CrossFadedProperty,\n    ColorRampProperty\n} from '../properties';\n\nimport type Color from '../../style-spec/util/color';\n\nimport type Formatted from '../../style-spec/expression/types/formatted';\n\nimport type ResolvedImage from '../../style-spec/expression/types/resolved_image';\n\n\nexport type PaintProps = {|\n    \"raster-opacity\": DataConstantProperty<number>,\n    \"raster-hue-rotate\": DataConstantProperty<number>,\n    \"raster-brightness-min\": DataConstantProperty<number>,\n    \"raster-brightness-max\": DataConstantProperty<number>,\n    \"raster-saturation\": DataConstantProperty<number>,\n    \"raster-contrast\": DataConstantProperty<number>,\n    \"raster-resampling\": DataConstantProperty<\"linear\" | \"nearest\">,\n    \"raster-fade-duration\": DataConstantProperty<number>,\n|};\n\nconst paint: Properties<PaintProps> = new Properties({\n    \"raster-opacity\": new DataConstantProperty(styleSpec[\"paint_raster\"][\"raster-opacity\"]),\n    \"raster-hue-rotate\": new DataConstantProperty(styleSpec[\"paint_raster\"][\"raster-hue-rotate\"]),\n    \"raster-brightness-min\": new DataConstantProperty(styleSpec[\"paint_raster\"][\"raster-brightness-min\"]),\n    \"raster-brightness-max\": new DataConstantProperty(styleSpec[\"paint_raster\"][\"raster-brightness-max\"]),\n    \"raster-saturation\": new DataConstantProperty(styleSpec[\"paint_raster\"][\"raster-saturation\"]),\n    \"raster-contrast\": new DataConstantProperty(styleSpec[\"paint_raster\"][\"raster-contrast\"]),\n    \"raster-resampling\": new DataConstantProperty(styleSpec[\"paint_raster\"][\"raster-resampling\"]),\n    \"raster-fade-duration\": new DataConstantProperty(styleSpec[\"paint_raster\"][\"raster-fade-duration\"]),\n});\n\n// Note: without adding the explicit type annotation, Flow infers weaker types\n// for these objects from their use in the constructor to StyleLayer, as\n// {layout?: Properties<...>, paint: Properties<...>}\nexport default ({ paint }: $Exact<{\n  paint: Properties<PaintProps>\n}>);\n","// @flow\n\nimport StyleLayer from '../style_layer';\n\nimport properties from './raster_style_layer_properties';\nimport {Transitionable, Transitioning, PossiblyEvaluated} from '../properties';\n\nimport type {PaintProps} from './raster_style_layer_properties';\nimport type {LayerSpecification} from '../../style-spec/types';\n\nclass RasterStyleLayer extends StyleLayer {\n    _transitionablePaint: Transitionable<PaintProps>;\n    _transitioningPaint: Transitioning<PaintProps>;\n    paint: PossiblyEvaluated<PaintProps>;\n\n    constructor(layer: LayerSpecification) {\n        super(layer, properties);\n    }\n}\n\nexport default RasterStyleLayer;\n","// @flow\n\nimport StyleLayer from '../style_layer';\nimport type Map from '../../ui/map';\nimport assert from 'assert';\n\ntype CustomRenderMethod = (gl: WebGLRenderingContext, matrix: Array<number>) => void;\n\n/**\n * Interface for custom style layers. This is a specification for\n * implementers to model: it is not an exported method or class.\n *\n * Custom layers allow a user to render directly into the map's GL context using the map's camera.\n * These layers can be added between any regular layers using {@link Map#addLayer}.\n *\n * Custom layers must have a unique `id` and must have the `type` of `\"custom\"`.\n * They must implement `render` and may implement `prerender`, `onAdd` and `onRemove`.\n * They can trigger rendering using {@link Map#triggerRepaint}\n * and they should appropriately handle {@link Map.event:webglcontextlost} and\n * {@link Map.event:webglcontextrestored}.\n *\n * The `renderingMode` property controls whether the layer is treated as a `\"2d\"` or `\"3d\"` map layer. Use:\n * - `\"renderingMode\": \"3d\"` to use the depth buffer and share it with other layers\n * - `\"renderingMode\": \"2d\"` to add a layer with no depth. If you need to use the depth buffer for a `\"2d\"` layer you must use an offscreen\n *   framebuffer and {@link CustomLayerInterface#prerender}\n *\n * @interface CustomLayerInterface\n * @property {string} id A unique layer id.\n * @property {string} type The layer's type. Must be `\"custom\"`.\n * @property {string} renderingMode Either `\"2d\"` or `\"3d\"`. Defaults to `\"2d\"`.\n * @example\n * // Custom layer implemented as ES6 class\n * class NullIslandLayer {\n *     constructor() {\n *         this.id = 'null-island';\n *         this.type = 'custom';\n *         this.renderingMode = '2d';\n *     }\n *\n *     onAdd(map, gl) {\n *         const vertexSource = `\n *         uniform mat4 u_matrix;\n *         void main() {\n *             gl_Position = u_matrix * vec4(0.5, 0.5, 0.0, 1.0);\n *             gl_PointSize = 20.0;\n *         }`;\n *\n *         const fragmentSource = `\n *         void main() {\n *             gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n *         }`;\n *\n *         const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n *         gl.shaderSource(vertexShader, vertexSource);\n *         gl.compileShader(vertexShader);\n *         const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n *         gl.shaderSource(fragmentShader, fragmentSource);\n *         gl.compileShader(fragmentShader);\n *\n *         this.program = gl.createProgram();\n *         gl.attachShader(this.program, vertexShader);\n *         gl.attachShader(this.program, fragmentShader);\n *         gl.linkProgram(this.program);\n *     }\n *\n *     render(gl, matrix) {\n *         gl.useProgram(this.program);\n *         gl.uniformMatrix4fv(gl.getUniformLocation(this.program, \"u_matrix\"), false, matrix);\n *         gl.drawArrays(gl.POINTS, 0, 1);\n *     }\n * }\n *\n * map.on('load', function() {\n *     map.addLayer(new NullIslandLayer());\n * });\n */\n\n/**\n * Optional method called when the layer has been added to the Map with {@link Map#addLayer}. This\n * gives the layer a chance to initialize gl resources and register event listeners.\n *\n * @function\n * @memberof CustomLayerInterface\n * @instance\n * @name onAdd\n * @param {Map} map The Map this custom layer was just added to.\n * @param {WebGLRenderingContext} gl The gl context for the map.\n */\n\n/**\n * Optional method called when the layer has been removed from the Map with {@link Map#removeLayer}. This\n * gives the layer a chance to clean up gl resources and event listeners.\n *\n * @function\n * @memberof CustomLayerInterface\n * @instance\n * @name onRemove\n * @param {Map} map The Map this custom layer was just added to.\n * @param {WebGLRenderingContext} gl The gl context for the map.\n */\n\n/**\n * Optional method called during a render frame to allow a layer to prepare resources or render into a texture.\n *\n * The layer cannot make any assumptions about the current GL state and must bind a framebuffer before rendering.\n *\n * @function\n * @memberof CustomLayerInterface\n * @instance\n * @name prerender\n * @param {WebGLRenderingContext} gl The map's gl context.\n * @param {Array<number>} matrix The map's camera matrix. It projects spherical mercator\n * coordinates to gl coordinates. The mercator coordinate `[0, 0]` represents the\n * top left corner of the mercator world and `[1, 1]` represents the bottom right corner. When\n * the `renderingMode` is `\"3d\"`, the z coordinate is conformal. A box with identical x, y, and z\n * lengths in mercator units would be rendered as a cube. {@link MercatorCoordinate}.fromLatLng\n * can be used to project a `LngLat` to a mercator coordinate.\n */\n\n/**\n * Called during a render frame allowing the layer to draw into the GL context.\n *\n * The layer can assume blending and depth state is set to allow the layer to properly\n * blend and clip other layers. The layer cannot make any other assumptions about the\n * current GL state.\n *\n * If the layer needs to render to a texture, it should implement the `prerender` method\n * to do this and only use the `render` method for drawing directly into the main framebuffer.\n *\n * The blend function is set to `gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)`. This expects\n * colors to be provided in premultiplied alpha form where the `r`, `g` and `b` values are already\n * multiplied by the `a` value. If you are unable to provide colors in premultiplied form you\n * may want to change the blend function to\n * `gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA)`.\n *\n * @function\n * @memberof CustomLayerInterface\n * @instance\n * @name render\n * @param {WebGLRenderingContext} gl The map's gl context.\n * @param {Array<number>} matrix The map's camera matrix. It projects spherical mercator\n * coordinates to gl coordinates. The spherical mercator coordinate `[0, 0]` represents the\n * top left corner of the mercator world and `[1, 1]` represents the bottom right corner. When\n * the `renderingMode` is `\"3d\"`, the z coordinate is conformal. A box with identical x, y, and z\n * lengths in mercator units would be rendered as a cube. {@link MercatorCoordinate}.fromLatLng\n * can be used to project a `LngLat` to a mercator coordinate.\n */\nexport type CustomLayerInterface = {\n    id: string,\n    type: \"custom\",\n    renderingMode: \"2d\" | \"3d\",\n    render: CustomRenderMethod,\n    prerender: ?CustomRenderMethod,\n    onAdd: ?(map: Map, gl: WebGLRenderingContext) => void,\n    onRemove: ?(map: Map, gl: WebGLRenderingContext) => void\n}\n\nexport function validateCustomStyleLayer(layerObject: CustomLayerInterface) {\n    const errors = [];\n    const id = layerObject.id;\n\n    if (id === undefined) {\n        errors.push({\n            message: `layers.${id}: missing required property \"id\"`\n        });\n    }\n\n    if (layerObject.render === undefined) {\n        errors.push({\n            message: `layers.${id}: missing required method \"render\"`\n        });\n    }\n\n    if (layerObject.renderingMode &&\n        layerObject.renderingMode !== '2d' &&\n        layerObject.renderingMode !== '3d') {\n        errors.push({\n            message: `layers.${id}: property \"renderingMode\" must be either \"2d\" or \"3d\"`\n        });\n    }\n\n    return errors;\n}\n\nclass CustomStyleLayer extends StyleLayer {\n\n    implementation: CustomLayerInterface;\n\n    constructor(implementation: CustomLayerInterface) {\n        super(implementation, {});\n        this.implementation = implementation;\n    }\n\n    is3D() {\n        return this.implementation.renderingMode === '3d';\n    }\n\n    hasOffscreenPass() {\n        return this.implementation.prerender !== undefined;\n    }\n\n    recalculate() {}\n    updateTransitions() {}\n    hasTransition() {}\n\n    serialize() {\n        assert(false, \"Custom layers cannot be serialized\");\n    }\n\n    onAdd(map: Map) {\n        if (this.implementation.onAdd) {\n            this.implementation.onAdd(map, map.painter.context.gl);\n        }\n    }\n\n    onRemove(map: Map) {\n        if (this.implementation.onRemove) {\n            this.implementation.onRemove(map, map.painter.context.gl);\n        }\n    }\n}\n\nexport default CustomStyleLayer;\n","// @flow\n\nimport circle from './style_layer/circle_style_layer';\nimport heatmap from './style_layer/heatmap_style_layer';\nimport hillshade from './style_layer/hillshade_style_layer';\nimport fill from './style_layer/fill_style_layer';\nimport fillExtrusion from './style_layer/fill_extrusion_style_layer';\nimport customWebgl from './style_layer/custom_webgl_layer';\nimport line from './style_layer/line_style_layer';\nimport symbol from './style_layer/symbol_style_layer';\nimport background from './style_layer/background_style_layer';\nimport raster from './style_layer/raster_style_layer';\nimport CustomStyleLayer from './style_layer/custom_style_layer';\nimport type {CustomLayerInterface} from './style_layer/custom_style_layer';\n\nimport type {LayerSpecification} from '../style-spec/types';\n\nconst subclasses = {\n    circle,\n    heatmap,\n    hillshade,\n    fill,\n    'fill-extrusion': fillExtrusion,\n    'custom-webgl': customWebgl,\n    line,\n    symbol,\n    background,\n    raster\n};\n\nexport default function createStyleLayer(layer: LayerSpecification | CustomLayerInterface) {\n    if (layer.type === 'custom') {\n        return new CustomStyleLayer(layer);\n    } else {\n        return new subclasses[layer.type](layer);\n    }\n}\n\n","\nexport default function potpack(boxes) {\n\n    // calculate total box area and maximum box width\n    let area = 0;\n    let maxWidth = 0;\n\n    for (const box of boxes) {\n        area += box.w * box.h;\n        maxWidth = Math.max(maxWidth, box.w);\n    }\n\n    // sort the boxes for insertion by height, descending\n    boxes.sort((a, b) => b.h - a.h);\n\n    // aim for a squarish resulting container,\n    // slightly adjusted for sub-100% space utilization\n    const startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth);\n\n    // start with a single empty space, unbounded at the bottom\n    const spaces = [{x: 0, y: 0, w: startWidth, h: Infinity}];\n\n    let width = 0;\n    let height = 0;\n\n    for (const box of boxes) {\n        // look through spaces backwards so that we check smaller spaces first\n        for (let i = spaces.length - 1; i >= 0; i--) {\n            const space = spaces[i];\n\n            // look for empty spaces that can accommodate the current box\n            if (box.w > space.w || box.h > space.h) continue;\n\n            // found the space; add the box to its top-left corner\n            // |-------|-------|\n            // |  box  |       |\n            // |_______|       |\n            // |         space |\n            // |_______________|\n            box.x = space.x;\n            box.y = space.y;\n\n            height = Math.max(height, box.y + box.h);\n            width = Math.max(width, box.x + box.w);\n\n            if (box.w === space.w && box.h === space.h) {\n                // space matches the box exactly; remove it\n                const last = spaces.pop();\n                if (i < spaces.length) spaces[i] = last;\n\n            } else if (box.h === space.h) {\n                // space matches the box height; update it accordingly\n                // |-------|---------------|\n                // |  box  | updated space |\n                // |_______|_______________|\n                space.x += box.w;\n                space.w -= box.w;\n\n            } else if (box.w === space.w) {\n                // space matches the box width; update it accordingly\n                // |---------------|\n                // |      box      |\n                // |_______________|\n                // | updated space |\n                // |_______________|\n                space.y += box.h;\n                space.h -= box.h;\n\n            } else {\n                // otherwise the box splits the space into two spaces\n                // |-------|-----------|\n                // |  box  | new space |\n                // |_______|___________|\n                // | updated space     |\n                // |___________________|\n                spaces.push({\n                    x: space.x + box.w,\n                    y: space.y,\n                    w: space.w - box.w,\n                    h: box.h\n                });\n                space.y += box.h;\n                space.h -= box.h;\n            }\n            break;\n        }\n    }\n\n    return {\n        w: width, // container width\n        h: height, // container height\n        fill: (area / (width * height)) || 0 // space utilization\n    };\n}\n","// @flow\n\nimport {RGBAImage} from '../util/image';\nimport {register} from '../util/web_worker_transfer';\nimport potpack from 'potpack';\n\nimport type {StyleImage} from '../style/style_image';\nimport type ImageManager from './image_manager';\nimport type Texture from './texture';\n\nconst padding = 1;\n\ntype Rect = {\n    x: number,\n    y: number,\n    w: number,\n    h: number\n};\n\nexport class ImagePosition {\n    paddedRect: Rect;\n    pixelRatio: number;\n    version: number;\n\n    constructor(paddedRect: Rect, {pixelRatio, version}: StyleImage) {\n        this.paddedRect = paddedRect;\n        this.pixelRatio = pixelRatio;\n        this.version = version;\n    }\n\n    get tl(): [number, number] {\n        return [\n            this.paddedRect.x + padding,\n            this.paddedRect.y + padding\n        ];\n    }\n\n    get br(): [number, number] {\n        return [\n            this.paddedRect.x + this.paddedRect.w - padding,\n            this.paddedRect.y + this.paddedRect.h - padding\n        ];\n    }\n\n    get tlbr(): Array<number> {\n        return this.tl.concat(this.br);\n    }\n\n    get displaySize(): [number, number] {\n        return [\n            (this.paddedRect.w - padding * 2) / this.pixelRatio,\n            (this.paddedRect.h - padding * 2) / this.pixelRatio\n        ];\n    }\n}\n\nexport default class ImageAtlas {\n    image: RGBAImage;\n    iconPositions: {[string]: ImagePosition};\n    patternPositions: {[string]: ImagePosition};\n    haveRenderCallbacks: Array<string>;\n    uploaded: ?boolean;\n\n    constructor(icons: {[string]: StyleImage}, patterns: {[string]: StyleImage}) {\n        const iconPositions = {}, patternPositions = {};\n        this.haveRenderCallbacks = [];\n\n        const bins = [];\n\n        this.addImages(icons, iconPositions, bins);\n        this.addImages(patterns, patternPositions, bins);\n\n        const {w, h} = potpack(bins);\n        const image = new RGBAImage({width: w || 1, height: h || 1});\n\n        for (const id in icons) {\n            const src = icons[id];\n            const bin = iconPositions[id].paddedRect;\n            RGBAImage.copy(src.data, image, {x: 0, y: 0}, {x: bin.x + padding, y: bin.y + padding}, src.data);\n        }\n\n        for (const id in patterns) {\n            const src = patterns[id];\n            const bin = patternPositions[id].paddedRect;\n            const x = bin.x + padding,\n                y = bin.y + padding,\n                w = src.data.width,\n                h = src.data.height;\n\n            RGBAImage.copy(src.data, image, {x: 0, y: 0}, {x, y}, src.data);\n            // Add 1 pixel wrapped padding on each side of the image.\n            RGBAImage.copy(src.data, image, {x: 0, y: h - 1}, {x, y: y - 1}, {width: w, height: 1}); // T\n            RGBAImage.copy(src.data, image, {x: 0, y:     0}, {x, y: y + h}, {width: w, height: 1}); // B\n            RGBAImage.copy(src.data, image, {x: w - 1, y: 0}, {x: x - 1, y}, {width: 1, height: h}); // L\n            RGBAImage.copy(src.data, image, {x: 0,     y: 0}, {x: x + w, y}, {width: 1, height: h}); // R\n        }\n\n        this.image = image;\n        this.iconPositions = iconPositions;\n        this.patternPositions = patternPositions;\n    }\n\n    addImages(images: {[string]: StyleImage}, positions: {[string]: ImagePosition}, bins: Array<Rect>) {\n        for (const id in images) {\n            const src = images[id];\n            const bin = {\n                x: 0,\n                y: 0,\n                w: src.data.width + 2 * padding,\n                h: src.data.height + 2 * padding,\n            };\n            bins.push(bin);\n            positions[id] = new ImagePosition(bin, src);\n\n            if (src.hasRenderCallback) {\n                this.haveRenderCallbacks.push(id);\n            }\n        }\n    }\n\n    patchUpdatedImages(imageManager: ImageManager, texture: Texture) {\n        imageManager.dispatchRenderCallbacks(this.haveRenderCallbacks);\n        for (const name in imageManager.updatedImages) {\n            this.patchUpdatedImage(this.iconPositions[name], imageManager.getImage(name), texture);\n            this.patchUpdatedImage(this.patternPositions[name], imageManager.getImage(name), texture);\n        }\n    }\n\n    patchUpdatedImage(position: ?ImagePosition, image: ?StyleImage, texture: Texture) {\n        if (!position || !image) return;\n\n        if (position.version === image.version) return;\n\n        position.version = image.version;\n        const [x, y] = position.tl;\n        texture.update(image.data, undefined, {x, y});\n    }\n\n}\n\nregister('ImagePosition', ImagePosition);\nregister('ImageAtlas', ImageAtlas);\n","// @flow\n\nimport window from '../util/window';\nconst {HTMLImageElement, HTMLCanvasElement, HTMLVideoElement, ImageData} = window;\n\nimport type Context from '../gl/context';\nimport type {RGBAImage, AlphaImage} from '../util/image';\n\nexport type TextureFormat =\n    | $PropertyType<WebGLRenderingContext, 'RGBA'>\n    | $PropertyType<WebGLRenderingContext, 'ALPHA'>;\nexport type TextureFilter =\n    | $PropertyType<WebGLRenderingContext, 'LINEAR'>\n    | $PropertyType<WebGLRenderingContext, 'LINEAR_MIPMAP_NEAREST'>\n    | $PropertyType<WebGLRenderingContext, 'NEAREST'>;\nexport type TextureWrap =\n    | $PropertyType<WebGLRenderingContext, 'REPEAT'>\n    | $PropertyType<WebGLRenderingContext, 'CLAMP_TO_EDGE'>\n    | $PropertyType<WebGLRenderingContext, 'MIRRORED_REPEAT'>;\n\ntype EmptyImage = {\n    width: number,\n    height: number,\n    data: null\n}\n\nexport type TextureImage =\n    | RGBAImage\n    | AlphaImage\n    | HTMLImageElement\n    | HTMLCanvasElement\n    | HTMLVideoElement\n    | ImageData\n    | EmptyImage;\n\nclass Texture {\n    context: Context;\n    size: [number, number];\n    texture: WebGLTexture;\n    format: TextureFormat;\n    filter: ?TextureFilter;\n    wrap: ?TextureWrap;\n    useMipmap: boolean;\n\n    constructor(context: Context, image: TextureImage, format: TextureFormat, options: ?{ premultiply?: boolean, useMipmap?: boolean }) {\n        this.context = context;\n        this.format = format;\n        this.texture = context.gl.createTexture();\n        this.update(image, options);\n    }\n\n    update(image: TextureImage, options: ?{premultiply?: boolean, useMipmap?: boolean}, position?: { x: number, y: number }) {\n        const {width, height} = image;\n        const resize = (!this.size || this.size[0] !== width || this.size[1] !== height) && !position;\n        const {context} = this;\n        const {gl} = context;\n\n        this.useMipmap = Boolean(options && options.useMipmap);\n        gl.bindTexture(gl.TEXTURE_2D, this.texture);\n\n        context.pixelStoreUnpackFlipY.set(false);\n        context.pixelStoreUnpack.set(1);\n        context.pixelStoreUnpackPremultiplyAlpha.set(this.format === gl.RGBA && (!options || options.premultiply !== false));\n\n        if (resize) {\n            this.size = [width, height];\n\n            if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement || image instanceof ImageData) {\n                gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, gl.UNSIGNED_BYTE, image);\n            } else {\n                gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, gl.UNSIGNED_BYTE, image.data);\n            }\n\n        } else {\n            const {x, y} = position || {x: 0, y: 0};\n            if (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement || image instanceof ImageData) {\n                gl.texSubImage2D(gl.TEXTURE_2D, 0, x, y, gl.RGBA, gl.UNSIGNED_BYTE, image);\n            } else {\n                gl.texSubImage2D(gl.TEXTURE_2D, 0, x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, image.data);\n            }\n        }\n\n        if (this.useMipmap && this.isSizePowerOfTwo()) {\n            gl.generateMipmap(gl.TEXTURE_2D);\n        }\n    }\n\n    bind(filter: TextureFilter, wrap: TextureWrap, minFilter: ?TextureFilter) {\n        const {context} = this;\n        const {gl} = context;\n        gl.bindTexture(gl.TEXTURE_2D, this.texture);\n\n        if (minFilter === gl.LINEAR_MIPMAP_NEAREST && !this.isSizePowerOfTwo()) {\n            minFilter = gl.LINEAR;\n        }\n\n        if (filter !== this.filter) {\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter || filter);\n            this.filter = filter;\n        }\n\n        if (wrap !== this.wrap) {\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap);\n            this.wrap = wrap;\n        }\n    }\n\n    isSizePowerOfTwo() {\n        return this.size[0] === this.size[1] && (Math.log(this.size[0]) / Math.LN2) % 1 === 0;\n    }\n\n    destroy() {\n        const {gl} = this.context;\n        gl.deleteTexture(this.texture);\n        this.texture = (null: any);\n    }\n}\n\nexport default Texture;\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","// @flow\n\nimport Anchor from './anchor';\n\nimport {getAnchors, getCenterAnchor} from './get_anchors';\nimport clipLine from './clip_line';\nimport {shapeText, shapeIcon, WritingMode, fitIconToText} from './shaping';\nimport {getGlyphQuads, getIconQuads} from './quads';\nimport CollisionFeature from './collision_feature';\nimport {warnOnce} from '../util/util';\nimport {\n    allowsVerticalWritingMode,\n    allowsLetterSpacing\n} from '../util/script_detection';\nimport findPoleOfInaccessibility from '../util/find_pole_of_inaccessibility';\nimport classifyRings from '../util/classify_rings';\nimport EXTENT from '../data/extent';\nimport SymbolBucket from '../data/bucket/symbol_bucket';\nimport EvaluationParameters from '../style/evaluation_parameters';\nimport {SIZE_PACK_FACTOR} from './symbol_size';\nimport ONE_EM from './one_em';\n\nimport type {Shaping, PositionedIcon, TextJustify} from './shaping';\nimport type {CollisionBoxArray} from '../data/array_types';\nimport type {SymbolFeature} from '../data/bucket/symbol_bucket';\nimport type {StyleImage} from '../style/style_image';\nimport type {StyleGlyph} from '../style/style_glyph';\nimport type SymbolStyleLayer from '../style/style_layer/symbol_style_layer';\nimport type {ImagePosition} from '../render/image_atlas';\nimport type {GlyphPosition} from '../render/glyph_atlas';\nimport type {PossiblyEvaluatedPropertyValue} from '../style/properties';\n\nimport Point from '@mapbox/point-geometry';\nimport murmur3 from 'murmurhash-js';\n\n// The symbol layout process needs `text-size` evaluated at up to five different zoom levels, and\n// `icon-size` at up to three:\n//\n//   1. `text-size` at the zoom level of the bucket. Used to calculate a per-feature size for source `text-size`\n//       expressions, and to calculate the box dimensions for icon-text-fit.\n//   2. `icon-size` at the zoom level of the bucket. Used to calculate a per-feature size for source `icon-size`\n//       expressions.\n//   3. `text-size` and `icon-size` at the zoom level of the bucket, plus one. Used to calculate collision boxes.\n//   4. `text-size` at zoom level 18. Used for something line-symbol-placement-related.\n//   5.  For composite `*-size` expressions: two zoom levels of curve stops that \"cover\" the zoom level of the\n//       bucket. These go into a vertex buffer and are used by the shader to interpolate the size at render time.\n//\n// (1) and (2) are stored in `bucket.layers[0].layout`. The remainder are below.\n//\ntype Sizes = {\n    layoutTextSize: PossiblyEvaluatedPropertyValue<number>, // (3)\n    layoutIconSize: PossiblyEvaluatedPropertyValue<number>, // (3)\n    textMaxSize: PossiblyEvaluatedPropertyValue<number>,    // (4)\n    compositeTextSizes: [PossiblyEvaluatedPropertyValue<number>, PossiblyEvaluatedPropertyValue<number>], // (5)\n    compositeIconSizes: [PossiblyEvaluatedPropertyValue<number>, PossiblyEvaluatedPropertyValue<number>], // (5)\n};\n\nexport type TextAnchor = 'center' | 'left' | 'right' | 'top' | 'bottom' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\n\n// The radial offset is to the edge of the text box\n// In the horizontal direction, the edge of the text box is where glyphs start\n// But in the vertical direction, the glyphs appear to \"start\" at the baseline\n// We don't actually load baseline data, but we assume an offset of ONE_EM - 17\n// (see \"yOffset\" in shaping.js)\nconst baselineOffset = 7;\nconst INVALID_TEXT_OFFSET = Number.POSITIVE_INFINITY;\n\nexport function evaluateVariableOffset(anchor: TextAnchor, offset: [number, number]) {\n\n    function fromRadialOffset(anchor: TextAnchor, radialOffset: number) {\n        let x = 0, y = 0;\n        if (radialOffset < 0) radialOffset = 0; // Ignore negative offset.\n        // solve for r where r^2 + r^2 = radialOffset^2\n        const hypotenuse = radialOffset / Math.sqrt(2);\n        switch (anchor) {\n        case 'top-right':\n        case 'top-left':\n            y = hypotenuse - baselineOffset;\n            break;\n        case 'bottom-right':\n        case 'bottom-left':\n            y = -hypotenuse + baselineOffset;\n            break;\n        case 'bottom':\n            y = -radialOffset + baselineOffset;\n            break;\n        case 'top':\n            y = radialOffset - baselineOffset;\n            break;\n        }\n\n        switch (anchor) {\n        case 'top-right':\n        case 'bottom-right':\n            x = -hypotenuse;\n            break;\n        case 'top-left':\n        case 'bottom-left':\n            x = hypotenuse;\n            break;\n        case 'left':\n            x = radialOffset;\n            break;\n        case 'right':\n            x = -radialOffset;\n            break;\n        }\n\n        return [x, y];\n    }\n\n    function fromTextOffset(anchor: TextAnchor, offsetX: number, offsetY: number) {\n        let x = 0, y = 0;\n        // Use absolute offset values.\n        offsetX = Math.abs(offsetX);\n        offsetY = Math.abs(offsetY);\n\n        switch (anchor) {\n        case 'top-right':\n        case 'top-left':\n        case 'top':\n            y = offsetY - baselineOffset;\n            break;\n        case 'bottom-right':\n        case 'bottom-left':\n        case 'bottom':\n            y = -offsetY + baselineOffset;\n            break;\n        }\n\n        switch (anchor) {\n        case 'top-right':\n        case 'bottom-right':\n        case 'right':\n            x = -offsetX;\n            break;\n        case 'top-left':\n        case 'bottom-left':\n        case 'left':\n            x = offsetX;\n            break;\n        }\n\n        return [x, y];\n    }\n\n    return (offset[1] !== INVALID_TEXT_OFFSET) ? fromTextOffset(anchor, offset[0], offset[1]) : fromRadialOffset(anchor, offset[0]);\n}\n\nexport function performSymbolLayout(bucket: SymbolBucket,\n                             glyphMap: {[string]: {[number]: ?StyleGlyph}},\n                             glyphPositions: {[string]: {[number]: GlyphPosition}},\n                             imageMap: {[string]: StyleImage},\n                             imagePositions: {[string]: ImagePosition},\n                             showCollisionBoxes: boolean) {\n    bucket.createArrays();\n\n    const tileSize = 512 * bucket.overscaling;\n    bucket.tilePixelRatio = EXTENT / tileSize;\n    bucket.compareText = {};\n    bucket.iconsNeedLinear = false;\n\n    const layout = bucket.layers[0].layout;\n    const unevaluatedLayoutValues = bucket.layers[0]._unevaluatedLayout._values;\n\n    const sizes = {};\n\n    if (bucket.textSizeData.kind === 'composite') {\n        const {minZoom, maxZoom} = bucket.textSizeData;\n        sizes.compositeTextSizes = [\n            unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(minZoom)),\n            unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(maxZoom))\n        ];\n    }\n\n    if (bucket.iconSizeData.kind === 'composite') {\n        const {minZoom, maxZoom} = bucket.iconSizeData;\n        sizes.compositeIconSizes = [\n            unevaluatedLayoutValues['icon-size'].possiblyEvaluate(new EvaluationParameters(minZoom)),\n            unevaluatedLayoutValues['icon-size'].possiblyEvaluate(new EvaluationParameters(maxZoom))\n        ];\n    }\n\n    sizes.layoutTextSize = unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(bucket.zoom + 1));\n    sizes.layoutIconSize = unevaluatedLayoutValues['icon-size'].possiblyEvaluate(new EvaluationParameters(bucket.zoom + 1));\n    sizes.textMaxSize = unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(18));\n\n    const lineHeight = layout.get('text-line-height') * ONE_EM;\n    const textAlongLine = layout.get('text-rotation-alignment') === 'map' && layout.get('symbol-placement') !== 'point';\n    const keepUpright = layout.get('text-keep-upright');\n\n    for (const feature of bucket.features) {\n        const fontstack = layout.get('text-font').evaluate(feature, {}).join(',');\n        const glyphPositionMap = glyphPositions;\n\n        const shapedTextOrientations = {\n            horizontal: {},\n            vertical: undefined\n        };\n        const text = feature.text;\n        let textOffset: [number, number] = [0, 0];\n        if (text) {\n            const unformattedText = text.toString();\n            const spacing = layout.get('text-letter-spacing').evaluate(feature, {}) * ONE_EM;\n            const spacingIfAllowed = allowsLetterSpacing(unformattedText) ? spacing : 0;\n\n            const textAnchor = layout.get('text-anchor').evaluate(feature, {});\n            const variableTextAnchor = layout.get('text-variable-anchor');\n\n            if (!variableTextAnchor) {\n                const radialOffset = layout.get('text-radial-offset').evaluate(feature, {});\n                // Layers with variable anchors use the `text-radial-offset` property and the [x, y] offset vector\n                // is calculated at placement time instead of layout time\n                if (radialOffset) {\n                    // The style spec says don't use `text-offset` and `text-radial-offset` together\n                    // but doesn't actually specify what happens if you use both. We go with the radial offset.\n                    textOffset = evaluateVariableOffset(textAnchor, [radialOffset * ONE_EM, INVALID_TEXT_OFFSET]);\n                } else {\n                    textOffset = (layout.get('text-offset').evaluate(feature, {}).map(t => t * ONE_EM): any);\n                }\n            }\n\n            let textJustify = textAlongLine ?\n                \"center\" :\n                layout.get('text-justify').evaluate(feature, {});\n\n            const symbolPlacement = layout.get('symbol-placement');\n            const maxWidth = symbolPlacement === 'point' ?\n                layout.get('text-max-width').evaluate(feature, {}) * ONE_EM :\n                0;\n\n            const addVerticalShapingForPointLabelIfNeeded = () => {\n                if (bucket.allowVerticalPlacement && allowsVerticalWritingMode(unformattedText)) {\n                    // Vertical POI label placement is meant to be used for scripts that support vertical\n                    // writing mode, thus, default left justification is used. If Latin\n                    // scripts would need to be supported, this should take into account other justifications.\n                    shapedTextOrientations.vertical = shapeText(text, glyphMap, fontstack, maxWidth, lineHeight, textAnchor,\n                                                                'left', spacingIfAllowed, textOffset, WritingMode.vertical, true, symbolPlacement);\n                }\n            };\n\n            // If this layer uses text-variable-anchor, generate shapings for all justification possibilities.\n            if (!textAlongLine && variableTextAnchor) {\n                const justifications = textJustify === \"auto\" ?\n                    variableTextAnchor.map(a => getAnchorJustification(a)) :\n                    [textJustify];\n\n                let singleLine = false;\n                for (let i = 0; i < justifications.length; i++) {\n                    const justification: TextJustify = justifications[i];\n                    if (shapedTextOrientations.horizontal[justification]) continue;\n                    if (singleLine) {\n                        // If the shaping for the first justification was only a single line, we\n                        // can re-use it for the other justifications\n                        shapedTextOrientations.horizontal[justification] = shapedTextOrientations.horizontal[0];\n                    } else {\n                        // If using text-variable-anchor for the layer, we use a center anchor for all shapings and apply\n                        // the offsets for the anchor in the placement step.\n                        const shaping = shapeText(text, glyphMap, fontstack, maxWidth, lineHeight, 'center',\n                                                  justification, spacingIfAllowed, textOffset, WritingMode.horizontal, false, symbolPlacement);\n                        if (shaping) {\n                            shapedTextOrientations.horizontal[justification] = shaping;\n                            singleLine = shaping.lineCount === 1;\n                        }\n                    }\n                }\n\n                addVerticalShapingForPointLabelIfNeeded();\n            } else {\n                if (textJustify === \"auto\") {\n                    textJustify = getAnchorJustification(textAnchor);\n                }\n\n                // Horizontal point or line label.\n                const shaping = shapeText(text, glyphMap, fontstack, maxWidth, lineHeight, textAnchor, textJustify, spacingIfAllowed,\n                                          textOffset, WritingMode.horizontal, false, symbolPlacement);\n                if (shaping) shapedTextOrientations.horizontal[textJustify] = shaping;\n\n                // Vertical point label (if allowVerticalPlacement is enabled).\n                addVerticalShapingForPointLabelIfNeeded();\n\n                // Verticalized line label.\n                if (allowsVerticalWritingMode(unformattedText) && textAlongLine && keepUpright) {\n                    shapedTextOrientations.vertical = shapeText(text, glyphMap, fontstack, maxWidth, lineHeight, textAnchor, textJustify,\n                                                                spacingIfAllowed, textOffset, WritingMode.vertical, false, symbolPlacement);\n                }\n            }\n\n        }\n\n        let shapedIcon;\n        if (feature.icon && feature.icon.name) {\n            const image = imageMap[feature.icon.name];\n            if (image) {\n                shapedIcon = shapeIcon(\n                    imagePositions[feature.icon.name],\n                    layout.get('icon-offset').evaluate(feature, {}),\n                    layout.get('icon-anchor').evaluate(feature, {}));\n                if (bucket.sdfIcons === undefined) {\n                    bucket.sdfIcons = image.sdf;\n                } else if (bucket.sdfIcons !== image.sdf) {\n                    warnOnce('Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer');\n                }\n                if (image.pixelRatio !== bucket.pixelRatio) {\n                    bucket.iconsNeedLinear = true;\n                } else if (layout.get('icon-rotate').constantOr(1) !== 0) {\n                    bucket.iconsNeedLinear = true;\n                }\n            }\n        }\n\n        if (Object.keys(shapedTextOrientations.horizontal).length || shapedIcon) {\n            addFeature(bucket, feature, shapedTextOrientations, shapedIcon, glyphPositionMap, sizes, textOffset);\n        }\n    }\n\n    if (showCollisionBoxes) {\n        bucket.generateCollisionDebugBuffers();\n    }\n}\n\n// Choose the justification that matches the direction of the TextAnchor\nexport function getAnchorJustification(anchor: TextAnchor): TextJustify  {\n    switch (anchor) {\n    case 'right':\n    case 'top-right':\n    case 'bottom-right':\n        return 'right';\n    case 'left':\n    case 'top-left':\n    case 'bottom-left':\n        return 'left';\n    }\n    return 'center';\n}\n\n/**\n * Given a feature and its shaped text and icon data, add a 'symbol\n * instance' for each _possible_ placement of the symbol feature.\n * (At render timePlaceSymbols#place() selects which of these instances to\n * show or hide based on collisions with symbols in other layers.)\n * @private\n */\nfunction addFeature(bucket: SymbolBucket,\n                    feature: SymbolFeature,\n                    shapedTextOrientations: any,\n                    shapedIcon: PositionedIcon | void,\n                    glyphPositionMap: {[string]: {[number]: GlyphPosition}},\n                    sizes: Sizes,\n                    textOffset: [number, number]) {\n    const layoutTextSize = sizes.layoutTextSize.evaluate(feature, {});\n    const layoutIconSize = sizes.layoutIconSize.evaluate(feature, {});\n\n    // To reduce the number of labels that jump around when zooming we need\n    // to use a text-size value that is the same for all zoom levels.\n    // bucket calculates text-size at a high zoom level so that all tiles can\n    // use the same value when calculating anchor positions.\n    let textMaxSize = sizes.textMaxSize.evaluate(feature, {});\n    if (textMaxSize === undefined) {\n        textMaxSize = layoutTextSize;\n    }\n\n    const layout = bucket.layers[0].layout;\n    const iconOffset = layout.get('icon-offset').evaluate(feature, {});\n    const defaultHorizontalShaping = getDefaultHorizontalShaping(shapedTextOrientations.horizontal);\n    const glyphSize = 24,\n        fontScale = layoutTextSize / glyphSize,\n        textBoxScale = bucket.tilePixelRatio * fontScale,\n        textMaxBoxScale = bucket.tilePixelRatio * textMaxSize / glyphSize,\n        iconBoxScale = bucket.tilePixelRatio * layoutIconSize,\n        symbolMinDistance = bucket.tilePixelRatio * layout.get('symbol-spacing'),\n        textPadding = layout.get('text-padding') * bucket.tilePixelRatio,\n        iconPadding = layout.get('icon-padding') * bucket.tilePixelRatio,\n        textMaxAngle = layout.get('text-max-angle') / 180 * Math.PI,\n        textAlongLine = layout.get('text-rotation-alignment') === 'map' && layout.get('symbol-placement') !== 'point',\n        iconAlongLine = layout.get('icon-rotation-alignment') === 'map' && layout.get('symbol-placement') !== 'point',\n        symbolPlacement = layout.get('symbol-placement'),\n        textRepeatDistance = symbolMinDistance / 2;\n\n    const iconTextFit = layout.get('icon-text-fit');\n    let verticallyShapedIcon;\n    // Adjust shaped icon size when icon-text-fit is used.\n    if (shapedIcon && iconTextFit !== 'none') {\n        if (bucket.allowVerticalPlacement && shapedTextOrientations.vertical) {\n            verticallyShapedIcon = fitIconToText(shapedIcon, shapedTextOrientations.vertical, iconTextFit,\n                layout.get('icon-text-fit-padding'), iconOffset, fontScale);\n        }\n        if (defaultHorizontalShaping) {\n            shapedIcon = fitIconToText(shapedIcon, defaultHorizontalShaping, iconTextFit,\n                                       layout.get('icon-text-fit-padding'), iconOffset, fontScale);\n        }\n    }\n\n    const addSymbolAtAnchor = (line, anchor) => {\n        if (anchor.x < 0 || anchor.x >= EXTENT || anchor.y < 0 || anchor.y >= EXTENT) {\n            // Symbol layers are drawn across tile boundaries, We filter out symbols\n            // outside our tile boundaries (which may be included in vector tile buffers)\n            // to prevent double-drawing symbols.\n            return;\n        }\n\n        addSymbol(bucket, anchor, line, shapedTextOrientations, shapedIcon, verticallyShapedIcon, bucket.layers[0],\n            bucket.collisionBoxArray, feature.index, feature.sourceLayerIndex, bucket.index,\n            textBoxScale, textPadding, textAlongLine, textOffset,\n            iconBoxScale, iconPadding, iconAlongLine, iconOffset,\n            feature, glyphPositionMap, sizes);\n    };\n\n    if (symbolPlacement === 'line') {\n        for (const line of clipLine(feature.geometry, 0, 0, EXTENT, EXTENT)) {\n            const anchors = getAnchors(\n                line,\n                symbolMinDistance,\n                textMaxAngle,\n                shapedTextOrientations.vertical || defaultHorizontalShaping,\n                shapedIcon,\n                glyphSize,\n                textMaxBoxScale,\n                bucket.overscaling,\n                EXTENT\n            );\n            for (const anchor of anchors) {\n                const shapedText = defaultHorizontalShaping;\n                if (!shapedText || !anchorIsTooClose(bucket, shapedText.text, textRepeatDistance, anchor)) {\n                    addSymbolAtAnchor(line, anchor);\n                }\n            }\n        }\n    } else if (symbolPlacement === 'line-center') {\n        // No clipping, multiple lines per feature are allowed\n        // \"lines\" with only one point are ignored as in clipLines\n        for (const line of feature.geometry) {\n            if (line.length > 1) {\n                const anchor = getCenterAnchor(\n                    line,\n                    textMaxAngle,\n                    shapedTextOrientations.vertical || defaultHorizontalShaping,\n                    shapedIcon,\n                    glyphSize,\n                    textMaxBoxScale);\n                if (anchor) {\n                    addSymbolAtAnchor(line, anchor);\n                }\n            }\n        }\n    } else if (feature.type === 'Polygon') {\n        for (const polygon of classifyRings(feature.geometry, 0)) {\n            // 16 here represents 2 pixels\n            const poi = findPoleOfInaccessibility(polygon, 16);\n            addSymbolAtAnchor(polygon[0], new Anchor(poi.x, poi.y, 0));\n        }\n    } else if (feature.type === 'LineString') {\n        // https://github.com/mapbox/mapbox-gl-js/issues/3808\n        for (const line of feature.geometry) {\n            addSymbolAtAnchor(line, new Anchor(line[0].x, line[0].y, 0));\n        }\n    } else if (feature.type === 'Point') {\n        for (const points of feature.geometry) {\n            for (const point of points) {\n                addSymbolAtAnchor([point], new Anchor(point.x, point.y, 0));\n            }\n        }\n    }\n}\n\nconst MAX_PACKED_SIZE = 65535;\n\nfunction addTextVertices(bucket: SymbolBucket,\n                         anchor: Point,\n                         shapedText: Shaping,\n                         layer: SymbolStyleLayer,\n                         textAlongLine: boolean,\n                         feature: SymbolFeature,\n                         textOffset: [number, number],\n                         lineArray: {lineStartIndex: number, lineLength: number},\n                         writingMode: number,\n                         placementTypes: Array<'vertical' | 'center' | 'left' | 'right'>,\n                         placedTextSymbolIndices: {[string]: number},\n                         glyphPositionMap: {[string]: {[number]: GlyphPosition}},\n                         placedIconIndex: number,\n                         sizes: Sizes) {\n    const glyphQuads = getGlyphQuads(anchor, shapedText, textOffset,\n                            layer, textAlongLine, feature, glyphPositionMap, bucket.allowVerticalPlacement);\n\n    const sizeData = bucket.textSizeData;\n    let textSizeData = null;\n\n    if (sizeData.kind === 'source') {\n        textSizeData = [\n            SIZE_PACK_FACTOR * layer.layout.get('text-size').evaluate(feature, {})\n        ];\n        if (textSizeData[0] > MAX_PACKED_SIZE) {\n            warnOnce(`${bucket.layerIds[0]}: Value for \"text-size\" is >= 256. Reduce your \"text-size\".`);\n        }\n    } else if (sizeData.kind === 'composite') {\n        textSizeData = [\n            SIZE_PACK_FACTOR * sizes.compositeTextSizes[0].evaluate(feature, {}),\n            SIZE_PACK_FACTOR * sizes.compositeTextSizes[1].evaluate(feature, {})\n        ];\n        if (textSizeData[0] > MAX_PACKED_SIZE || textSizeData[1] > MAX_PACKED_SIZE) {\n            warnOnce(`${bucket.layerIds[0]}: Value for \"text-size\" is >= 256. Reduce your \"text-size\".`);\n        }\n    }\n\n    bucket.addSymbols(\n        bucket.text,\n        glyphQuads,\n        textSizeData,\n        textOffset,\n        textAlongLine,\n        feature,\n        writingMode,\n        anchor,\n        lineArray.lineStartIndex,\n        lineArray.lineLength,\n        placedIconIndex);\n\n    // The placedSymbolArray is used at render time in drawTileSymbols\n    // These indices allow access to the array at collision detection time\n    for (const placementType of placementTypes) {\n        placedTextSymbolIndices[placementType] = bucket.text.placedSymbolArray.length - 1;\n    }\n\n    return glyphQuads.length * 4;\n}\n\nfunction getDefaultHorizontalShaping(horizontalShaping: {[TextJustify]: Shaping}): Shaping | null {\n    // We don't care which shaping we get because this is used for collision purposes\n    // and all the justifications have the same collision box\n    for (const justification: any in horizontalShaping) {\n        return horizontalShaping[justification];\n    }\n    return null;\n}\n\n/**\n * Add a single label & icon placement.\n *\n * @private\n */\nfunction addSymbol(bucket: SymbolBucket,\n                   anchor: Anchor,\n                   line: Array<Point>,\n                   shapedTextOrientations: any,\n                   shapedIcon: PositionedIcon | void,\n                   verticallyShapedIcon: PositionedIcon | void,\n                   layer: SymbolStyleLayer,\n                   collisionBoxArray: CollisionBoxArray,\n                   featureIndex: number,\n                   sourceLayerIndex: number,\n                   bucketIndex: number,\n                   textBoxScale: number,\n                   textPadding: number,\n                   textAlongLine: boolean,\n                   textOffset: [number, number],\n                   iconBoxScale: number,\n                   iconPadding: number,\n                   iconAlongLine: boolean,\n                   iconOffset: [number, number],\n                   feature: SymbolFeature,\n                   glyphPositionMap: {[string]: {[number]: GlyphPosition}},\n                   sizes: Sizes) {\n    const lineArray = bucket.addToLineVertexArray(anchor, line);\n\n    let textCollisionFeature, iconCollisionFeature, verticalTextCollisionFeature, verticalIconCollisionFeature;\n\n    let numIconVertices = 0;\n    let numVerticalIconVertices = 0;\n    let numHorizontalGlyphVertices = 0;\n    let numVerticalGlyphVertices = 0;\n    let placedIconSymbolIndex = -1;\n    let verticalPlacedIconSymbolIndex = -1;\n    const placedTextSymbolIndices = {};\n    let key = murmur3('');\n\n    let textOffset0 = 0;\n    let textOffset1 = 0;\n    if (layer._unevaluatedLayout.getValue('text-radial-offset') === undefined) {\n        [textOffset0, textOffset1] = (layer.layout.get('text-offset').evaluate(feature, {}).map(t => t * ONE_EM): any);\n    } else {\n        textOffset0 = layer.layout.get('text-radial-offset').evaluate(feature, {}) * ONE_EM;\n        textOffset1 = INVALID_TEXT_OFFSET;\n    }\n\n    if (bucket.allowVerticalPlacement && shapedTextOrientations.vertical) {\n        const textRotation = layer.layout.get('text-rotate').evaluate(feature, {});\n        const verticalTextRotation = textRotation + 90.0;\n        const verticalShaping = shapedTextOrientations.vertical;\n        verticalTextCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, verticalShaping, textBoxScale, textPadding, textAlongLine, bucket.overscaling, verticalTextRotation);\n\n        if (verticallyShapedIcon) {\n            verticalIconCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, verticallyShapedIcon, iconBoxScale, iconPadding, textAlongLine, bucket.overscaling, verticalTextRotation);\n        }\n    }\n\n    //Place icon first, so text can have a reference to its index in the placed symbol array.\n    //Text symbols can lazily shift at render-time because of variable anchor placement.\n    //If the style specifies an `icon-text-fit` then the icon would have to shift along with it.\n    // For more info check `updateVariableAnchors` in `draw_symbol.js` .\n    if (shapedIcon) {\n        const iconRotate = layer.layout.get('icon-rotate').evaluate(feature, {});\n        const iconQuads = getIconQuads(shapedIcon, iconRotate);\n        const verticalIconQuads = verticallyShapedIcon ? getIconQuads(verticallyShapedIcon, iconRotate) : undefined;\n        iconCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, shapedIcon, iconBoxScale, iconPadding, /*align boxes to line*/false, bucket.overscaling, iconRotate);\n\n        numIconVertices = iconQuads.length * 4;\n\n        const sizeData = bucket.iconSizeData;\n        let iconSizeData = null;\n\n        if (sizeData.kind === 'source') {\n            iconSizeData = [\n                SIZE_PACK_FACTOR * layer.layout.get('icon-size').evaluate(feature, {})\n            ];\n            if (iconSizeData[0] > MAX_PACKED_SIZE) {\n                warnOnce(`${bucket.layerIds[0]}: Value for \"icon-size\" is >= 256. Reduce your \"icon-size\".`);\n            }\n        } else if (sizeData.kind === 'composite') {\n            iconSizeData = [\n                SIZE_PACK_FACTOR * sizes.compositeIconSizes[0].evaluate(feature, {}),\n                SIZE_PACK_FACTOR * sizes.compositeIconSizes[1].evaluate(feature, {})\n            ];\n            if (iconSizeData[0] > MAX_PACKED_SIZE || iconSizeData[1] > MAX_PACKED_SIZE) {\n                warnOnce(`${bucket.layerIds[0]}: Value for \"icon-size\" is >= 256. Reduce your \"icon-size\".`);\n            }\n        }\n\n        bucket.addSymbols(\n            bucket.icon,\n            iconQuads,\n            iconSizeData,\n            iconOffset,\n            iconAlongLine,\n            feature,\n            false,\n            anchor,\n            lineArray.lineStartIndex,\n            lineArray.lineLength,\n            // The icon itself does not have an associated symbol since the text isnt placed yet\n            -1);\n\n        placedIconSymbolIndex = bucket.icon.placedSymbolArray.length - 1;\n\n        if (verticalIconQuads) {\n            numVerticalIconVertices = verticalIconQuads.length * 4;\n\n            bucket.addSymbols(\n                bucket.icon,\n                verticalIconQuads,\n                iconSizeData,\n                iconOffset,\n                iconAlongLine,\n                feature,\n                WritingMode.vertical,\n                anchor,\n                lineArray.lineStartIndex,\n                lineArray.lineLength,\n                // The icon itself does not have an associated symbol since the text isnt placed yet\n                -1);\n\n            verticalPlacedIconSymbolIndex = bucket.icon.placedSymbolArray.length - 1;\n        }\n    }\n\n    for (const justification: any in shapedTextOrientations.horizontal) {\n        const shaping = shapedTextOrientations.horizontal[justification];\n\n        if (!textCollisionFeature) {\n            key = murmur3(shaping.text);\n            const textRotate = layer.layout.get('text-rotate').evaluate(feature, {});\n            // As a collision approximation, we can use either the vertical or any of the horizontal versions of the feature\n            // We're counting on all versions having similar dimensions\n            textCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, shaping, textBoxScale, textPadding, textAlongLine, bucket.overscaling, textRotate);\n        }\n\n        const singleLine = shaping.lineCount === 1;\n        numHorizontalGlyphVertices += addTextVertices(\n            bucket, anchor, shaping, layer, textAlongLine, feature, textOffset, lineArray,\n            shapedTextOrientations.vertical ? WritingMode.horizontal : WritingMode.horizontalOnly,\n            singleLine ? (Object.keys(shapedTextOrientations.horizontal): any) : [justification],\n            placedTextSymbolIndices, glyphPositionMap, placedIconSymbolIndex, sizes);\n\n        if (singleLine) {\n            break;\n        }\n    }\n\n    if (shapedTextOrientations.vertical) {\n        numVerticalGlyphVertices += addTextVertices(\n            bucket, anchor, shapedTextOrientations.vertical, layer, textAlongLine, feature,\n            textOffset, lineArray, WritingMode.vertical, ['vertical'], placedTextSymbolIndices, glyphPositionMap, verticalPlacedIconSymbolIndex, sizes);\n    }\n\n    const textBoxStartIndex = textCollisionFeature ? textCollisionFeature.boxStartIndex : bucket.collisionBoxArray.length;\n    const textBoxEndIndex = textCollisionFeature ? textCollisionFeature.boxEndIndex : bucket.collisionBoxArray.length;\n\n    const verticalTextBoxStartIndex = verticalTextCollisionFeature ? verticalTextCollisionFeature.boxStartIndex : bucket.collisionBoxArray.length;\n    const verticalTextBoxEndIndex = verticalTextCollisionFeature ? verticalTextCollisionFeature.boxEndIndex : bucket.collisionBoxArray.length;\n\n    const iconBoxStartIndex = iconCollisionFeature ? iconCollisionFeature.boxStartIndex : bucket.collisionBoxArray.length;\n    const iconBoxEndIndex = iconCollisionFeature ? iconCollisionFeature.boxEndIndex : bucket.collisionBoxArray.length;\n\n    const verticalIconBoxStartIndex = verticalIconCollisionFeature ? verticalIconCollisionFeature.boxStartIndex : bucket.collisionBoxArray.length;\n    const verticalIconBoxEndIndex = verticalIconCollisionFeature ? verticalIconCollisionFeature.boxEndIndex : bucket.collisionBoxArray.length;\n\n    if (bucket.glyphOffsetArray.length >= SymbolBucket.MAX_GLYPHS) warnOnce(\n        \"Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907\"\n    );\n\n    bucket.symbolInstances.emplaceBack(\n        anchor.x,\n        anchor.y,\n        placedTextSymbolIndices.right >= 0 ? placedTextSymbolIndices.right : -1,\n        placedTextSymbolIndices.center >= 0 ? placedTextSymbolIndices.center : -1,\n        placedTextSymbolIndices.left >= 0 ? placedTextSymbolIndices.left : -1,\n        placedTextSymbolIndices.vertical || -1,\n        placedIconSymbolIndex,\n        verticalPlacedIconSymbolIndex,\n        key,\n        textBoxStartIndex,\n        textBoxEndIndex,\n        verticalTextBoxStartIndex,\n        verticalTextBoxEndIndex,\n        iconBoxStartIndex,\n        iconBoxEndIndex,\n        verticalIconBoxStartIndex,\n        verticalIconBoxEndIndex,\n        featureIndex,\n        numHorizontalGlyphVertices,\n        numVerticalGlyphVertices,\n        numIconVertices,\n        numVerticalIconVertices,\n        0,\n        textBoxScale,\n        textOffset0,\n        textOffset1);\n}\n\nfunction anchorIsTooClose(bucket: any, text: string, repeatDistance: number, anchor: Point) {\n    const compareText = bucket.compareText;\n    if (!(text in compareText)) {\n        compareText[text] = [];\n    } else {\n        const otherAnchors = compareText[text];\n        for (let k = otherAnchors.length - 1; k >= 0; k--) {\n            if (anchor.dist(otherAnchors[k]) < repeatDistance) {\n                // If it's within repeatDistance of one anchor, stop looking\n                return true;\n            }\n        }\n    }\n    // If anchor is not within repeatDistance of any other anchor, add to array\n    compareText[text].push(anchor);\n    return false;\n}\n","// @flow\n\nimport assert from 'assert';\nimport {\n    charHasUprightVerticalOrientation,\n    charAllowsIdeographicBreaking,\n    charInComplexShapingScript\n} from '../util/script_detection';\nimport verticalizePunctuation from '../util/verticalize_punctuation';\nimport {plugin as rtlTextPlugin} from '../source/rtl_text_plugin';\nimport ONE_EM from './one_em';\n\nimport type {StyleGlyph} from '../style/style_glyph';\nimport type {ImagePosition} from '../render/image_atlas';\nimport Formatted from '../style-spec/expression/types/formatted';\n\nconst WritingMode = {\n    horizontal: 1,\n    vertical: 2,\n    horizontalOnly: 3\n};\n\nexport {shapeText, shapeIcon, fitIconToText, getAnchorAlignment, WritingMode};\n\n// The position of a glyph relative to the text's anchor point.\nexport type PositionedGlyph = {\n    glyph: number,\n    x: number,\n    y: number,\n    vertical: boolean,\n    scale: number,\n    fontStack: string,\n    sectionIndex: number\n};\n\n// A collection of positioned glyphs and some metadata\nexport type Shaping = {\n    positionedGlyphs: Array<PositionedGlyph>,\n    top: number,\n    bottom: number,\n    left: number,\n    right: number,\n    writingMode: 1 | 2,\n    lineCount: number,\n    text: string,\n    yOffset: number,\n};\n\nexport type SymbolAnchor = 'center' | 'left' | 'right' | 'top' | 'bottom' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\nexport type TextJustify = 'left' | 'center' | 'right';\n\nclass TaggedString {\n    text: string;\n    sectionIndex: Array<number> // maps each character in 'text' to its corresponding entry in 'sections'\n    sections: Array<{ scale: number, fontStack: string }>\n\n    constructor() {\n        this.text = \"\";\n        this.sectionIndex = [];\n        this.sections = [];\n    }\n\n    static fromFeature(text: Formatted, defaultFontStack: string) {\n        const result = new TaggedString();\n        for (let i = 0; i < text.sections.length; i++) {\n            const section = text.sections[i];\n            result.sections.push({\n                scale: section.scale || 1,\n                fontStack: section.fontStack || defaultFontStack\n            });\n            result.text += section.text;\n            for (let j = 0; j < section.text.length; j++) {\n                result.sectionIndex.push(i);\n            }\n        }\n        return result;\n    }\n\n    length(): number {\n        return this.text.length;\n    }\n\n    getSection(index: number): { scale: number, fontStack: string } {\n        return this.sections[this.sectionIndex[index]];\n    }\n\n    getSectionIndex(index: number): number {\n        return this.sectionIndex[index];\n    }\n\n    getCharCode(index: number): number {\n        return this.text.charCodeAt(index);\n    }\n\n    verticalizePunctuation() {\n        this.text = verticalizePunctuation(this.text);\n    }\n\n    trim() {\n        let beginningWhitespace = 0;\n        for (let i = 0;\n            i < this.text.length && whitespace[this.text.charCodeAt(i)];\n            i++) {\n            beginningWhitespace++;\n        }\n        let trailingWhitespace = this.text.length;\n        for (let i = this.text.length - 1;\n            i >= 0 && i >= beginningWhitespace && whitespace[this.text.charCodeAt(i)];\n            i--) {\n            trailingWhitespace--;\n        }\n        this.text = this.text.substring(beginningWhitespace, trailingWhitespace);\n        this.sectionIndex = this.sectionIndex.slice(beginningWhitespace, trailingWhitespace);\n    }\n\n    substring(start: number, end: number): TaggedString {\n        const substring = new TaggedString();\n        substring.text = this.text.substring(start, end);\n        substring.sectionIndex = this.sectionIndex.slice(start, end);\n        substring.sections = this.sections;\n        return substring;\n    }\n\n    toString(): string {\n        return this.text;\n    }\n\n    getMaxScale() {\n        return this.sectionIndex.reduce((max, index) => Math.max(max, this.sections[index].scale), 0);\n    }\n}\n\nfunction breakLines(input: TaggedString, lineBreakPoints: Array<number>): Array<TaggedString> {\n    const lines = [];\n    const text = input.text;\n    let start = 0;\n    for (const lineBreak of lineBreakPoints) {\n        lines.push(input.substring(start, lineBreak));\n        start = lineBreak;\n    }\n\n    if (start < text.length) {\n        lines.push(input.substring(start, text.length));\n    }\n    return lines;\n}\n\nfunction shapeText(text: Formatted,\n                   glyphs: {[string]: {[number]: ?StyleGlyph}},\n                   defaultFontStack: string,\n                   maxWidth: number,\n                   lineHeight: number,\n                   textAnchor: SymbolAnchor,\n                   textJustify: TextJustify,\n                   spacing: number,\n                   translate: [number, number],\n                   writingMode: 1 | 2,\n                   allowVerticalPlacement: boolean,\n                   symbolPlacement: string): Shaping | false {\n    const logicalInput = TaggedString.fromFeature(text, defaultFontStack);\n\n    if (writingMode === WritingMode.vertical) {\n        logicalInput.verticalizePunctuation();\n    }\n\n    let lines: Array<TaggedString>;\n\n    const {processBidirectionalText, processStyledBidirectionalText} = rtlTextPlugin;\n    if (processBidirectionalText && logicalInput.sections.length === 1) {\n        // Bidi doesn't have to be style-aware\n        lines = [];\n        const untaggedLines =\n            processBidirectionalText(logicalInput.toString(),\n                                     determineLineBreaks(logicalInput, spacing, maxWidth, glyphs, symbolPlacement));\n        for (const line of untaggedLines) {\n            const taggedLine = new TaggedString();\n            taggedLine.text = line;\n            taggedLine.sections = logicalInput.sections;\n            for (let i = 0; i < line.length; i++) {\n                taggedLine.sectionIndex.push(0);\n            }\n            lines.push(taggedLine);\n        }\n    } else if (processStyledBidirectionalText) {\n        // Need version of mapbox-gl-rtl-text with style support for combining RTL text\n        // with formatting\n        lines = [];\n        const processedLines =\n            processStyledBidirectionalText(logicalInput.text,\n                                           logicalInput.sectionIndex,\n                                           determineLineBreaks(logicalInput, spacing, maxWidth, glyphs, symbolPlacement));\n        for (const line of processedLines) {\n            const taggedLine = new TaggedString();\n            taggedLine.text = line[0];\n            taggedLine.sectionIndex = line[1];\n            taggedLine.sections = logicalInput.sections;\n            lines.push(taggedLine);\n        }\n    } else {\n        lines = breakLines(logicalInput, determineLineBreaks(logicalInput, spacing, maxWidth, glyphs, symbolPlacement));\n    }\n\n    const positionedGlyphs = [];\n    const shaping = {\n        positionedGlyphs,\n        text: logicalInput.toString(),\n        top: translate[1],\n        bottom: translate[1],\n        left: translate[0],\n        right: translate[0],\n        writingMode,\n        lineCount: lines.length,\n        yOffset: -17 // the y offset *should* be part of the font metadata\n    };\n\n    shapeLines(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, writingMode, spacing, allowVerticalPlacement);\n    if (!positionedGlyphs.length) return false;\n\n    return shaping;\n}\n\n// using computed properties due to https://github.com/facebook/flow/issues/380\n/* eslint no-useless-computed-key: 0 */\n\nconst whitespace: {[number]: boolean} = {\n    [0x09]: true, // tab\n    [0x0a]: true, // newline\n    [0x0b]: true, // vertical tab\n    [0x0c]: true, // form feed\n    [0x0d]: true, // carriage return\n    [0x20]: true, // space\n};\n\nconst breakable: {[number]: boolean} = {\n    [0x0a]:   true, // newline\n    [0x20]:   true, // space\n    [0x26]:   true, // ampersand\n    [0x28]:   true, // left parenthesis\n    [0x29]:   true, // right parenthesis\n    [0x2b]:   true, // plus sign\n    [0x2d]:   true, // hyphen-minus\n    [0x2f]:   true, // solidus\n    [0xad]:   true, // soft hyphen\n    [0xb7]:   true, // middle dot\n    [0x200b]: true, // zero-width space\n    [0x2010]: true, // hyphen\n    [0x2013]: true, // en dash\n    [0x2027]: true  // interpunct\n    // Many other characters may be reasonable breakpoints\n    // Consider \"neutral orientation\" characters at scriptDetection.charHasNeutralVerticalOrientation\n    // See https://github.com/mapbox/mapbox-gl-js/issues/3658\n};\n\nfunction determineAverageLineWidth(logicalInput: TaggedString,\n                                   spacing: number,\n                                   maxWidth: number,\n                                   glyphMap: {[string]: {[number]: ?StyleGlyph}}) {\n    let totalWidth = 0;\n\n    for (let index = 0; index < logicalInput.length(); index++) {\n        const section = logicalInput.getSection(index);\n        const positions = glyphMap[section.fontStack];\n        const glyph = positions && positions[logicalInput.getCharCode(index)];\n        if (!glyph)\n            continue;\n        totalWidth += glyph.metrics.advance * section.scale + spacing;\n    }\n\n    const lineCount = Math.max(1, Math.ceil(totalWidth / maxWidth));\n    return totalWidth / lineCount;\n}\n\nfunction calculateBadness(lineWidth: number,\n                          targetWidth: number,\n                          penalty: number,\n                          isLastBreak: boolean) {\n    const raggedness = Math.pow(lineWidth - targetWidth, 2);\n    if (isLastBreak) {\n        // Favor finals lines shorter than average over longer than average\n        if (lineWidth < targetWidth) {\n            return raggedness / 2;\n        } else {\n            return raggedness * 2;\n        }\n    }\n\n    return raggedness + Math.abs(penalty) * penalty;\n}\n\nfunction calculatePenalty(codePoint: number, nextCodePoint: number, penalizableIdeographicBreak: boolean) {\n    let penalty = 0;\n    // Force break on newline\n    if (codePoint === 0x0a) {\n        penalty -= 10000;\n    }\n    // Penalize breaks between characters that allow ideographic breaking because\n    // they are less preferable than breaks at spaces (or zero width spaces).\n    if (penalizableIdeographicBreak) {\n        penalty += 150;\n    }\n\n    // Penalize open parenthesis at end of line\n    if (codePoint === 0x28 || codePoint === 0xff08) {\n        penalty += 50;\n    }\n\n    // Penalize close parenthesis at beginning of line\n    if (nextCodePoint === 0x29 || nextCodePoint === 0xff09) {\n        penalty += 50;\n    }\n    return penalty;\n}\n\ntype Break = {\n    index: number,\n    x: number,\n    priorBreak: ?Break,\n    badness: number\n};\n\nfunction evaluateBreak(breakIndex: number,\n                       breakX: number,\n                       targetWidth: number,\n                       potentialBreaks: Array<Break>,\n                       penalty: number,\n                       isLastBreak: boolean): Break {\n    // We could skip evaluating breaks where the line length (breakX - priorBreak.x) > maxWidth\n    //  ...but in fact we allow lines longer than maxWidth (if there's no break points)\n    //  ...and when targetWidth and maxWidth are close, strictly enforcing maxWidth can give\n    //     more lopsided results.\n\n    let bestPriorBreak: ?Break = null;\n    let bestBreakBadness = calculateBadness(breakX, targetWidth, penalty, isLastBreak);\n\n    for (const potentialBreak of potentialBreaks) {\n        const lineWidth = breakX - potentialBreak.x;\n        const breakBadness =\n            calculateBadness(lineWidth, targetWidth, penalty, isLastBreak) + potentialBreak.badness;\n        if (breakBadness <= bestBreakBadness) {\n            bestPriorBreak = potentialBreak;\n            bestBreakBadness = breakBadness;\n        }\n    }\n\n    return {\n        index: breakIndex,\n        x: breakX,\n        priorBreak: bestPriorBreak,\n        badness: bestBreakBadness\n    };\n}\n\nfunction leastBadBreaks(lastLineBreak: ?Break): Array<number> {\n    if (!lastLineBreak) {\n        return [];\n    }\n    return leastBadBreaks(lastLineBreak.priorBreak).concat(lastLineBreak.index);\n}\n\nfunction determineLineBreaks(logicalInput: TaggedString,\n                             spacing: number,\n                             maxWidth: number,\n                             glyphMap: {[string]: {[number]: ?StyleGlyph}},\n                             symbolPlacement: string): Array<number> {\n    if (symbolPlacement !== 'point')\n        return [];\n\n    if (!logicalInput)\n        return [];\n\n    const potentialLineBreaks = [];\n    const targetWidth = determineAverageLineWidth(logicalInput, spacing, maxWidth, glyphMap);\n\n    const hasServerSuggestedBreakpoints = logicalInput.text.indexOf(\"\\u200b\") >= 0;\n\n    let currentX = 0;\n\n    for (let i = 0; i < logicalInput.length(); i++) {\n        const section = logicalInput.getSection(i);\n        const codePoint = logicalInput.getCharCode(i);\n        const positions = glyphMap[section.fontStack];\n        const glyph = positions && positions[codePoint];\n\n        if (glyph && !whitespace[codePoint])\n            currentX += glyph.metrics.advance * section.scale + spacing;\n\n        // Ideographic characters, spaces, and word-breaking punctuation that often appear without\n        // surrounding spaces.\n        if ((i < logicalInput.length() - 1)) {\n            const ideographicBreak = charAllowsIdeographicBreaking(codePoint);\n            if (breakable[codePoint] || ideographicBreak) {\n\n                potentialLineBreaks.push(\n                    evaluateBreak(\n                        i + 1,\n                        currentX,\n                        targetWidth,\n                        potentialLineBreaks,\n                        calculatePenalty(codePoint, logicalInput.getCharCode(i + 1), ideographicBreak && hasServerSuggestedBreakpoints),\n                        false));\n            }\n        }\n    }\n\n    return leastBadBreaks(\n        evaluateBreak(\n            logicalInput.length(),\n            currentX,\n            targetWidth,\n            potentialLineBreaks,\n            0,\n            true));\n}\n\nfunction getAnchorAlignment(anchor: SymbolAnchor) {\n    let horizontalAlign = 0.5, verticalAlign = 0.5;\n\n    switch (anchor) {\n    case 'right':\n    case 'top-right':\n    case 'bottom-right':\n        horizontalAlign = 1;\n        break;\n    case 'left':\n    case 'top-left':\n    case 'bottom-left':\n        horizontalAlign = 0;\n        break;\n    }\n\n    switch (anchor) {\n    case 'bottom':\n    case 'bottom-right':\n    case 'bottom-left':\n        verticalAlign = 1;\n        break;\n    case 'top':\n    case 'top-right':\n    case 'top-left':\n        verticalAlign = 0;\n        break;\n    }\n\n    return {horizontalAlign, verticalAlign};\n}\n\nfunction shapeLines(shaping: Shaping,\n                    glyphMap: {[string]: {[number]: ?StyleGlyph}},\n                    lines: Array<TaggedString>,\n                    lineHeight: number,\n                    textAnchor: SymbolAnchor,\n                    textJustify: TextJustify,\n                    writingMode: 1 | 2,\n                    spacing: number,\n                    allowVerticalPlacement: boolean) {\n\n    let x = 0;\n    let y = shaping.yOffset;\n\n    let maxLineLength = 0;\n    const positionedGlyphs = shaping.positionedGlyphs;\n\n    const justify =\n        textJustify === 'right' ? 1 :\n        textJustify === 'left' ? 0 : 0.5;\n\n    for (const line of lines) {\n        line.trim();\n\n        const lineMaxScale = line.getMaxScale();\n\n        if (!line.length()) {\n            y += lineHeight; // Still need a line feed after empty line\n            continue;\n        }\n\n        const lineStartIndex = positionedGlyphs.length;\n        for (let i = 0; i < line.length(); i++) {\n            const section = line.getSection(i);\n            const sectionIndex = line.getSectionIndex(i);\n            const codePoint = line.getCharCode(i);\n            // We don't know the baseline, but since we're laying out\n            // at 24 points, we can calculate how much it will move when\n            // we scale up or down.\n            const baselineOffset = (lineMaxScale - section.scale) * 24;\n            const positions = glyphMap[section.fontStack];\n            const glyph = positions && positions[codePoint];\n\n            if (!glyph) continue;\n\n            if (writingMode === WritingMode.horizontal ||\n                // Don't verticalize glyphs that have no upright orientation if vertical placement is disabled.\n                (!allowVerticalPlacement && !charHasUprightVerticalOrientation(codePoint)) ||\n                // If vertical placement is ebabled, don't verticalize glyphs that\n                // are from complex text layout script, or whitespaces.\n                (allowVerticalPlacement && (whitespace[codePoint] || charInComplexShapingScript(codePoint)))) {\n                positionedGlyphs.push({glyph: codePoint, x, y: y + baselineOffset, vertical: false, scale: section.scale, fontStack: section.fontStack, sectionIndex});\n                x += glyph.metrics.advance * section.scale + spacing;\n            } else {\n                positionedGlyphs.push({glyph: codePoint, x, y: y + baselineOffset, vertical: true, scale: section.scale, fontStack: section.fontStack, sectionIndex});\n                x += ONE_EM * section.scale + spacing;\n            }\n        }\n\n        // Only justify if we placed at least one glyph\n        if (positionedGlyphs.length !== lineStartIndex) {\n            const lineLength = x - spacing;\n            maxLineLength = Math.max(lineLength, maxLineLength);\n\n            justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);\n        }\n\n        x = 0;\n        y += lineHeight * lineMaxScale;\n    }\n\n    const {horizontalAlign, verticalAlign} = getAnchorAlignment(textAnchor);\n    align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lines.length);\n\n    // Calculate the bounding box\n    const height = y - shaping.yOffset;\n\n    shaping.top += -verticalAlign * height;\n    shaping.bottom = shaping.top + height;\n    shaping.left += -horizontalAlign * maxLineLength;\n    shaping.right = shaping.left + maxLineLength;\n}\n\n// justify right = 1, left = 0, center = 0.5\nfunction justifyLine(positionedGlyphs: Array<PositionedGlyph>,\n                     glyphMap: {[string]: {[number]: ?StyleGlyph}},\n                     start: number,\n                     end: number,\n                     justify: 1 | 0 | 0.5) {\n    if (!justify)\n        return;\n\n    const lastPositionedGlyph = positionedGlyphs[end];\n    const positions = glyphMap[lastPositionedGlyph.fontStack];\n    const glyph = positions && positions[lastPositionedGlyph.glyph];\n    if (glyph) {\n        const lastAdvance = glyph.metrics.advance * lastPositionedGlyph.scale;\n        const lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;\n\n        for (let j = start; j <= end; j++) {\n            positionedGlyphs[j].x -= lineIndent;\n        }\n    }\n}\n\nfunction align(positionedGlyphs: Array<PositionedGlyph>,\n               justify: number,\n               horizontalAlign: number,\n               verticalAlign: number,\n               maxLineLength: number,\n               lineHeight: number,\n               lineCount: number) {\n    const shiftX = (justify - horizontalAlign) * maxLineLength;\n    const shiftY = (-verticalAlign * lineCount + 0.5) * lineHeight;\n\n    for (let j = 0; j < positionedGlyphs.length; j++) {\n        positionedGlyphs[j].x += shiftX;\n        positionedGlyphs[j].y += shiftY;\n    }\n}\n\nexport type PositionedIcon = {\n    image: ImagePosition,\n    top: number,\n    bottom: number,\n    left: number,\n    right: number\n};\n\nfunction shapeIcon(image: ImagePosition, iconOffset: [number, number], iconAnchor: SymbolAnchor): PositionedIcon {\n    const {horizontalAlign, verticalAlign} = getAnchorAlignment(iconAnchor);\n    const dx = iconOffset[0];\n    const dy = iconOffset[1];\n    const x1 = dx - image.displaySize[0] * horizontalAlign;\n    const x2 = x1 + image.displaySize[0];\n    const y1 = dy - image.displaySize[1] * verticalAlign;\n    const y2 = y1 + image.displaySize[1];\n    return {image, top: y1, bottom: y2, left: x1, right: x2};\n}\n\nfunction fitIconToText(shapedIcon: PositionedIcon, shapedText: Shaping,\n                       textFit: string,\n                       padding: [ number, number, number, number ],\n                       iconOffset: [ number, number ], fontScale: number): PositionedIcon {\n    assert(textFit !== 'none');\n    assert(Array.isArray(padding) && padding.length === 4);\n    assert(Array.isArray(iconOffset) && iconOffset.length === 2);\n\n    const image = shapedIcon.image;\n\n    // We don't respect the icon-anchor, because icon-text-fit is set. Instead,\n    // the icon will be centered on the text, then stretched in the given\n    // dimensions.\n\n    const textLeft = shapedText.left * fontScale;\n    const textRight = shapedText.right * fontScale;\n\n    let top, right, bottom, left;\n    if (textFit === 'width' || textFit === 'both') {\n        // Stretched horizontally to the text width\n        left = iconOffset[0] + textLeft - padding[3];\n        right = iconOffset[0] + textRight + padding[1];\n    } else {\n        // Centered on the text\n        left = iconOffset[0] + (textLeft + textRight - image.displaySize[0]) / 2;\n        right = left + image.displaySize[0];\n    }\n\n    const textTop = shapedText.top * fontScale;\n    const textBottom = shapedText.bottom * fontScale;\n    if (textFit === 'height' || textFit === 'both') {\n        // Stretched vertically to the text height\n        top = iconOffset[1] + textTop - padding[0];\n        bottom = iconOffset[1] + textBottom + padding[2];\n    } else {\n        // Centered on the text\n        top = iconOffset[1] + (textTop + textBottom - image.displaySize[1]) / 2;\n        bottom = top + image.displaySize[1];\n    }\n\n    return {image, top, right, bottom, left};\n}\n","// @flow\n\nimport Point from '@mapbox/point-geometry';\n\nexport default clipLine;\n\n/**\n * Returns the part of a multiline that intersects with the provided rectangular box.\n *\n * @param lines\n * @param x1 the left edge of the box\n * @param y1 the top edge of the box\n * @param x2 the right edge of the box\n * @param y2 the bottom edge of the box\n * @returns lines\n * @private\n */\nfunction clipLine(lines: Array<Array<Point>>, x1: number, y1: number, x2: number, y2: number): Array<Array<Point>> {\n    const clippedLines = [];\n\n    for (let l = 0; l < lines.length; l++) {\n        const line = lines[l];\n        let clippedLine;\n\n        for (let i = 0; i < line.length - 1; i++) {\n            let p0 = line[i];\n            let p1 = line[i + 1];\n\n            if (p0.x < x1 && p1.x < x1) {\n                continue;\n            } else if (p0.x < x1) {\n                p0 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();\n            } else if (p1.x < x1) {\n                p1 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();\n            }\n\n            if (p0.y < y1 && p1.y < y1) {\n                continue;\n            } else if (p0.y < y1) {\n                p0 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();\n            } else if (p1.y < y1) {\n                p1 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();\n            }\n\n            if (p0.x >= x2 && p1.x >= x2) {\n                continue;\n            } else if (p0.x >= x2) {\n                p0 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();\n            } else if (p1.x >= x2) {\n                p1 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();\n            }\n\n            if (p0.y >= y2 && p1.y >= y2) {\n                continue;\n            } else if (p0.y >= y2) {\n                p0 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();\n            } else if (p1.y >= y2) {\n                p1 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();\n            }\n\n            if (!clippedLine || !p0.equals(clippedLine[clippedLine.length - 1])) {\n                clippedLine = [p0];\n                clippedLines.push(clippedLine);\n            }\n\n            clippedLine.push(p1);\n        }\n    }\n\n    return clippedLines;\n}\n","// @flow\n\nimport {warnOnce, parseCacheControl} from './util';\nimport window from './window';\n\nimport type Dispatcher from './dispatcher';\n\nconst CACHE_NAME = 'mapbox-tiles';\nlet cacheLimit = 500; // 50MB / (100KB/tile) ~= 500 tiles\nlet cacheCheckThreshold = 50;\n\nconst MIN_TIME_UNTIL_EXPIRY = 1000 * 60 * 7; // 7 minutes. Skip caching tiles with a short enough max age.\n\nexport type ResponseOptions = {\n    status: number,\n    statusText: string,\n    headers: window.Headers\n};\n\nlet responseConstructorSupportsReadableStream;\nfunction prepareBody(response: Response, callback) {\n    if (responseConstructorSupportsReadableStream === undefined) {\n        try {\n            new Response(new ReadableStream()); // eslint-disable-line no-undef\n            responseConstructorSupportsReadableStream = true;\n        } catch (e) {\n            // Edge\n            responseConstructorSupportsReadableStream = false;\n        }\n    }\n\n    if (responseConstructorSupportsReadableStream) {\n        callback(response.body);\n    } else {\n        response.blob().then(callback);\n    }\n}\n\nexport function cachePut(request: Request, response: Response, requestTime: number) {\n    if (!window.caches) return;\n\n    const options: ResponseOptions = {\n        status: response.status,\n        statusText: response.statusText,\n        headers: new window.Headers()\n    };\n    response.headers.forEach((v, k) => options.headers.set(k, v));\n\n    const cacheControl = parseCacheControl(response.headers.get('Cache-Control') || '');\n    if (cacheControl['no-store']) {\n        return;\n    }\n    if (cacheControl['max-age']) {\n        options.headers.set('Expires', new Date(requestTime + cacheControl['max-age'] * 1000).toUTCString());\n    }\n\n    const timeUntilExpiry = new Date(options.headers.get('Expires')).getTime() - requestTime;\n    if (timeUntilExpiry < MIN_TIME_UNTIL_EXPIRY) return;\n\n    prepareBody(response, body => {\n        const clonedResponse = new window.Response(body, options);\n\n        window.caches.open(CACHE_NAME)\n            .then(cache => cache.put(stripQueryParameters(request.url), clonedResponse))\n            .catch(e => warnOnce(e.message));\n    });\n}\n\nfunction stripQueryParameters(url: string) {\n    const start = url.indexOf('?');\n    return start < 0 ? url : url.slice(0, start);\n}\n\nexport function cacheGet(request: Request, callback: (error: ?any, response: ?Response, fresh: ?boolean) => void) {\n    if (!window.caches) return callback(null);\n\n    const strippedURL = stripQueryParameters(request.url);\n\n    window.caches.open(CACHE_NAME)\n        .then(cache => {\n            // manually strip URL instead of `ignoreSearch: true` because of a known\n            // performance issue in Chrome https://github.com/mapbox/mapbox-gl-js/issues/8431\n            cache.match(strippedURL)\n                .then(response => {\n                    const fresh = isFresh(response);\n\n                    // Reinsert into cache so that order of keys in the cache is the order of access.\n                    // This line makes the cache a LRU instead of a FIFO cache.\n                    cache.delete(strippedURL);\n                    if (fresh) {\n                        cache.put(strippedURL, response.clone());\n                    }\n\n                    callback(null, response, fresh);\n                })\n                .catch(callback);\n        })\n        .catch(callback);\n\n}\n\nfunction isFresh(response) {\n    if (!response) return false;\n    const expires = new Date(response.headers.get('Expires'));\n    const cacheControl = parseCacheControl(response.headers.get('Cache-Control') || '');\n    return expires > Date.now() && !cacheControl['no-cache'];\n}\n\n// `Infinity` triggers a cache check after the first tile is loaded\n// so that a check is run at least once on each page load.\nlet globalEntryCounter = Infinity;\n\n// The cache check gets run on a worker. The reason for this is that\n// profiling sometimes shows this as taking up significant time on the\n// thread it gets called from. And sometimes it doesn't. It *may* be\n// fine to run this on the main thread but out of caution this is being\n// dispatched on a worker. This can be investigated further in the future.\nexport function cacheEntryPossiblyAdded(dispatcher: Dispatcher) {\n    globalEntryCounter++;\n    if (globalEntryCounter > cacheCheckThreshold) {\n        dispatcher.getActor().send('enforceCacheSizeLimit', cacheLimit);\n        globalEntryCounter = 0;\n    }\n}\n\n// runs on worker, see above comment\nexport function enforceCacheSizeLimit(limit: number) {\n    if (!window.caches) return;\n    window.caches.open(CACHE_NAME)\n        .then(cache => {\n            cache.keys().then(keys => {\n                for (let i = 0; i < keys.length - limit; i++) {\n                    cache.delete(keys[i]);\n                }\n            });\n        });\n}\n\nexport function clearTileCache(callback?: (err: ?Error) => void) {\n    const promise = window.caches.delete(CACHE_NAME);\n    if (callback) {\n        promise.catch(callback).then(() => callback());\n    }\n}\n\nexport function setCacheLimits(limit: number, checkThreshold: number) {\n    cacheLimit = limit;\n    cacheCheckThreshold = checkThreshold;\n}\n","\nimport refProperties from './util/ref_properties';\n\nfunction stringify(obj) {\n    const type = typeof obj;\n    if (type === 'number' || type === 'boolean' || type === 'string' || obj === undefined || obj === null)\n        return JSON.stringify(obj);\n\n    if (Array.isArray(obj)) {\n        let str = '[';\n        for (const val of obj) {\n            str += `${stringify(val)},`;\n        }\n        return `${str}]`;\n    }\n\n    const keys = Object.keys(obj).sort();\n\n    let str = '{';\n    for (let i = 0; i < keys.length; i++) {\n        str += `${JSON.stringify(keys[i])}:${stringify(obj[keys[i]])},`;\n    }\n    return `${str}}`;\n}\n\nfunction getKey(layer) {\n    let key = '';\n    for (const k of refProperties) {\n        key += `/${stringify(layer[k])}`;\n    }\n    return key;\n}\n\nexport default groupByLayout;\n\n/**\n * Given an array of layers, return an array of arrays of layers where all\n * layers in each group have identical layout-affecting properties. These\n * are the properties that were formerly used by explicit `ref` mechanism\n * for layers: 'type', 'source', 'source-layer', 'minzoom', 'maxzoom',\n * 'filter', and 'layout'.\n *\n * The input is not modified. The output layers are references to the\n * input layers.\n *\n * @private\n * @param {Array<Layer>} layers\n * @param {Object} [cachedKeys] - an object to keep already calculated keys.\n * @returns {Array<Array<Layer>>}\n */\nfunction groupByLayout(layers, cachedKeys) {\n    const groups = {};\n\n    for (let i = 0; i < layers.length; i++) {\n\n        const k = (cachedKeys && cachedKeys[layers[i].id]) || getKey(layers[i]);\n        // update the cache if there is one\n        if (cachedKeys)\n            cachedKeys[layers[i].id] = k;\n\n        let group = groups[k];\n        if (!group) {\n            group = groups[k] = [];\n        }\n        group.push(layers[i]);\n    }\n\n    const result = [];\n\n    for (const k in groups) {\n        result.push(groups[k]);\n    }\n\n    return result;\n}\n","// @flow\n\nimport StyleLayer from './style_layer';\nimport createStyleLayer from './create_style_layer';\n\nimport {values} from '../util/util';\nimport featureFilter from '../style-spec/feature_filter';\nimport groupByLayout from '../style-spec/group_by_layout';\n\nimport type {TypedStyleLayer} from './style_layer/typed_style_layer';\nimport type {LayerSpecification} from '../style-spec/types';\n\nexport type LayerConfigs = { [string]: LayerSpecification };\nexport type Family<Layer: TypedStyleLayer> = Array<Layer>;\n\nclass StyleLayerIndex {\n    familiesBySource: { [source: string]: { [sourceLayer: string]: Array<Family<*>> } };\n    keyCache: { [source: string]: string };\n\n    _layerConfigs: LayerConfigs;\n    _layers: { [string]: StyleLayer };\n\n    constructor(layerConfigs: ?Array<LayerSpecification>) {\n        this.keyCache = {};\n        if (layerConfigs) {\n            this.replace(layerConfigs);\n        }\n    }\n\n    replace(layerConfigs: Array<LayerSpecification>) {\n        this._layerConfigs = {};\n        this._layers = {};\n        this.update(layerConfigs, []);\n    }\n\n    update(layerConfigs: Array<LayerSpecification>, removedIds: Array<string>) {\n        for (const layerConfig of layerConfigs) {\n            this._layerConfigs[layerConfig.id] = layerConfig;\n\n            const layer = this._layers[layerConfig.id] = createStyleLayer(layerConfig);\n            layer._featureFilter = featureFilter(layer.filter);\n            if (this.keyCache[layerConfig.id])\n                delete this.keyCache[layerConfig.id];\n        }\n        for (const id of removedIds) {\n            delete this.keyCache[id];\n            delete this._layerConfigs[id];\n            delete this._layers[id];\n        }\n\n        this.familiesBySource = {};\n\n        const groups = groupByLayout(values(this._layerConfigs), this.keyCache);\n\n        for (const layerConfigs of groups) {\n            const layers = layerConfigs.map((layerConfig) => this._layers[layerConfig.id]);\n\n            const layer = layers[0];\n            if (layer.visibility === 'none') {\n                continue;\n            }\n\n            const sourceId = layer.source || '';\n            let sourceGroup = this.familiesBySource[sourceId];\n            if (!sourceGroup) {\n                sourceGroup = this.familiesBySource[sourceId] = {};\n            }\n\n            const sourceLayerId = layer.sourceLayer || '_geojsonTileLayer';\n            let sourceLayerFamilies = sourceGroup[sourceLayerId];\n            if (!sourceLayerFamilies) {\n                sourceLayerFamilies = sourceGroup[sourceLayerId] = [];\n            }\n\n            sourceLayerFamilies.push(layers);\n        }\n    }\n}\n\nexport default StyleLayerIndex;\n","// @flow\n\nimport {AlphaImage} from '../util/image';\nimport {register} from '../util/web_worker_transfer';\nimport potpack from 'potpack';\n\nimport type {GlyphMetrics, StyleGlyph} from '../style/style_glyph';\n\nconst padding = 1;\n\ntype Rect = {\n    x: number,\n    y: number,\n    w: number,\n    h: number\n};\n\nexport type GlyphPosition = {\n    rect: Rect,\n    metrics: GlyphMetrics\n};\n\nexport type GlyphPositions = { [string]: { [number]: GlyphPosition } }\n\nexport default class GlyphAtlas {\n    image: AlphaImage;\n    positions: GlyphPositions;\n\n    constructor(stacks: { [string]: { [number]: ?StyleGlyph } }) {\n        const positions = {};\n        const bins = [];\n\n        for (const stack in stacks) {\n            const glyphs = stacks[stack];\n            const stackPositions = positions[stack] = {};\n\n            for (const id in glyphs) {\n                const src = glyphs[+id];\n                if (!src || src.bitmap.width === 0 || src.bitmap.height === 0) continue;\n\n                const bin = {\n                    x: 0,\n                    y: 0,\n                    w: src.bitmap.width + 2 * padding,\n                    h: src.bitmap.height + 2 * padding\n                };\n                bins.push(bin);\n                stackPositions[id] = {rect: bin, metrics: src.metrics};\n            }\n        }\n\n        const {w, h} = potpack(bins);\n        const image = new AlphaImage({width: w || 1, height: h || 1});\n\n        for (const stack in stacks) {\n            const glyphs = stacks[stack];\n\n            for (const id in glyphs) {\n                const src = glyphs[+id];\n                if (!src || src.bitmap.width === 0 || src.bitmap.height === 0) continue;\n                const bin = positions[stack][id].rect;\n                AlphaImage.copy(src.bitmap, image, {x: 0, y: 0}, {x: bin.x + padding, y: bin.y + padding}, src.bitmap);\n            }\n        }\n\n        this.image = image;\n        this.positions = positions;\n    }\n}\n\nregister('GlyphAtlas', GlyphAtlas);\n","// @flow\n\nimport FeatureIndex from '../data/feature_index';\n\nimport {performSymbolLayout} from '../symbol/symbol_layout';\nimport {CollisionBoxArray} from '../data/array_types';\nimport DictionaryCoder from '../util/dictionary_coder';\nimport SymbolBucket from '../data/bucket/symbol_bucket';\nimport LineBucket from '../data/bucket/line_bucket';\nimport FillBucket from '../data/bucket/fill_bucket';\nimport FillExtrusionBucket from '../data/bucket/fill_extrusion_bucket';\nimport {warnOnce, mapObject, values} from '../util/util';\nimport assert from 'assert';\nimport ImageAtlas from '../render/image_atlas';\nimport GlyphAtlas from '../render/glyph_atlas';\nimport EvaluationParameters from '../style/evaluation_parameters';\nimport {OverscaledTileID} from './tile_id';\n\nimport type {Bucket} from '../data/bucket';\nimport type Actor from '../util/actor';\nimport type StyleLayer from '../style/style_layer';\nimport type StyleLayerIndex from '../style/style_layer_index';\nimport type {StyleImage} from '../style/style_image';\nimport type {StyleGlyph} from '../style/style_glyph';\nimport type {\n    WorkerTileParameters,\n    WorkerTileCallback,\n} from '../source/worker_source';\n\nclass WorkerTile {\n    tileID: OverscaledTileID;\n    uid: string;\n    zoom: number;\n    pixelRatio: number;\n    tileSize: number;\n    source: string;\n    overscaling: number;\n    showCollisionBoxes: boolean;\n    collectResourceTiming: boolean;\n    returnDependencies: boolean;\n\n    status: 'parsing' | 'done';\n    data: VectorTile;\n    collisionBoxArray: CollisionBoxArray;\n\n    abort: ?() => void;\n    reloadCallback: WorkerTileCallback;\n    vectorTile: VectorTile;\n\n    constructor(params: WorkerTileParameters) {\n        this.tileID = new OverscaledTileID(params.tileID.overscaledZ, params.tileID.wrap, params.tileID.canonical.z, params.tileID.canonical.x, params.tileID.canonical.y);\n        this.uid = params.uid;\n        this.zoom = params.zoom;\n        this.pixelRatio = params.pixelRatio;\n        this.tileSize = params.tileSize;\n        this.source = params.source;\n        this.overscaling = this.tileID.overscaleFactor();\n        this.showCollisionBoxes = params.showCollisionBoxes;\n        this.collectResourceTiming = !!params.collectResourceTiming;\n        this.returnDependencies = !!params.returnDependencies;\n    }\n\n    parse(data: VectorTile, layerIndex: StyleLayerIndex, availableImages: Array<string>, actor: Actor, callback: WorkerTileCallback) {\n        this.status = 'parsing';\n        this.data = data;\n\n        this.collisionBoxArray = new CollisionBoxArray();\n        const sourceLayerCoder = new DictionaryCoder(Object.keys(data.layers).sort());\n\n        const featureIndex = new FeatureIndex(this.tileID);\n        featureIndex.bucketLayerIDs = [];\n\n        const buckets: {[string]: Bucket} = {};\n\n        const options = {\n            featureIndex,\n            iconDependencies: {},\n            patternDependencies: {},\n            glyphDependencies: {},\n            availableImages\n        };\n\n        const layerFamilies = layerIndex.familiesBySource[this.source];\n        for (const sourceLayerId in layerFamilies) {\n            const sourceLayer = data.layers[sourceLayerId];\n            if (!sourceLayer) {\n                continue;\n            }\n\n            if (sourceLayer.version === 1) {\n                warnOnce(`Vector tile source \"${this.source}\" layer \"${sourceLayerId}\" ` +\n                    `does not use vector tile spec v2 and therefore may have some rendering errors.`);\n            }\n\n            const sourceLayerIndex = sourceLayerCoder.encode(sourceLayerId);\n            const features = [];\n            for (let index = 0; index < sourceLayer.length; index++) {\n                const feature = sourceLayer.feature(index);\n                features.push({feature, index, sourceLayerIndex});\n            }\n\n            for (const family of layerFamilies[sourceLayerId]) {\n                const layer = family[0];\n\n                assert(layer.source === this.source);\n                if (layer.minzoom && this.zoom < Math.floor(layer.minzoom)) continue;\n                if (layer.maxzoom && this.zoom >= layer.maxzoom) continue;\n                if (layer.visibility === 'none') continue;\n\n                recalculateLayers(family, this.zoom, availableImages);\n\n                const bucket = buckets[layer.id] = layer.createBucket({\n                    index: featureIndex.bucketLayerIDs.length,\n                    layers: family,\n                    zoom: this.zoom,\n                    pixelRatio: this.pixelRatio,\n                    overscaling: this.overscaling,\n                    collisionBoxArray: this.collisionBoxArray,\n                    sourceLayerIndex,\n                    sourceID: this.source\n                });\n\n                bucket.populate(features, options);\n                featureIndex.bucketLayerIDs.push(family.map((l) => l.id));\n            }\n        }\n\n        let error: ?Error;\n        let glyphMap: ?{[string]: {[number]: ?StyleGlyph}};\n        let iconMap: ?{[string]: StyleImage};\n        let patternMap: ?{[string]: StyleImage};\n\n        const stacks = mapObject(options.glyphDependencies, (glyphs) => Object.keys(glyphs).map(Number));\n        if (Object.keys(stacks).length) {\n            actor.send('getGlyphs', {uid: this.uid, stacks}, (err, result) => {\n                if (!error) {\n                    error = err;\n                    glyphMap = result;\n                    maybePrepare.call(this);\n                }\n            });\n        } else {\n            glyphMap = {};\n        }\n\n        const icons = Object.keys(options.iconDependencies);\n        if (icons.length) {\n            actor.send('getImages', {icons}, (err, result) => {\n                if (!error) {\n                    error = err;\n                    iconMap = result;\n                    maybePrepare.call(this);\n                }\n            });\n        } else {\n            iconMap = {};\n        }\n\n        const patterns = Object.keys(options.patternDependencies);\n        if (patterns.length) {\n            actor.send('getImages', {icons: patterns}, (err, result) => {\n                if (!error) {\n                    error = err;\n                    patternMap = result;\n                    maybePrepare.call(this);\n                }\n            });\n        } else {\n            patternMap = {};\n        }\n\n        maybePrepare.call(this);\n\n        function maybePrepare() {\n            if (error) {\n                return callback(error);\n            } else if (glyphMap && iconMap && patternMap) {\n                const glyphAtlas = new GlyphAtlas(glyphMap);\n                const imageAtlas = new ImageAtlas(iconMap, patternMap);\n\n                for (const key in buckets) {\n                    const bucket = buckets[key];\n                    if (bucket instanceof SymbolBucket) {\n                        recalculateLayers(bucket.layers, this.zoom, availableImages);\n                        performSymbolLayout(bucket, glyphMap, glyphAtlas.positions, iconMap, imageAtlas.iconPositions, this.showCollisionBoxes);\n                    } else if (bucket.hasPattern &&\n                        (bucket instanceof LineBucket ||\n                         bucket instanceof FillBucket ||\n                         bucket instanceof FillExtrusionBucket)) {\n                        recalculateLayers(bucket.layers, this.zoom, availableImages);\n                        bucket.addFeatures(options, imageAtlas.patternPositions);\n                    }\n                }\n\n                this.status = 'done';\n                callback(null, {\n                    buckets: values(buckets).filter(b => !b.isEmpty()),\n                    featureIndex,\n                    collisionBoxArray: this.collisionBoxArray,\n                    glyphAtlasImage: glyphAtlas.image,\n                    imageAtlas,\n                    // Only used for benchmarking:\n                    glyphMap: this.returnDependencies ? glyphMap : null,\n                    iconMap: this.returnDependencies ? iconMap : null,\n                    glyphPositions: this.returnDependencies ? glyphAtlas.positions : null\n                });\n            }\n        }\n    }\n}\n\nfunction recalculateLayers(layers: $ReadOnlyArray<StyleLayer>, zoom: number, availableImages: Array<string>) {\n    // Layers are shared and may have been used by a WorkerTile with a different zoom.\n    const parameters = new EvaluationParameters(zoom);\n    for (const layer of layers) {\n        layer.recalculate(parameters, availableImages);\n    }\n}\n\nexport default WorkerTile;\n","// @flow\n\nimport type {RequestParameters} from '../util/ajax';\n\n// Wraps performance to facilitate testing\n// Not incorporated into browser.js because the latter is poisonous when used outside the main thread\nconst performanceExists = typeof performance !== 'undefined';\nconst wrapper = {};\n\nwrapper.getEntriesByName = (url: string) => {\n    if (performanceExists && performance && performance.getEntriesByName)\n        return performance.getEntriesByName(url);\n    else\n        return false;\n};\n\nwrapper.mark = (name: string) => {\n    if (performanceExists && performance && performance.mark)\n        return performance.mark(name);\n    else\n        return false;\n};\n\nwrapper.measure = (name: string, startMark: string, endMark: string) => {\n    if (performanceExists && performance && performance.measure)\n        return performance.measure(name, startMark, endMark);\n    else\n        return false;\n};\n\nwrapper.clearMarks = (name: string) => {\n    if (performanceExists && performance && performance.clearMarks)\n        return performance.clearMarks(name);\n    else\n        return false;\n};\n\nwrapper.clearMeasures = (name: string) => {\n    if (performanceExists && performance && performance.clearMeasures)\n        return performance.clearMeasures(name);\n    else\n        return false;\n};\n\n/**\n * Safe wrapper for the performance resource timing API in web workers with graceful degradation\n *\n * @param {RequestParameters} request\n * @private\n */\nclass Performance {\n    _marks: {start: string, end: string, measure: string};\n\n    constructor (request: RequestParameters) {\n        this._marks = {\n            start: [request.url, 'start'].join('#'),\n            end: [request.url, 'end'].join('#'),\n            measure: request.url.toString()\n        };\n\n        wrapper.mark(this._marks.start);\n    }\n\n    finish() {\n        wrapper.mark(this._marks.end);\n        let resourceTimingData = wrapper.getEntriesByName(this._marks.measure);\n\n        // fallback if web worker implementation of perf.getEntriesByName returns empty\n        if (resourceTimingData.length === 0) {\n            wrapper.measure(this._marks.measure, this._marks.start, this._marks.end);\n            resourceTimingData = wrapper.getEntriesByName(this._marks.measure);\n\n            // cleanup\n            wrapper.clearMarks(this._marks.start);\n            wrapper.clearMarks(this._marks.end);\n            wrapper.clearMeasures(this._marks.measure);\n        }\n\n        return resourceTimingData;\n    }\n}\n\nwrapper.Performance = Performance;\n\nexport default wrapper;\n","// @flow\n\nimport {getArrayBuffer} from '../util/ajax';\n\nimport vt from '@mapbox/vector-tile';\nimport Protobuf from 'pbf';\nimport WorkerTile from './worker_tile';\nimport {extend} from '../util/util';\nimport performance from '../util/performance';\n\nimport type {\n    WorkerSource,\n    WorkerTileParameters,\n    WorkerTileCallback,\n    TileParameters\n} from '../source/worker_source';\n\nimport type Actor from '../util/actor';\nimport type StyleLayerIndex from '../style/style_layer_index';\nimport type {Callback} from '../types/callback';\n\nexport type LoadVectorTileResult = {\n    vectorTile: VectorTile;\n    rawData: ArrayBuffer;\n    expires?: any;\n    cacheControl?: any;\n    resourceTiming?: Array<PerformanceResourceTiming>;\n};\n\n/**\n * @callback LoadVectorDataCallback\n * @param error\n * @param vectorTile\n * @private\n */\nexport type LoadVectorDataCallback = Callback<?LoadVectorTileResult>;\n\nexport type AbortVectorData = () => void;\nexport type LoadVectorData = (params: WorkerTileParameters, callback: LoadVectorDataCallback) => ?AbortVectorData;\n\n/**\n * @private\n */\nfunction loadVectorTile(params: WorkerTileParameters, callback: LoadVectorDataCallback) {\n    const request = getArrayBuffer(params.request, (err: ?Error, data: ?ArrayBuffer, cacheControl: ?string, expires: ?string) => {\n        if (err) {\n            callback(err);\n        } else if (data) {\n            callback(null, {\n                vectorTile: new vt.VectorTile(new Protobuf(data)),\n                rawData: data,\n                cacheControl,\n                expires\n            });\n        }\n    });\n    return () => {\n        request.cancel();\n        callback();\n    };\n}\n\n/**\n * The {@link WorkerSource} implementation that supports {@link VectorTileSource}.\n * This class is designed to be easily reused to support custom source types\n * for data formats that can be parsed/converted into an in-memory VectorTile\n * representation.  To do so, create it with\n * `new VectorTileWorkerSource(actor, styleLayers, customLoadVectorDataFunction)`.\n *\n * @private\n */\nclass VectorTileWorkerSource implements WorkerSource {\n    actor: Actor;\n    layerIndex: StyleLayerIndex;\n    availableImages: Array<string>;\n    loadVectorData: LoadVectorData;\n    loading: { [string]: WorkerTile };\n    loaded: { [string]: WorkerTile };\n\n    /**\n     * @param [loadVectorData] Optional method for custom loading of a VectorTile\n     * object based on parameters passed from the main-thread Source. See\n     * {@link VectorTileWorkerSource#loadTile}. The default implementation simply\n     * loads the pbf at `params.url`.\n     */\n    constructor(actor: Actor, layerIndex: StyleLayerIndex, availableImages: Array<string>, loadVectorData: ?LoadVectorData) {\n        this.actor = actor;\n        this.layerIndex = layerIndex;\n        this.availableImages = availableImages;\n        this.loadVectorData = loadVectorData || loadVectorTile;\n        this.loading = {};\n        this.loaded = {};\n    }\n\n    /**\n     * Implements {@link WorkerSource#loadTile}. Delegates to\n     * {@link VectorTileWorkerSource#loadVectorData} (which by default expects\n     * a `params.url` property) for fetching and producing a VectorTile object.\n     */\n    loadTile(params: WorkerTileParameters, callback: WorkerTileCallback) {\n        const uid = params.uid;\n\n        if (!this.loading)\n            this.loading = {};\n\n        const perf = (params && params.request && params.request.collectResourceTiming) ?\n            new performance.Performance(params.request) : false;\n\n        const workerTile = this.loading[uid] = new WorkerTile(params);\n        workerTile.abort = this.loadVectorData(params, (err, response) => {\n            delete this.loading[uid];\n\n            if (err || !response) {\n                workerTile.status = 'done';\n                this.loaded[uid] = workerTile;\n                return callback(err);\n            }\n\n            const rawTileData = response.rawData;\n            const cacheControl = {};\n            if (response.expires) cacheControl.expires = response.expires;\n            if (response.cacheControl) cacheControl.cacheControl = response.cacheControl;\n\n            const resourceTiming = {};\n            if (perf) {\n                const resourceTimingData = perf.finish();\n                // it's necessary to eval the result of getEntriesByName() here via parse/stringify\n                // late evaluation in the main thread causes TypeError: illegal invocation\n                if (resourceTimingData)\n                    resourceTiming.resourceTiming = JSON.parse(JSON.stringify(resourceTimingData));\n            }\n\n            workerTile.vectorTile = response.vectorTile;\n            workerTile.parse(response.vectorTile, this.layerIndex, this.availableImages, this.actor, (err, result) => {\n                if (err || !result) return callback(err);\n\n                // Transferring a copy of rawTileData because the worker needs to retain its copy.\n                callback(null, extend({rawTileData: rawTileData.slice(0)}, result, cacheControl, resourceTiming));\n            });\n\n            this.loaded = this.loaded || {};\n            this.loaded[uid] = workerTile;\n        });\n    }\n\n    /**\n     * Implements {@link WorkerSource#reloadTile}.\n     */\n    reloadTile(params: WorkerTileParameters, callback: WorkerTileCallback) {\n        const loaded = this.loaded,\n            uid = params.uid,\n            vtSource = this;\n        if (loaded && loaded[uid]) {\n            const workerTile = loaded[uid];\n            workerTile.showCollisionBoxes = params.showCollisionBoxes;\n\n            const done = (err, data) => {\n                const reloadCallback = workerTile.reloadCallback;\n                if (reloadCallback) {\n                    delete workerTile.reloadCallback;\n                    workerTile.parse(workerTile.vectorTile, vtSource.layerIndex, this.availableImages, vtSource.actor, reloadCallback);\n                }\n                callback(err, data);\n            };\n\n            if (workerTile.status === 'parsing') {\n                workerTile.reloadCallback = done;\n            } else if (workerTile.status === 'done') {\n                // if there was no vector tile data on the initial load, don't try and re-parse tile\n                if (workerTile.vectorTile) {\n                    workerTile.parse(workerTile.vectorTile, this.layerIndex, this.availableImages, this.actor, done);\n                } else {\n                    done();\n                }\n            }\n        }\n    }\n\n    /**\n     * Implements {@link WorkerSource#abortTile}.\n     *\n     * @param params\n     * @param params.uid The UID for this tile.\n     */\n    abortTile(params: TileParameters, callback: WorkerTileCallback) {\n        const loading = this.loading,\n            uid = params.uid;\n        if (loading && loading[uid] && loading[uid].abort) {\n            loading[uid].abort();\n            delete loading[uid];\n        }\n        callback();\n    }\n\n    /**\n     * Implements {@link WorkerSource#removeTile}.\n     *\n     * @param params\n     * @param params.uid The UID for this tile.\n     */\n    removeTile(params: TileParameters, callback: WorkerTileCallback) {\n        const loaded = this.loaded,\n            uid = params.uid;\n        if (loaded && loaded[uid]) {\n            delete loaded[uid];\n        }\n        callback();\n    }\n}\n\nexport default VectorTileWorkerSource;\n","// @flow\n\nimport DEMData from '../data/dem_data';\n\nimport type Actor from '../util/actor';\nimport type {\n    WorkerDEMTileParameters,\n    WorkerDEMTileCallback,\n    TileParameters\n} from './worker_source';\n\nclass RasterDEMTileWorkerSource {\n    actor: Actor;\n    loaded: {[string]: DEMData};\n\n    constructor() {\n        this.loaded = {};\n    }\n\n    loadTile(params: WorkerDEMTileParameters, callback: WorkerDEMTileCallback) {\n        const {uid, encoding, rawImageData} = params;\n        const dem = new DEMData(uid, rawImageData, encoding);\n\n        this.loaded = this.loaded || {};\n        this.loaded[uid] = dem;\n        callback(null, dem);\n    }\n\n    removeTile(params: TileParameters) {\n        const loaded = this.loaded,\n            uid = params.uid;\n        if (loaded && loaded[uid]) {\n            delete loaded[uid];\n        }\n    }\n}\n\nexport default RasterDEMTileWorkerSource;\n","module.exports.RADIUS = 6378137;\nmodule.exports.FLATTENING = 1/298.257223563;\nmodule.exports.POLAR_RADIUS = 6356752.3142;\n","var wgs84 = require('wgs84');\n\nmodule.exports.geometry = geometry;\nmodule.exports.ring = ringArea;\n\nfunction geometry(_) {\n    var area = 0, i;\n    switch (_.type) {\n        case 'Polygon':\n            return polygonArea(_.coordinates);\n        case 'MultiPolygon':\n            for (i = 0; i < _.coordinates.length; i++) {\n                area += polygonArea(_.coordinates[i]);\n            }\n            return area;\n        case 'Point':\n        case 'MultiPoint':\n        case 'LineString':\n        case 'MultiLineString':\n            return 0;\n        case 'GeometryCollection':\n            for (i = 0; i < _.geometries.length; i++) {\n                area += geometry(_.geometries[i]);\n            }\n            return area;\n    }\n}\n\nfunction polygonArea(coords) {\n    var area = 0;\n    if (coords && coords.length > 0) {\n        area += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            area -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return area;\n}\n\n/**\n * Calculate the approximate area of the polygon were it projected onto\n *     the earth.  Note that this area will be positive if ring is oriented\n *     clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n *     Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * Returns:\n * {float} The approximate signed geodesic area of the polygon in square\n *     meters.\n */\n\nfunction ringArea(coords) {\n    var p1, p2, p3, lowerIndex, middleIndex, upperIndex, i,\n    area = 0,\n    coordsLength = coords.length;\n\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {// i = N-2\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength -1;\n                upperIndex = 0;\n            } else if (i === coordsLength - 1) {// i = N-1\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            } else { // i = 0 to N-3\n                lowerIndex = i;\n                middleIndex = i+1;\n                upperIndex = i+2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            area += ( rad(p3[0]) - rad(p1[0]) ) * Math.sin( rad(p2[1]));\n        }\n\n        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;\n    }\n\n    return area;\n}\n\nfunction rad(_) {\n    return _ * Math.PI / 180;\n}","var geojsonArea = require('@mapbox/geojson-area');\n\nmodule.exports = rewind;\n\nfunction rewind(gj, outer) {\n    switch ((gj && gj.type) || null) {\n        case 'FeatureCollection':\n            gj.features = gj.features.map(curryOuter(rewind, outer));\n            return gj;\n        case 'GeometryCollection':\n            gj.geometries = gj.geometries.map(curryOuter(rewind, outer));\n            return gj;\n        case 'Feature':\n            gj.geometry = rewind(gj.geometry, outer);\n            return gj;\n        case 'Polygon':\n        case 'MultiPolygon':\n            return correct(gj, outer);\n        default:\n            return gj;\n    }\n}\n\nfunction curryOuter(a, b) {\n    return function(_) { return a(_, b); };\n}\n\nfunction correct(_, outer) {\n    if (_.type === 'Polygon') {\n        _.coordinates = correctRings(_.coordinates, outer);\n    } else if (_.type === 'MultiPolygon') {\n        _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));\n    }\n    return _;\n}\n\nfunction correctRings(_, outer) {\n    outer = !!outer;\n    _[0] = wind(_[0], outer);\n    for (var i = 1; i < _.length; i++) {\n        _[i] = wind(_[i], !outer);\n    }\n    return _;\n}\n\nfunction wind(_, dir) {\n    return cw(_) === dir ? _ : _.reverse();\n}\n\nfunction cw(_) {\n    return geojsonArea.ring(_) >= 0;\n}\n","// @flow\n\nimport Point from '@mapbox/point-geometry';\n\nimport mvt from '@mapbox/vector-tile';\nconst toGeoJSON = mvt.VectorTileFeature.prototype.toGeoJSON;\nimport EXTENT from '../data/extent';\n\n// The feature type used by geojson-vt and supercluster. Should be extracted to\n// global type and used in module definitions for those two modules.\ntype Feature = {\n    type: 1,\n    id: mixed,\n    tags: {[string]: string | number | boolean},\n    geometry: Array<[number, number]>,\n} | {\n    type: 2 | 3,\n    id: mixed,\n    tags: {[string]: string | number | boolean},\n    geometry: Array<Array<[number, number]>>,\n}\n\nclass FeatureWrapper implements VectorTileFeature {\n    _feature: Feature;\n\n    extent: number;\n    type: 1 | 2 | 3;\n    id: number;\n    properties: {[string]: string | number | boolean};\n\n    constructor(feature: Feature) {\n        this._feature = feature;\n\n        this.extent = EXTENT;\n        this.type = feature.type;\n        this.properties = feature.tags;\n\n        // If the feature has a top-level `id` property, copy it over, but only\n        // if it can be coerced to an integer, because this wrapper is used for\n        // serializing geojson feature data into vector tile PBF data, and the\n        // vector tile spec only supports integer values for feature ids --\n        // allowing non-integer values here results in a non-compliant PBF\n        // that causes an exception when it is parsed with vector-tile-js\n        if ('id' in feature && !isNaN(feature.id)) {\n            this.id = parseInt(feature.id, 10);\n        }\n    }\n\n    loadGeometry() {\n        if (this._feature.type === 1) {\n            const geometry = [];\n            for (const point of this._feature.geometry) {\n                geometry.push([new Point(point[0], point[1])]);\n            }\n            return geometry;\n        } else {\n            const geometry = [];\n            for (const ring of this._feature.geometry) {\n                const newRing = [];\n                for (const point of ring) {\n                    newRing.push(new Point(point[0], point[1]));\n                }\n                geometry.push(newRing);\n            }\n            return geometry;\n        }\n    }\n\n    toGeoJSON(x: number, y: number, z: number) {\n        return toGeoJSON.call(this, x, y, z);\n    }\n}\n\nclass GeoJSONWrapper implements VectorTile, VectorTileLayer {\n    layers: {[string]: VectorTileLayer};\n    name: string;\n    extent: number;\n    length: number;\n    _features: Array<Feature>;\n\n    constructor(features: Array<Feature>) {\n        this.layers = {'_geojsonTileLayer': this};\n        this.name = '_geojsonTileLayer';\n        this.extent = EXTENT;\n        this.length = features.length;\n        this._features = features;\n    }\n\n    feature(i: number): VectorTileFeature {\n        return new FeatureWrapper(this._features[i]);\n    }\n}\n\nexport default GeoJSONWrapper;\n","'use strict'\n\nvar Point = require('@mapbox/point-geometry')\nvar VectorTileFeature = require('@mapbox/vector-tile').VectorTileFeature\n\nmodule.exports = GeoJSONWrapper\n\n// conform to vectortile api\nfunction GeoJSONWrapper (features, options) {\n  this.options = options || {}\n  this.features = features\n  this.length = features.length\n}\n\nGeoJSONWrapper.prototype.feature = function (i) {\n  return new FeatureWrapper(this.features[i], this.options.extent)\n}\n\nfunction FeatureWrapper (feature, extent) {\n  this.id = typeof feature.id === 'number' ? feature.id : undefined\n  this.type = feature.type\n  this.rawGeometry = feature.type === 1 ? [feature.geometry] : feature.geometry\n  this.properties = feature.tags\n  this.extent = extent || 4096\n}\n\nFeatureWrapper.prototype.loadGeometry = function () {\n  var rings = this.rawGeometry\n  this.geometry = []\n\n  for (var i = 0; i < rings.length; i++) {\n    var ring = rings[i]\n    var newRing = []\n    for (var j = 0; j < ring.length; j++) {\n      newRing.push(new Point(ring[j][0], ring[j][1]))\n    }\n    this.geometry.push(newRing)\n  }\n  return this.geometry\n}\n\nFeatureWrapper.prototype.bbox = function () {\n  if (!this.geometry) this.loadGeometry()\n\n  var rings = this.geometry\n  var x1 = Infinity\n  var x2 = -Infinity\n  var y1 = Infinity\n  var y2 = -Infinity\n\n  for (var i = 0; i < rings.length; i++) {\n    var ring = rings[i]\n\n    for (var j = 0; j < ring.length; j++) {\n      var coord = ring[j]\n\n      x1 = Math.min(x1, coord.x)\n      x2 = Math.max(x2, coord.x)\n      y1 = Math.min(y1, coord.y)\n      y2 = Math.max(y2, coord.y)\n    }\n  }\n\n  return [x1, y1, x2, y2]\n}\n\nFeatureWrapper.prototype.toGeoJSON = VectorTileFeature.prototype.toGeoJSON\n","var Pbf = require('pbf')\nvar GeoJSONWrapper = require('./lib/geojson_wrapper')\n\nmodule.exports = fromVectorTileJs\nmodule.exports.fromVectorTileJs = fromVectorTileJs\nmodule.exports.fromGeojsonVt = fromGeojsonVt\nmodule.exports.GeoJSONWrapper = GeoJSONWrapper\n\n/**\n * Serialize a vector-tile-js-created tile to pbf\n *\n * @param {Object} tile\n * @return {Buffer} uncompressed, pbf-serialized tile data\n */\nfunction fromVectorTileJs (tile) {\n  var out = new Pbf()\n  writeTile(tile, out)\n  return out.finish()\n}\n\n/**\n * Serialized a geojson-vt-created tile to pbf.\n *\n * @param {Object} layers - An object mapping layer names to geojson-vt-created vector tile objects\n * @param {Object} [options] - An object specifying the vector-tile specification version and extent that were used to create `layers`.\n * @param {Number} [options.version=1] - Version of vector-tile spec used\n * @param {Number} [options.extent=4096] - Extent of the vector tile\n * @return {Buffer} uncompressed, pbf-serialized tile data\n */\nfunction fromGeojsonVt (layers, options) {\n  options = options || {}\n  var l = {}\n  for (var k in layers) {\n    l[k] = new GeoJSONWrapper(layers[k].features, options)\n    l[k].name = k\n    l[k].version = options.version\n    l[k].extent = options.extent\n  }\n  return fromVectorTileJs({layers: l})\n}\n\nfunction writeTile (tile, pbf) {\n  for (var key in tile.layers) {\n    pbf.writeMessage(3, writeLayer, tile.layers[key])\n  }\n}\n\nfunction writeLayer (layer, pbf) {\n  pbf.writeVarintField(15, layer.version || 1)\n  pbf.writeStringField(1, layer.name || '')\n  pbf.writeVarintField(5, layer.extent || 4096)\n\n  var i\n  var context = {\n    keys: [],\n    values: [],\n    keycache: {},\n    valuecache: {}\n  }\n\n  for (i = 0; i < layer.length; i++) {\n    context.feature = layer.feature(i)\n    pbf.writeMessage(2, writeFeature, context)\n  }\n\n  var keys = context.keys\n  for (i = 0; i < keys.length; i++) {\n    pbf.writeStringField(3, keys[i])\n  }\n\n  var values = context.values\n  for (i = 0; i < values.length; i++) {\n    pbf.writeMessage(4, writeValue, values[i])\n  }\n}\n\nfunction writeFeature (context, pbf) {\n  var feature = context.feature\n\n  if (feature.id !== undefined) {\n    pbf.writeVarintField(1, feature.id)\n  }\n\n  pbf.writeMessage(2, writeProperties, context)\n  pbf.writeVarintField(3, feature.type)\n  pbf.writeMessage(4, writeGeometry, feature)\n}\n\nfunction writeProperties (context, pbf) {\n  var feature = context.feature\n  var keys = context.keys\n  var values = context.values\n  var keycache = context.keycache\n  var valuecache = context.valuecache\n\n  for (var key in feature.properties) {\n    var keyIndex = keycache[key]\n    if (typeof keyIndex === 'undefined') {\n      keys.push(key)\n      keyIndex = keys.length - 1\n      keycache[key] = keyIndex\n    }\n    pbf.writeVarint(keyIndex)\n\n    var value = feature.properties[key]\n    var type = typeof value\n    if (type !== 'string' && type !== 'boolean' && type !== 'number') {\n      value = JSON.stringify(value)\n    }\n    var valueKey = type + ':' + value\n    var valueIndex = valuecache[valueKey]\n    if (typeof valueIndex === 'undefined') {\n      values.push(value)\n      valueIndex = values.length - 1\n      valuecache[valueKey] = valueIndex\n    }\n    pbf.writeVarint(valueIndex)\n  }\n}\n\nfunction command (cmd, length) {\n  return (length << 3) + (cmd & 0x7)\n}\n\nfunction zigzag (num) {\n  return (num << 1) ^ (num >> 31)\n}\n\nfunction writeGeometry (feature, pbf) {\n  var geometry = feature.loadGeometry()\n  var type = feature.type\n  var x = 0\n  var y = 0\n  var rings = geometry.length\n  for (var r = 0; r < rings; r++) {\n    var ring = geometry[r]\n    var count = 1\n    if (type === 1) {\n      count = ring.length\n    }\n    pbf.writeVarint(command(1, count)) // moveto\n    // do not write polygon closing path as lineto\n    var lineCount = type === 3 ? ring.length - 1 : ring.length\n    for (var i = 0; i < lineCount; i++) {\n      if (i === 1 && type !== 1) {\n        pbf.writeVarint(command(2, lineCount - 1)) // lineto\n      }\n      var dx = ring[i].x - x\n      var dy = ring[i].y - y\n      pbf.writeVarint(zigzag(dx))\n      pbf.writeVarint(zigzag(dy))\n      x += dx\n      y += dy\n    }\n    if (type === 3) {\n      pbf.writeVarint(command(7, 1)) // closepath\n    }\n  }\n}\n\nfunction writeValue (value, pbf) {\n  var type = typeof value\n  if (type === 'string') {\n    pbf.writeStringField(1, value)\n  } else if (type === 'boolean') {\n    pbf.writeBooleanField(7, value)\n  } else if (type === 'number') {\n    if (value % 1 !== 0) {\n      pbf.writeDoubleField(3, value)\n    } else if (value < 0) {\n      pbf.writeSVarintField(6, value)\n    } else {\n      pbf.writeVarintField(5, value)\n    }\n  }\n}\n","\nexport default function sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) return;\n\n    const m = (left + right) >> 1;\n\n    select(ids, coords, m, left, right, depth % 2);\n\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n}\n\nfunction select(ids, coords, k, left, right, inc) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, inc);\n        }\n\n        const t = coords[2 * k + inc];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + inc] < t) i++;\n            while (coords[2 * j + inc] > t) j--;\n        }\n\n        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n","\nexport default function within(ids, coords, qx, qy, r, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    const r2 = r * r;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        const x = coords[2 * m];\n        const y = coords[2 * m + 1];\n\n        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction sqDist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n","\nimport sort from './sort';\nimport range from './range';\nimport within from './within';\n\nconst defaultGetX = p => p[0];\nconst defaultGetY = p => p[1];\n\nexport default class KDBush {\n    constructor(points, getX = defaultGetX, getY = defaultGetY, nodeSize = 64, ArrayType = Float64Array) {\n        this.nodeSize = nodeSize;\n        this.points = points;\n\n        const IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\n\n        const ids = this.ids = new IndexArrayType(points.length);\n        const coords = this.coords = new ArrayType(points.length * 2);\n\n        for (let i = 0; i < points.length; i++) {\n            ids[i] = i;\n            coords[2 * i] = getX(points[i]);\n            coords[2 * i + 1] = getY(points[i]);\n        }\n\n        sort(ids, coords, nodeSize, 0, ids.length - 1, 0);\n    }\n\n    range(minX, minY, maxX, maxY) {\n        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n    }\n\n    within(x, y, r) {\n        return within(this.ids, this.coords, x, y, r, this.nodeSize);\n    }\n}\n","\nexport default function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    let x, y;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                x = coords[2 * i];\n                y = coords[2 * i + 1];\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        x = coords[2 * m];\n        y = coords[2 * m + 1];\n\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? minX <= x : minY <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? maxX >= x : maxY >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n","\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = extend(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom, nodeSize} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        let clusters = [];\n        for (let i = 0; i < points.length; i++) {\n            if (!points[i].geometry) continue;\n            clusters.push(createPointCluster(points[i], i));\n        }\n        this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            clusters = this._cluster(clusters, z);\n            this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const clusters = [];\n        for (const id of ids) {\n            const c = tree.points[id];\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = clusterId >> 5;\n        const originZoom = clusterId % 32;\n        const errorMsg = 'No cluster with the specified id.';\n\n        const index = this.trees[originZoom];\n        if (!index) throw new Error(errorMsg);\n\n        const origin = index.points[originId];\n        if (!origin) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const ids = index.within(origin.x, origin.y, r);\n        const children = [];\n        for (const id of ids) {\n            const c = index.points[id];\n            if (c.parentId === clusterId) {\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let clusterZoom = (clusterId % 32) - 1;\n        while (clusterZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            clusterZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return clusterZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _addTileFeatures(ids, points, x, y, z2, tile) {\n        for (const i of ids) {\n            const c = points[i];\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (c.x * z2 - x)),\n                    Math.round(this.options.extent * (c.y * z2 - y))\n                ]],\n                tags: c.numPoints ? getClusterProperties(c) : this.points[c.index].properties\n            };\n            const id = c.numPoints ? c.id : this.points[c.index].id;\n            if (id !== undefined) {\n                f.id = id;\n            }\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(z, this.options.maxZoom + 1));\n    }\n\n    _cluster(points, zoom) {\n        const clusters = [];\n        const {radius, extent, reduce} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            const tree = this.trees[zoom + 1];\n            const neighborIds = tree.within(p.x, p.y, r);\n\n            let numPoints = p.numPoints || 1;\n            let wx = p.x * numPoints;\n            let wy = p.y * numPoints;\n\n            let clusterProperties = reduce && numPoints > 1 ? this._map(p, true) : null;\n\n            // encode both zoom and point index on which the cluster originated\n            const id = (i << 5) + (zoom + 1);\n\n            for (const neighborId of neighborIds) {\n                const b = tree.points[neighborId];\n                // filter out neighbors that are already processed\n                if (b.zoom <= zoom) continue;\n                b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                const numPoints2 = b.numPoints || 1;\n                wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n                wy += b.y * numPoints2;\n\n                numPoints += numPoints2;\n                b.parentId = id;\n\n                if (reduce) {\n                    if (!clusterProperties) clusterProperties = this._map(p, true);\n                    reduce(clusterProperties, this._map(b));\n                }\n            }\n\n            if (numPoints === 1) {\n                clusters.push(p);\n            } else {\n                p.parentId = id;\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n            }\n        }\n\n        return clusters;\n    }\n\n    _map(point, clone) {\n        if (point.numPoints) {\n            return clone ? extend({}, point.properties) : point.properties;\n        }\n        const original = this.points[point.index].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? extend({}, result) : result;\n    }\n}\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x, // weighted cluster center\n        y,\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints,\n        properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    const [x, y] = p.geometry.coordinates;\n    return {\n        x: lngX(x), // projected point coordinates\n        y: latY(y),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    const count = cluster.numPoints;\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (const id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n","\n// calculate simplification data using optimized Douglas-Peucker algorithm\n\nexport default function simplify(coords, first, last, sqTolerance) {\n    var maxSqDist = sqTolerance;\n    var mid = (last - first) >> 1;\n    var minPosToMid = last - first;\n    var index;\n\n    var ax = coords[first];\n    var ay = coords[first + 1];\n    var bx = coords[last];\n    var by = coords[last + 1];\n\n    for (var i = first + 3; i < last; i += 3) {\n        var d = getSqSegDist(coords[i], coords[i + 1], ax, ay, bx, by);\n\n        if (d > maxSqDist) {\n            index = i;\n            maxSqDist = d;\n\n        } else if (d === maxSqDist) {\n            // a workaround to ensure we choose a pivot close to the middle of the list,\n            // reducing recursion depth, for certain degenerate inputs\n            // https://github.com/mapbox/geojson-vt/issues/104\n            var posToMid = Math.abs(i - mid);\n            if (posToMid < minPosToMid) {\n                index = i;\n                minPosToMid = posToMid;\n            }\n        }\n    }\n\n    if (maxSqDist > sqTolerance) {\n        if (index - first > 3) simplify(coords, first, index, sqTolerance);\n        coords[index + 2] = maxSqDist;\n        if (last - index > 3) simplify(coords, index, last, sqTolerance);\n    }\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(px, py, x, y, bx, by) {\n\n    var dx = bx - x;\n    var dy = by - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = bx;\n            y = by;\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = px - x;\n    dy = py - y;\n\n    return dx * dx + dy * dy;\n}\n","\nexport default function createFeature(id, type, geom, tags) {\n    var feature = {\n        id: typeof id === 'undefined' ? null : id,\n        type: type,\n        geometry: geom,\n        tags: tags,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n    calcBBox(feature);\n    return feature;\n}\n\nfunction calcBBox(feature) {\n    var geom = feature.geometry;\n    var type = feature.type;\n\n    if (type === 'Point' || type === 'MultiPoint' || type === 'LineString') {\n        calcLineBBox(feature, geom);\n\n    } else if (type === 'Polygon' || type === 'MultiLineString') {\n        for (var i = 0; i < geom.length; i++) {\n            calcLineBBox(feature, geom[i]);\n        }\n\n    } else if (type === 'MultiPolygon') {\n        for (i = 0; i < geom.length; i++) {\n            for (var j = 0; j < geom[i].length; j++) {\n                calcLineBBox(feature, geom[i][j]);\n            }\n        }\n    }\n}\n\nfunction calcLineBBox(feature, geom) {\n    for (var i = 0; i < geom.length; i += 3) {\n        feature.minX = Math.min(feature.minX, geom[i]);\n        feature.minY = Math.min(feature.minY, geom[i + 1]);\n        feature.maxX = Math.max(feature.maxX, geom[i]);\n        feature.maxY = Math.max(feature.maxY, geom[i + 1]);\n    }\n}\n","\nimport simplify from './simplify';\nimport createFeature from './feature';\n\n// converts GeoJSON feature into an intermediate projected JSON vector format with simplification data\n\nexport default function convert(data, options) {\n    var features = [];\n    if (data.type === 'FeatureCollection') {\n        for (var i = 0; i < data.features.length; i++) {\n            convertFeature(features, data.features[i], options, i);\n        }\n\n    } else if (data.type === 'Feature') {\n        convertFeature(features, data, options);\n\n    } else {\n        // single geometry or a geometry collection\n        convertFeature(features, {geometry: data}, options);\n    }\n\n    return features;\n}\n\nfunction convertFeature(features, geojson, options, index) {\n    if (!geojson.geometry) return;\n\n    var coords = geojson.geometry.coordinates;\n    var type = geojson.geometry.type;\n    var tolerance = Math.pow(options.tolerance / ((1 << options.maxZoom) * options.extent), 2);\n    var geometry = [];\n    var id = geojson.id;\n    if (options.promoteId) {\n        id = geojson.properties[options.promoteId];\n    } else if (options.generateId) {\n        id = index || 0;\n    }\n    if (type === 'Point') {\n        convertPoint(coords, geometry);\n\n    } else if (type === 'MultiPoint') {\n        for (var i = 0; i < coords.length; i++) {\n            convertPoint(coords[i], geometry);\n        }\n\n    } else if (type === 'LineString') {\n        convertLine(coords, geometry, tolerance, false);\n\n    } else if (type === 'MultiLineString') {\n        if (options.lineMetrics) {\n            // explode into linestrings to be able to track metrics\n            for (i = 0; i < coords.length; i++) {\n                geometry = [];\n                convertLine(coords[i], geometry, tolerance, false);\n                features.push(createFeature(id, 'LineString', geometry, geojson.properties));\n            }\n            return;\n        } else {\n            convertLines(coords, geometry, tolerance, false);\n        }\n\n    } else if (type === 'Polygon') {\n        convertLines(coords, geometry, tolerance, true);\n\n    } else if (type === 'MultiPolygon') {\n        for (i = 0; i < coords.length; i++) {\n            var polygon = [];\n            convertLines(coords[i], polygon, tolerance, true);\n            geometry.push(polygon);\n        }\n    } else if (type === 'GeometryCollection') {\n        for (i = 0; i < geojson.geometry.geometries.length; i++) {\n            convertFeature(features, {\n                id: id,\n                geometry: geojson.geometry.geometries[i],\n                properties: geojson.properties\n            }, options, index);\n        }\n        return;\n    } else {\n        throw new Error('Input data is not a valid GeoJSON object.');\n    }\n\n    features.push(createFeature(id, type, geometry, geojson.properties));\n}\n\nfunction convertPoint(coords, out) {\n    out.push(projectX(coords[0]));\n    out.push(projectY(coords[1]));\n    out.push(0);\n}\n\nfunction convertLine(ring, out, tolerance, isPolygon) {\n    var x0, y0;\n    var size = 0;\n\n    for (var j = 0; j < ring.length; j++) {\n        var x = projectX(ring[j][0]);\n        var y = projectY(ring[j][1]);\n\n        out.push(x);\n        out.push(y);\n        out.push(0);\n\n        if (j > 0) {\n            if (isPolygon) {\n                size += (x0 * y - x * y0) / 2; // area\n            } else {\n                size += Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2)); // length\n            }\n        }\n        x0 = x;\n        y0 = y;\n    }\n\n    var last = out.length - 3;\n    out[2] = 1;\n    simplify(out, 0, last, tolerance);\n    out[last + 2] = 1;\n\n    out.size = Math.abs(size);\n    out.start = 0;\n    out.end = out.size;\n}\n\nfunction convertLines(rings, out, tolerance, isPolygon) {\n    for (var i = 0; i < rings.length; i++) {\n        var geom = [];\n        convertLine(rings[i], geom, tolerance, isPolygon);\n        out.push(geom);\n    }\n}\n\nfunction projectX(x) {\n    return x / 360 + 0.5;\n}\n\nfunction projectY(y) {\n    var sin = Math.sin(y * Math.PI / 180);\n    var y2 = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\n    return y2 < 0 ? 0 : y2 > 1 ? 1 : y2;\n}\n","\nimport createFeature from './feature';\n\n/* clip features between two axis-parallel lines:\n *     |        |\n *  ___|___     |     /\n * /   |   \\____|____/\n *     |        |\n */\n\nexport default function clip(features, scale, k1, k2, axis, minAll, maxAll, options) {\n\n    k1 /= scale;\n    k2 /= scale;\n\n    if (minAll >= k1 && maxAll < k2) return features; // trivial accept\n    else if (maxAll < k1 || minAll >= k2) return null; // trivial reject\n\n    var clipped = [];\n\n    for (var i = 0; i < features.length; i++) {\n\n        var feature = features[i];\n        var geometry = feature.geometry;\n        var type = feature.type;\n\n        var min = axis === 0 ? feature.minX : feature.minY;\n        var max = axis === 0 ? feature.maxX : feature.maxY;\n\n        if (min >= k1 && max < k2) { // trivial accept\n            clipped.push(feature);\n            continue;\n        } else if (max < k1 || min >= k2) { // trivial reject\n            continue;\n        }\n\n        var newGeometry = [];\n\n        if (type === 'Point' || type === 'MultiPoint') {\n            clipPoints(geometry, newGeometry, k1, k2, axis);\n\n        } else if (type === 'LineString') {\n            clipLine(geometry, newGeometry, k1, k2, axis, false, options.lineMetrics);\n\n        } else if (type === 'MultiLineString') {\n            clipLines(geometry, newGeometry, k1, k2, axis, false);\n\n        } else if (type === 'Polygon') {\n            clipLines(geometry, newGeometry, k1, k2, axis, true);\n\n        } else if (type === 'MultiPolygon') {\n            for (var j = 0; j < geometry.length; j++) {\n                var polygon = [];\n                clipLines(geometry[j], polygon, k1, k2, axis, true);\n                if (polygon.length) {\n                    newGeometry.push(polygon);\n                }\n            }\n        }\n\n        if (newGeometry.length) {\n            if (options.lineMetrics && type === 'LineString') {\n                for (j = 0; j < newGeometry.length; j++) {\n                    clipped.push(createFeature(feature.id, type, newGeometry[j], feature.tags));\n                }\n                continue;\n            }\n\n            if (type === 'LineString' || type === 'MultiLineString') {\n                if (newGeometry.length === 1) {\n                    type = 'LineString';\n                    newGeometry = newGeometry[0];\n                } else {\n                    type = 'MultiLineString';\n                }\n            }\n            if (type === 'Point' || type === 'MultiPoint') {\n                type = newGeometry.length === 3 ? 'Point' : 'MultiPoint';\n            }\n\n            clipped.push(createFeature(feature.id, type, newGeometry, feature.tags));\n        }\n    }\n\n    return clipped.length ? clipped : null;\n}\n\nfunction clipPoints(geom, newGeom, k1, k2, axis) {\n    for (var i = 0; i < geom.length; i += 3) {\n        var a = geom[i + axis];\n\n        if (a >= k1 && a <= k2) {\n            newGeom.push(geom[i]);\n            newGeom.push(geom[i + 1]);\n            newGeom.push(geom[i + 2]);\n        }\n    }\n}\n\nfunction clipLine(geom, newGeom, k1, k2, axis, isPolygon, trackMetrics) {\n\n    var slice = newSlice(geom);\n    var intersect = axis === 0 ? intersectX : intersectY;\n    var len = geom.start;\n    var segLen, t;\n\n    for (var i = 0; i < geom.length - 3; i += 3) {\n        var ax = geom[i];\n        var ay = geom[i + 1];\n        var az = geom[i + 2];\n        var bx = geom[i + 3];\n        var by = geom[i + 4];\n        var a = axis === 0 ? ax : ay;\n        var b = axis === 0 ? bx : by;\n        var exited = false;\n\n        if (trackMetrics) segLen = Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));\n\n        if (a < k1) {\n            // ---|-->  | (line enters the clip region from the left)\n            if (b > k1) {\n                t = intersect(slice, ax, ay, bx, by, k1);\n                if (trackMetrics) slice.start = len + segLen * t;\n            }\n        } else if (a > k2) {\n            // |  <--|--- (line enters the clip region from the right)\n            if (b < k2) {\n                t = intersect(slice, ax, ay, bx, by, k2);\n                if (trackMetrics) slice.start = len + segLen * t;\n            }\n        } else {\n            addPoint(slice, ax, ay, az);\n        }\n        if (b < k1 && a >= k1) {\n            // <--|---  | or <--|-----|--- (line exits the clip region on the left)\n            t = intersect(slice, ax, ay, bx, by, k1);\n            exited = true;\n        }\n        if (b > k2 && a <= k2) {\n            // |  ---|--> or ---|-----|--> (line exits the clip region on the right)\n            t = intersect(slice, ax, ay, bx, by, k2);\n            exited = true;\n        }\n\n        if (!isPolygon && exited) {\n            if (trackMetrics) slice.end = len + segLen * t;\n            newGeom.push(slice);\n            slice = newSlice(geom);\n        }\n\n        if (trackMetrics) len += segLen;\n    }\n\n    // add the last point\n    var last = geom.length - 3;\n    ax = geom[last];\n    ay = geom[last + 1];\n    az = geom[last + 2];\n    a = axis === 0 ? ax : ay;\n    if (a >= k1 && a <= k2) addPoint(slice, ax, ay, az);\n\n    // close the polygon if its endpoints are not the same after clipping\n    last = slice.length - 3;\n    if (isPolygon && last >= 3 && (slice[last] !== slice[0] || slice[last + 1] !== slice[1])) {\n        addPoint(slice, slice[0], slice[1], slice[2]);\n    }\n\n    // add the final slice\n    if (slice.length) {\n        newGeom.push(slice);\n    }\n}\n\nfunction newSlice(line) {\n    var slice = [];\n    slice.size = line.size;\n    slice.start = line.start;\n    slice.end = line.end;\n    return slice;\n}\n\nfunction clipLines(geom, newGeom, k1, k2, axis, isPolygon) {\n    for (var i = 0; i < geom.length; i++) {\n        clipLine(geom[i], newGeom, k1, k2, axis, isPolygon, false);\n    }\n}\n\nfunction addPoint(out, x, y, z) {\n    out.push(x);\n    out.push(y);\n    out.push(z);\n}\n\nfunction intersectX(out, ax, ay, bx, by, x) {\n    var t = (x - ax) / (bx - ax);\n    out.push(x);\n    out.push(ay + (by - ay) * t);\n    out.push(1);\n    return t;\n}\n\nfunction intersectY(out, ax, ay, bx, by, y) {\n    var t = (y - ay) / (by - ay);\n    out.push(ax + (bx - ax) * t);\n    out.push(y);\n    out.push(1);\n    return t;\n}\n","\nimport clip from './clip';\nimport createFeature from './feature';\n\nexport default function wrap(features, options) {\n    var buffer = options.buffer / options.extent;\n    var merged = features;\n    var left  = clip(features, 1, -1 - buffer, buffer,     0, -1, 2, options); // left world copy\n    var right = clip(features, 1,  1 - buffer, 2 + buffer, 0, -1, 2, options); // right world copy\n\n    if (left || right) {\n        merged = clip(features, 1, -buffer, 1 + buffer, 0, -1, 2, options) || []; // center world copy\n\n        if (left) merged = shiftFeatureCoords(left, 1).concat(merged); // merge left into center\n        if (right) merged = merged.concat(shiftFeatureCoords(right, -1)); // merge right into center\n    }\n\n    return merged;\n}\n\nfunction shiftFeatureCoords(features, offset) {\n    var newFeatures = [];\n\n    for (var i = 0; i < features.length; i++) {\n        var feature = features[i],\n            type = feature.type;\n\n        var newGeometry;\n\n        if (type === 'Point' || type === 'MultiPoint' || type === 'LineString') {\n            newGeometry = shiftCoords(feature.geometry, offset);\n\n        } else if (type === 'MultiLineString' || type === 'Polygon') {\n            newGeometry = [];\n            for (var j = 0; j < feature.geometry.length; j++) {\n                newGeometry.push(shiftCoords(feature.geometry[j], offset));\n            }\n        } else if (type === 'MultiPolygon') {\n            newGeometry = [];\n            for (j = 0; j < feature.geometry.length; j++) {\n                var newPolygon = [];\n                for (var k = 0; k < feature.geometry[j].length; k++) {\n                    newPolygon.push(shiftCoords(feature.geometry[j][k], offset));\n                }\n                newGeometry.push(newPolygon);\n            }\n        }\n\n        newFeatures.push(createFeature(feature.id, type, newGeometry, feature.tags));\n    }\n\n    return newFeatures;\n}\n\nfunction shiftCoords(points, offset) {\n    var newPoints = [];\n    newPoints.size = points.size;\n\n    if (points.start !== undefined) {\n        newPoints.start = points.start;\n        newPoints.end = points.end;\n    }\n\n    for (var i = 0; i < points.length; i += 3) {\n        newPoints.push(points[i] + offset, points[i + 1], points[i + 2]);\n    }\n    return newPoints;\n}\n","\n// Transforms the coordinates of each feature in the given tile from\n// mercator-projected space into (extent x extent) tile space.\nexport default function transformTile(tile, extent) {\n    if (tile.transformed) return tile;\n\n    var z2 = 1 << tile.z,\n        tx = tile.x,\n        ty = tile.y,\n        i, j, k;\n\n    for (i = 0; i < tile.features.length; i++) {\n        var feature = tile.features[i],\n            geom = feature.geometry,\n            type = feature.type;\n\n        feature.geometry = [];\n\n        if (type === 1) {\n            for (j = 0; j < geom.length; j += 2) {\n                feature.geometry.push(transformPoint(geom[j], geom[j + 1], extent, z2, tx, ty));\n            }\n        } else {\n            for (j = 0; j < geom.length; j++) {\n                var ring = [];\n                for (k = 0; k < geom[j].length; k += 2) {\n                    ring.push(transformPoint(geom[j][k], geom[j][k + 1], extent, z2, tx, ty));\n                }\n                feature.geometry.push(ring);\n            }\n        }\n    }\n\n    tile.transformed = true;\n\n    return tile;\n}\n\nfunction transformPoint(x, y, extent, z2, tx, ty) {\n    return [\n        Math.round(extent * (x * z2 - tx)),\n        Math.round(extent * (y * z2 - ty))];\n}\n","\nexport default function createTile(features, z, tx, ty, options) {\n    var tolerance = z === options.maxZoom ? 0 : options.tolerance / ((1 << z) * options.extent);\n    var tile = {\n        features: [],\n        numPoints: 0,\n        numSimplified: 0,\n        numFeatures: 0,\n        source: null,\n        x: tx,\n        y: ty,\n        z: z,\n        transformed: false,\n        minX: 2,\n        minY: 1,\n        maxX: -1,\n        maxY: 0\n    };\n    for (var i = 0; i < features.length; i++) {\n        tile.numFeatures++;\n        addFeature(tile, features[i], tolerance, options);\n\n        var minX = features[i].minX;\n        var minY = features[i].minY;\n        var maxX = features[i].maxX;\n        var maxY = features[i].maxY;\n\n        if (minX < tile.minX) tile.minX = minX;\n        if (minY < tile.minY) tile.minY = minY;\n        if (maxX > tile.maxX) tile.maxX = maxX;\n        if (maxY > tile.maxY) tile.maxY = maxY;\n    }\n    return tile;\n}\n\nfunction addFeature(tile, feature, tolerance, options) {\n\n    var geom = feature.geometry,\n        type = feature.type,\n        simplified = [];\n\n    if (type === 'Point' || type === 'MultiPoint') {\n        for (var i = 0; i < geom.length; i += 3) {\n            simplified.push(geom[i]);\n            simplified.push(geom[i + 1]);\n            tile.numPoints++;\n            tile.numSimplified++;\n        }\n\n    } else if (type === 'LineString') {\n        addLine(simplified, geom, tile, tolerance, false, false);\n\n    } else if (type === 'MultiLineString' || type === 'Polygon') {\n        for (i = 0; i < geom.length; i++) {\n            addLine(simplified, geom[i], tile, tolerance, type === 'Polygon', i === 0);\n        }\n\n    } else if (type === 'MultiPolygon') {\n\n        for (var k = 0; k < geom.length; k++) {\n            var polygon = geom[k];\n            for (i = 0; i < polygon.length; i++) {\n                addLine(simplified, polygon[i], tile, tolerance, true, i === 0);\n            }\n        }\n    }\n\n    if (simplified.length) {\n        var tags = feature.tags || null;\n        if (type === 'LineString' && options.lineMetrics) {\n            tags = {};\n            for (var key in feature.tags) tags[key] = feature.tags[key];\n            tags['mapbox_clip_start'] = geom.start / geom.size;\n            tags['mapbox_clip_end'] = geom.end / geom.size;\n        }\n        var tileFeature = {\n            geometry: simplified,\n            type: type === 'Polygon' || type === 'MultiPolygon' ? 3 :\n                type === 'LineString' || type === 'MultiLineString' ? 2 : 1,\n            tags: tags\n        };\n        if (feature.id !== null) {\n            tileFeature.id = feature.id;\n        }\n        tile.features.push(tileFeature);\n    }\n}\n\nfunction addLine(result, geom, tile, tolerance, isPolygon, isOuter) {\n    var sqTolerance = tolerance * tolerance;\n\n    if (tolerance > 0 && (geom.size < (isPolygon ? sqTolerance : tolerance))) {\n        tile.numPoints += geom.length / 3;\n        return;\n    }\n\n    var ring = [];\n\n    for (var i = 0; i < geom.length; i += 3) {\n        if (tolerance === 0 || geom[i + 2] > sqTolerance) {\n            tile.numSimplified++;\n            ring.push(geom[i]);\n            ring.push(geom[i + 1]);\n        }\n        tile.numPoints++;\n    }\n\n    if (isPolygon) rewind(ring, isOuter);\n\n    result.push(ring);\n}\n\nfunction rewind(ring, clockwise) {\n    var area = 0;\n    for (var i = 0, len = ring.length, j = len - 2; i < len; j = i, i += 2) {\n        area += (ring[i] - ring[j]) * (ring[i + 1] + ring[j + 1]);\n    }\n    if (area > 0 === clockwise) {\n        for (i = 0, len = ring.length; i < len / 2; i += 2) {\n            var x = ring[i];\n            var y = ring[i + 1];\n            ring[i] = ring[len - 2 - i];\n            ring[i + 1] = ring[len - 1 - i];\n            ring[len - 2 - i] = x;\n            ring[len - 1 - i] = y;\n        }\n    }\n}\n","\nimport convert from './convert';     // GeoJSON conversion and preprocessing\nimport clip from './clip';           // stripe clipping algorithm\nimport wrap from './wrap';           // date line processing\nimport transform from './transform'; // coordinate transformation\nimport createTile from './tile';     // final simplified tile generation\n\nexport default function geojsonvt(data, options) {\n    return new GeoJSONVT(data, options);\n}\n\nfunction GeoJSONVT(data, options) {\n    options = this.options = extend(Object.create(this.options), options);\n\n    var debug = options.debug;\n\n    if (debug) console.time('preprocess data');\n\n    if (options.maxZoom < 0 || options.maxZoom > 24) throw new Error('maxZoom should be in the 0-24 range');\n    if (options.promoteId && options.generateId) throw new Error('promoteId and generateId cannot be used together.');\n\n    var features = convert(data, options);\n\n    this.tiles = {};\n    this.tileCoords = [];\n\n    if (debug) {\n        console.timeEnd('preprocess data');\n        console.log('index: maxZoom: %d, maxPoints: %d', options.indexMaxZoom, options.indexMaxPoints);\n        console.time('generate tiles');\n        this.stats = {};\n        this.total = 0;\n    }\n\n    features = wrap(features, options);\n\n    // start slicing from the top tile down\n    if (features.length) this.splitTile(features, 0, 0, 0);\n\n    if (debug) {\n        if (features.length) console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints);\n        console.timeEnd('generate tiles');\n        console.log('tiles generated:', this.total, JSON.stringify(this.stats));\n    }\n}\n\nGeoJSONVT.prototype.options = {\n    maxZoom: 14,            // max zoom to preserve detail on\n    indexMaxZoom: 5,        // max zoom in the tile index\n    indexMaxPoints: 100000, // max number of points per tile in the tile index\n    tolerance: 3,           // simplification tolerance (higher means simpler)\n    extent: 4096,           // tile extent\n    buffer: 64,             // tile buffer on each side\n    lineMetrics: false,     // whether to calculate line metrics\n    promoteId: null,        // name of a feature property to be promoted to feature.id\n    generateId: false,      // whether to generate feature ids. Cannot be used with promoteId\n    debug: 0                // logging level (0, 1 or 2)\n};\n\nGeoJSONVT.prototype.splitTile = function (features, z, x, y, cz, cx, cy) {\n\n    var stack = [features, z, x, y],\n        options = this.options,\n        debug = options.debug;\n\n    // avoid recursion by using a processing queue\n    while (stack.length) {\n        y = stack.pop();\n        x = stack.pop();\n        z = stack.pop();\n        features = stack.pop();\n\n        var z2 = 1 << z,\n            id = toID(z, x, y),\n            tile = this.tiles[id];\n\n        if (!tile) {\n            if (debug > 1) console.time('creation');\n\n            tile = this.tiles[id] = createTile(features, z, x, y, options);\n            this.tileCoords.push({z: z, x: x, y: y});\n\n            if (debug) {\n                if (debug > 1) {\n                    console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)',\n                        z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified);\n                    console.timeEnd('creation');\n                }\n                var key = 'z' + z;\n                this.stats[key] = (this.stats[key] || 0) + 1;\n                this.total++;\n            }\n        }\n\n        // save reference to original geometry in tile so that we can drill down later if we stop now\n        tile.source = features;\n\n        // if it's the first-pass tiling\n        if (!cz) {\n            // stop tiling if we reached max zoom, or if the tile is too simple\n            if (z === options.indexMaxZoom || tile.numPoints <= options.indexMaxPoints) continue;\n\n        // if a drilldown to a specific tile\n        } else {\n            // stop tiling if we reached base zoom or our target tile zoom\n            if (z === options.maxZoom || z === cz) continue;\n\n            // stop tiling if it's not an ancestor of the target tile\n            var m = 1 << (cz - z);\n            if (x !== Math.floor(cx / m) || y !== Math.floor(cy / m)) continue;\n        }\n\n        // if we slice further down, no need to keep source geometry\n        tile.source = null;\n\n        if (features.length === 0) continue;\n\n        if (debug > 1) console.time('clipping');\n\n        // values we'll use for clipping\n        var k1 = 0.5 * options.buffer / options.extent,\n            k2 = 0.5 - k1,\n            k3 = 0.5 + k1,\n            k4 = 1 + k1,\n            tl, bl, tr, br, left, right;\n\n        tl = bl = tr = br = null;\n\n        left  = clip(features, z2, x - k1, x + k3, 0, tile.minX, tile.maxX, options);\n        right = clip(features, z2, x + k2, x + k4, 0, tile.minX, tile.maxX, options);\n        features = null;\n\n        if (left) {\n            tl = clip(left, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);\n            bl = clip(left, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);\n            left = null;\n        }\n\n        if (right) {\n            tr = clip(right, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, options);\n            br = clip(right, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, options);\n            right = null;\n        }\n\n        if (debug > 1) console.timeEnd('clipping');\n\n        stack.push(tl || [], z + 1, x * 2,     y * 2);\n        stack.push(bl || [], z + 1, x * 2,     y * 2 + 1);\n        stack.push(tr || [], z + 1, x * 2 + 1, y * 2);\n        stack.push(br || [], z + 1, x * 2 + 1, y * 2 + 1);\n    }\n};\n\nGeoJSONVT.prototype.getTile = function (z, x, y) {\n    var options = this.options,\n        extent = options.extent,\n        debug = options.debug;\n\n    if (z < 0 || z > 24) return null;\n\n    var z2 = 1 << z;\n    x = ((x % z2) + z2) % z2; // wrap tile x coordinate\n\n    var id = toID(z, x, y);\n    if (this.tiles[id]) return transform(this.tiles[id], extent);\n\n    if (debug > 1) console.log('drilling down to z%d-%d-%d', z, x, y);\n\n    var z0 = z,\n        x0 = x,\n        y0 = y,\n        parent;\n\n    while (!parent && z0 > 0) {\n        z0--;\n        x0 = Math.floor(x0 / 2);\n        y0 = Math.floor(y0 / 2);\n        parent = this.tiles[toID(z0, x0, y0)];\n    }\n\n    if (!parent || !parent.source) return null;\n\n    // if we found a parent tile containing the original geometry, we can drill down from it\n    if (debug > 1) console.log('found parent tile z%d-%d-%d', z0, x0, y0);\n\n    if (debug > 1) console.time('drilling down');\n    this.splitTile(parent.source, z0, x0, y0, z, x, y);\n    if (debug > 1) console.timeEnd('drilling down');\n\n    return this.tiles[id] ? transform(this.tiles[id], extent) : null;\n};\n\nfunction toID(z, x, y) {\n    return (((1 << z) * y + x) * 32) + z;\n}\n\nfunction extend(dest, src) {\n    for (var i in src) dest[i] = src[i];\n    return dest;\n}\n","// @flow\n\nimport {getJSON} from '../util/ajax';\n\nimport performance from '../util/performance';\nimport rewind from '@mapbox/geojson-rewind';\nimport GeoJSONWrapper from './geojson_wrapper';\nimport vtpbf from 'vt-pbf';\nimport Supercluster from 'supercluster';\nimport geojsonvt from 'geojson-vt';\nimport assert from 'assert';\nimport VectorTileWorkerSource from './vector_tile_worker_source';\nimport {createExpression} from '../style-spec/expression';\n\nimport type {\n    WorkerTileParameters,\n    WorkerTileCallback,\n} from '../source/worker_source';\n\nimport type Actor from '../util/actor';\nimport type StyleLayerIndex from '../style/style_layer_index';\n\nimport type {LoadVectorDataCallback} from './vector_tile_worker_source';\nimport type {RequestParameters, ResponseCallback} from '../util/ajax';\nimport type {Callback} from '../types/callback';\nimport type {GeoJSONFeature} from '@mapbox/geojson-types';\n\nexport type LoadGeoJSONParameters = {\n    request?: RequestParameters,\n    data?: string,\n    source: string,\n    cluster: boolean,\n    superclusterOptions?: Object,\n    geojsonVtOptions?: Object,\n    clusterProperties?: Object\n};\n\nexport type LoadGeoJSON = (params: LoadGeoJSONParameters, callback: ResponseCallback<Object>) => void;\n\nexport interface GeoJSONIndex {\n    getTile(z: number, x: number, y: number): Object;\n\n    // supercluster methods\n    getClusterExpansionZoom(clusterId: number): number;\n    getChildren(clusterId: number): Array<GeoJSONFeature>;\n    getLeaves(clusterId: number, limit: number, offset: number): Array<GeoJSONFeature>;\n}\n\nfunction loadGeoJSONTile(params: WorkerTileParameters, callback: LoadVectorDataCallback) {\n    const canonical = params.tileID.canonical;\n\n    if (!this._geoJSONIndex) {\n        return callback(null, null);  // we couldn't load the file\n    }\n\n    const geoJSONTile = this._geoJSONIndex.getTile(canonical.z, canonical.x, canonical.y);\n    if (!geoJSONTile) {\n        return callback(null, null); // nothing in the given tile\n    }\n\n    const geojsonWrapper = new GeoJSONWrapper(geoJSONTile.features);\n\n    // Encode the geojson-vt tile into binary vector tile form.  This\n    // is a convenience that allows `FeatureIndex` to operate the same way\n    // across `VectorTileSource` and `GeoJSONSource` data.\n    let pbf = vtpbf(geojsonWrapper);\n    if (pbf.byteOffset !== 0 || pbf.byteLength !== pbf.buffer.byteLength) {\n        // Compatibility with node Buffer (https://github.com/mapbox/pbf/issues/35)\n        pbf = new Uint8Array(pbf);\n    }\n\n    callback(null, {\n        vectorTile: geojsonWrapper,\n        rawData: pbf.buffer\n    });\n}\n\nexport type SourceState =\n    | 'Idle'            // Source empty or data loaded\n    | 'Coalescing'      // Data finished loading, but discard 'loadData' messages until receiving 'coalesced'\n    | 'NeedsLoadData';  // 'loadData' received while coalescing, trigger one more 'loadData' on receiving 'coalesced'\n\n/**\n * The {@link WorkerSource} implementation that supports {@link GeoJSONSource}.\n * This class is designed to be easily reused to support custom source types\n * for data formats that can be parsed/converted into an in-memory GeoJSON\n * representation.  To do so, create it with\n * `new GeoJSONWorkerSource(actor, layerIndex, customLoadGeoJSONFunction)`.\n * For a full example, see [mapbox-gl-topojson](https://github.com/developmentseed/mapbox-gl-topojson).\n *\n * @private\n */\nclass GeoJSONWorkerSource extends VectorTileWorkerSource {\n    loadGeoJSON: LoadGeoJSON;\n    _state: SourceState;\n    _pendingCallback: Callback<{\n        resourceTiming?: {[string]: Array<PerformanceResourceTiming>},\n        abandoned?: boolean }>;\n    _pendingLoadDataParams: LoadGeoJSONParameters;\n    _geoJSONIndex: GeoJSONIndex\n\n    /**\n     * @param [loadGeoJSON] Optional method for custom loading/parsing of\n     * GeoJSON based on parameters passed from the main-thread Source.\n     * See {@link GeoJSONWorkerSource#loadGeoJSON}.\n     */\n    constructor(actor: Actor, layerIndex: StyleLayerIndex, availableImages: Array<string>, loadGeoJSON: ?LoadGeoJSON) {\n        super(actor, layerIndex, availableImages, loadGeoJSONTile);\n        if (loadGeoJSON) {\n            this.loadGeoJSON = loadGeoJSON;\n        }\n    }\n\n    /**\n     * Fetches (if appropriate), parses, and index geojson data into tiles. This\n     * preparatory method must be called before {@link GeoJSONWorkerSource#loadTile}\n     * can correctly serve up tiles.\n     *\n     * Defers to {@link GeoJSONWorkerSource#loadGeoJSON} for the fetching/parsing,\n     * expecting `callback(error, data)` to be called with either an error or a\n     * parsed GeoJSON object.\n     *\n     * When `loadData` requests come in faster than they can be processed,\n     * they are coalesced into a single request using the latest data.\n     * See {@link GeoJSONWorkerSource#coalesce}\n     *\n     * @param params\n     * @param callback\n     */\n    loadData(params: LoadGeoJSONParameters, callback: Callback<{\n        resourceTiming?: {[string]: Array<PerformanceResourceTiming>},\n        abandoned?: boolean }>) {\n        if (this._pendingCallback) {\n            // Tell the foreground the previous call has been abandoned\n            this._pendingCallback(null, {abandoned: true});\n        }\n        this._pendingCallback = callback;\n        this._pendingLoadDataParams = params;\n\n        if (this._state &&\n            this._state !== 'Idle') {\n            this._state = 'NeedsLoadData';\n        } else {\n            this._state = 'Coalescing';\n            this._loadData();\n        }\n    }\n\n    /**\n     * Internal implementation: called directly by `loadData`\n     * or by `coalesce` using stored parameters.\n     */\n    _loadData() {\n        if (!this._pendingCallback || !this._pendingLoadDataParams) {\n            assert(false);\n            return;\n        }\n        const callback = this._pendingCallback;\n        const params = this._pendingLoadDataParams;\n        delete this._pendingCallback;\n        delete this._pendingLoadDataParams;\n\n        const perf = (params && params.request && params.request.collectResourceTiming) ?\n            new performance.Performance(params.request) : false;\n\n        this.loadGeoJSON(params, (err: ?Error, data: ?Object) => {\n            if (err || !data) {\n                return callback(err);\n            } else if (typeof data !== 'object') {\n                return callback(new Error(`Input data given to '${params.source}' is not a valid GeoJSON object.`));\n            } else {\n                rewind(data, true);\n\n                try {\n                    this._geoJSONIndex = params.cluster ?\n                        new Supercluster(getSuperclusterOptions(params)).load(data.features) :\n                        geojsonvt(data, params.geojsonVtOptions);\n                } catch (err) {\n                    return callback(err);\n                }\n\n                this.loaded = {};\n\n                const result = {};\n                if (perf) {\n                    const resourceTimingData = perf.finish();\n                    // it's necessary to eval the result of getEntriesByName() here via parse/stringify\n                    // late evaluation in the main thread causes TypeError: illegal invocation\n                    if (resourceTimingData) {\n                        result.resourceTiming = {};\n                        result.resourceTiming[params.source] = JSON.parse(JSON.stringify(resourceTimingData));\n                    }\n                }\n                callback(null, result);\n            }\n        });\n    }\n\n    /**\n     * While processing `loadData`, we coalesce all further\n     * `loadData` messages into a single call to _loadData\n     * that will happen once we've finished processing the\n     * first message. {@link GeoJSONSource#_updateWorkerData}\n     * is responsible for sending us the `coalesce` message\n     * at the time it receives a response from `loadData`\n     *\n     *          State: Idle\n     *          â          |\n     *     'coalesce'   'loadData'\n     *          |     (triggers load)\n     *          |          â\n     *        State: Coalescing\n     *          â          |\n     *   (triggers load)   |\n     *     'coalesce'   'loadData'\n     *          |          â\n     *        State: NeedsLoadData\n     */\n    coalesce() {\n        if (this._state === 'Coalescing') {\n            this._state = 'Idle';\n        } else if (this._state === 'NeedsLoadData') {\n            this._state = 'Coalescing';\n            this._loadData();\n        }\n    }\n\n    /**\n    * Implements {@link WorkerSource#reloadTile}.\n    *\n    * If the tile is loaded, uses the implementation in VectorTileWorkerSource.\n    * Otherwise, such as after a setData() call, we load the tile fresh.\n    *\n    * @param params\n    * @param params.uid The UID for this tile.\n    */\n    reloadTile(params: WorkerTileParameters, callback: WorkerTileCallback) {\n        const loaded = this.loaded,\n            uid = params.uid;\n\n        if (loaded && loaded[uid]) {\n            return super.reloadTile(params, callback);\n        } else {\n            return this.loadTile(params, callback);\n        }\n    }\n\n    /**\n     * Fetch and parse GeoJSON according to the given params.  Calls `callback`\n     * with `(err, data)`, where `data` is a parsed GeoJSON object.\n     *\n     * GeoJSON is loaded and parsed from `params.url` if it exists, or else\n     * expected as a literal (string or object) `params.data`.\n     *\n     * @param params\n     * @param [params.url] A URL to the remote GeoJSON data.\n     * @param [params.data] Literal GeoJSON data. Must be provided if `params.url` is not.\n     */\n    loadGeoJSON(params: LoadGeoJSONParameters, callback: ResponseCallback<Object>) {\n        // Because of same origin issues, urls must either include an explicit\n        // origin or absolute path.\n        // ie: /foo/bar.json or http://example.com/bar.json\n        // but not ../foo/bar.json\n        if (params.request) {\n            getJSON(params.request, callback);\n        } else if (typeof params.data === 'string') {\n            try {\n                return callback(null, JSON.parse(params.data));\n            } catch (e) {\n                return callback(new Error(`Input data given to '${params.source}' is not a valid GeoJSON object.`));\n            }\n        } else {\n            return callback(new Error(`Input data given to '${params.source}' is not a valid GeoJSON object.`));\n        }\n    }\n\n    removeSource(params: {source: string}, callback: Callback<mixed>) {\n        if (this._pendingCallback) {\n            // Don't leak callbacks\n            this._pendingCallback(null, {abandoned: true});\n        }\n        callback();\n    }\n\n    getClusterExpansionZoom(params: {clusterId: number}, callback: Callback<number>) {\n        callback(null, this._geoJSONIndex.getClusterExpansionZoom(params.clusterId));\n    }\n\n    getClusterChildren(params: {clusterId: number}, callback: Callback<Array<GeoJSONFeature>>) {\n        callback(null, this._geoJSONIndex.getChildren(params.clusterId));\n    }\n\n    getClusterLeaves(params: {clusterId: number, limit: number, offset: number}, callback: Callback<Array<GeoJSONFeature>>) {\n        callback(null, this._geoJSONIndex.getLeaves(params.clusterId, params.limit, params.offset));\n    }\n}\n\nfunction getSuperclusterOptions({superclusterOptions, clusterProperties}) {\n    if (!clusterProperties || !superclusterOptions) return superclusterOptions;\n\n    const mapExpressions = {};\n    const reduceExpressions = {};\n    const globals = {accumulated: null, zoom: 0};\n    const feature = {properties: null};\n    const propertyNames = Object.keys(clusterProperties);\n\n    for (const key of propertyNames) {\n        const [operator, mapExpression] = clusterProperties[key];\n\n        const mapExpressionParsed = createExpression(mapExpression);\n        const reduceExpressionParsed = createExpression(\n            typeof operator === 'string' ? [operator, ['accumulated'], ['get', key]] : operator);\n\n        assert(mapExpressionParsed.result === 'success');\n        assert(reduceExpressionParsed.result === 'success');\n\n        mapExpressions[key] = mapExpressionParsed.value;\n        reduceExpressions[key] = reduceExpressionParsed.value;\n    }\n\n    superclusterOptions.map = (pointProperties) => {\n        feature.properties = pointProperties;\n        const properties = {};\n        for (const key of propertyNames) {\n            properties[key] = mapExpressions[key].evaluate(globals, feature);\n        }\n        return properties;\n    };\n    superclusterOptions.reduce = (accumulated, clusterProperties) => {\n        feature.properties = clusterProperties;\n        for (const key of propertyNames) {\n            globals.accumulated = accumulated[key];\n            accumulated[key] = reduceExpressions[key].evaluate(globals, feature);\n        }\n    };\n\n    return superclusterOptions;\n}\n\nexport default GeoJSONWorkerSource;\n","\nimport refProperties from './util/ref_properties';\n\nfunction deref(layer, parent) {\n    const result = {};\n\n    for (const k in layer) {\n        if (k !== 'ref') {\n            result[k] = layer[k];\n        }\n    }\n\n    refProperties.forEach((k) => {\n        if (k in parent) {\n            result[k] = parent[k];\n        }\n    });\n\n    return result;\n}\n\nexport default derefLayers;\n\n/**\n * Given an array of layers, some of which may contain `ref` properties\n * whose value is the `id` of another property, return a new array where\n * such layers have been augmented with the 'type', 'source', etc. properties\n * from the parent layer, and the `ref` property has been removed.\n *\n * The input is not modified. The output may contain references to portions\n * of the input.\n *\n * @private\n * @param {Array<Layer>} layers\n * @returns {Array<Layer>}\n */\nfunction derefLayers(layers) {\n    layers = layers.slice();\n\n    const map = Object.create(null);\n    for (let i = 0; i < layers.length; i++) {\n        map[layers[i].id] = layers[i];\n    }\n\n    for (let i = 0; i < layers.length; i++) {\n        if ('ref' in layers[i]) {\n            layers[i] = deref(layers[i], map[layers[i].ref]);\n        }\n    }\n\n    return layers;\n}\n","// @flow\n\nimport WebWorker from './web_worker';\nimport type {WorkerInterface} from './web_worker';\nimport browser from './browser';\n\n/**\n * Constructs a worker pool.\n * @private\n */\nexport default class WorkerPool {\n    static workerCount: number;\n\n    active: {[number]: boolean};\n    workers: Array<WorkerInterface>;\n\n    constructor() {\n        this.active = {};\n    }\n\n    acquire(mapId: number): Array<WorkerInterface> {\n        if (!this.workers) {\n            // Lazily look up the value of mapboxgl.workerCount so that\n            // client code has had a chance to set it.\n            this.workers = [];\n            while (this.workers.length < WorkerPool.workerCount) {\n                this.workers.push(new WebWorker());\n            }\n        }\n\n        this.active[mapId] = true;\n        return this.workers.slice();\n    }\n\n    release(mapId: number) {\n        delete this.active[mapId];\n        if (Object.keys(this.active).length === 0) {\n            this.workers.forEach((w) => {\n                w.terminate();\n            });\n            this.workers = (null: any);\n        }\n    }\n}\n\nconst availableLogicalProcessors = Math.floor(browser.hardwareConcurrency / 2);\nWorkerPool.workerCount = Math.max(Math.min(availableLogicalProcessors, 6), 1);\n","\nimport isEqual from './util/deep_equal';\n\nconst operations = {\n\n    /*\n     * { command: 'setStyle', args: [stylesheet] }\n     */\n    setStyle: 'setStyle',\n\n    /*\n     * { command: 'addLayer', args: [layer, 'beforeLayerId'] }\n     */\n    addLayer: 'addLayer',\n\n    /*\n     * { command: 'removeLayer', args: ['layerId'] }\n     */\n    removeLayer: 'removeLayer',\n\n    /*\n     * { command: 'setPaintProperty', args: ['layerId', 'prop', value] }\n     */\n    setPaintProperty: 'setPaintProperty',\n\n    /*\n     * { command: 'setLayoutProperty', args: ['layerId', 'prop', value] }\n     */\n    setLayoutProperty: 'setLayoutProperty',\n\n    /*\n     * { command: 'setFilter', args: ['layerId', filter] }\n     */\n    setFilter: 'setFilter',\n\n    /*\n     * { command: 'addSource', args: ['sourceId', source] }\n     */\n    addSource: 'addSource',\n\n    /*\n     * { command: 'removeSource', args: ['sourceId'] }\n     */\n    removeSource: 'removeSource',\n\n    /*\n     * { command: 'setGeoJSONSourceData', args: ['sourceId', data] }\n     */\n    setGeoJSONSourceData: 'setGeoJSONSourceData',\n\n    /*\n     * { command: 'setLayerZoomRange', args: ['layerId', 0, 22] }\n     */\n    setLayerZoomRange: 'setLayerZoomRange',\n\n    /*\n     * { command: 'setLayerProperty', args: ['layerId', 'prop', value] }\n     */\n    setLayerProperty: 'setLayerProperty',\n\n    /*\n     * { command: 'setCenter', args: [[lon, lat]] }\n     */\n    setCenter: 'setCenter',\n\n    /*\n     * { command: 'setZoom', args: [zoom] }\n     */\n    setZoom: 'setZoom',\n\n    /*\n     * { command: 'setBearing', args: [bearing] }\n     */\n    setBearing: 'setBearing',\n\n    /*\n     * { command: 'setPitch', args: [pitch] }\n     */\n    setPitch: 'setPitch',\n\n    /*\n     * { command: 'setSprite', args: ['spriteUrl'] }\n     */\n    setSprite: 'setSprite',\n\n    /*\n     * { command: 'setGlyphs', args: ['glyphsUrl'] }\n     */\n    setGlyphs: 'setGlyphs',\n\n    /*\n     * { command: 'setTransition', args: [transition] }\n     */\n    setTransition: 'setTransition',\n\n    /*\n     * { command: 'setLighting', args: [lightProperties] }\n     */\n    setLight: 'setLight'\n\n};\n\nfunction addSource(sourceId, after, commands) {\n    commands.push({command: operations.addSource, args: [sourceId, after[sourceId]]});\n}\n\nfunction removeSource(sourceId, commands, sourcesRemoved) {\n    commands.push({command: operations.removeSource, args: [sourceId]});\n    sourcesRemoved[sourceId] = true;\n}\n\nfunction updateSource(sourceId, after, commands, sourcesRemoved) {\n    removeSource(sourceId, commands, sourcesRemoved);\n    addSource(sourceId, after, commands);\n}\n\nfunction canUpdateGeoJSON(before, after, sourceId) {\n    let prop;\n    for (prop in before[sourceId]) {\n        if (!before[sourceId].hasOwnProperty(prop)) continue;\n        if (prop !== 'data' && !isEqual(before[sourceId][prop], after[sourceId][prop])) {\n            return false;\n        }\n    }\n    for (prop in after[sourceId]) {\n        if (!after[sourceId].hasOwnProperty(prop)) continue;\n        if (prop !== 'data' && !isEqual(before[sourceId][prop], after[sourceId][prop])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction diffSources(before, after, commands, sourcesRemoved) {\n    before = before || {};\n    after = after || {};\n\n    let sourceId;\n\n    // look for sources to remove\n    for (sourceId in before) {\n        if (!before.hasOwnProperty(sourceId)) continue;\n        if (!after.hasOwnProperty(sourceId)) {\n            removeSource(sourceId, commands, sourcesRemoved);\n        }\n    }\n\n    // look for sources to add/update\n    for (sourceId in after) {\n        if (!after.hasOwnProperty(sourceId)) continue;\n        if (!before.hasOwnProperty(sourceId)) {\n            addSource(sourceId, after, commands);\n        } else if (!isEqual(before[sourceId], after[sourceId])) {\n            if (before[sourceId].type === 'geojson' && after[sourceId].type === 'geojson' && canUpdateGeoJSON(before, after, sourceId)) {\n                commands.push({command: operations.setGeoJSONSourceData, args: [sourceId, after[sourceId].data]});\n            } else {\n                // no update command, must remove then add\n                updateSource(sourceId, after, commands, sourcesRemoved);\n            }\n        }\n    }\n}\n\nfunction diffLayerPropertyChanges(before, after, commands, layerId, klass, command) {\n    before = before || {};\n    after = after || {};\n\n    let prop;\n\n    for (prop in before) {\n        if (!before.hasOwnProperty(prop)) continue;\n        if (!isEqual(before[prop], after[prop])) {\n            commands.push({command, args: [layerId, prop, after[prop], klass]});\n        }\n    }\n    for (prop in after) {\n        if (!after.hasOwnProperty(prop) || before.hasOwnProperty(prop)) continue;\n        if (!isEqual(before[prop], after[prop])) {\n            commands.push({command, args: [layerId, prop, after[prop], klass]});\n        }\n    }\n}\n\nfunction pluckId(layer) {\n    return layer.id;\n}\nfunction indexById(group, layer) {\n    group[layer.id] = layer;\n    return group;\n}\n\nfunction diffLayers(before, after, commands) {\n    before = before || [];\n    after = after || [];\n\n    // order of layers by id\n    const beforeOrder = before.map(pluckId);\n    const afterOrder = after.map(pluckId);\n\n    // index of layer by id\n    const beforeIndex = before.reduce(indexById, {});\n    const afterIndex = after.reduce(indexById, {});\n\n    // track order of layers as if they have been mutated\n    const tracker = beforeOrder.slice();\n\n    // layers that have been added do not need to be diffed\n    const clean = Object.create(null);\n\n    let i, d, layerId, beforeLayer, afterLayer, insertBeforeLayerId, prop;\n\n    // remove layers\n    for (i = 0, d = 0; i < beforeOrder.length; i++) {\n        layerId = beforeOrder[i];\n        if (!afterIndex.hasOwnProperty(layerId)) {\n            commands.push({command: operations.removeLayer, args: [layerId]});\n            tracker.splice(tracker.indexOf(layerId, d), 1);\n        } else {\n            // limit where in tracker we need to look for a match\n            d++;\n        }\n    }\n\n    // add/reorder layers\n    for (i = 0, d = 0; i < afterOrder.length; i++) {\n        // work backwards as insert is before an existing layer\n        layerId = afterOrder[afterOrder.length - 1 - i];\n\n        if (tracker[tracker.length - 1 - i] === layerId) continue;\n\n        if (beforeIndex.hasOwnProperty(layerId)) {\n            // remove the layer before we insert at the correct position\n            commands.push({command: operations.removeLayer, args: [layerId]});\n            tracker.splice(tracker.lastIndexOf(layerId, tracker.length - d), 1);\n        } else {\n            // limit where in tracker we need to look for a match\n            d++;\n        }\n\n        // add layer at correct position\n        insertBeforeLayerId = tracker[tracker.length - i];\n        commands.push({command: operations.addLayer, args: [afterIndex[layerId], insertBeforeLayerId]});\n        tracker.splice(tracker.length - i, 0, layerId);\n        clean[layerId] = true;\n    }\n\n    // update layers\n    for (i = 0; i < afterOrder.length; i++) {\n        layerId = afterOrder[i];\n        beforeLayer = beforeIndex[layerId];\n        afterLayer = afterIndex[layerId];\n\n        // no need to update if previously added (new or moved)\n        if (clean[layerId] || isEqual(beforeLayer, afterLayer)) continue;\n\n        // If source, source-layer, or type have changes, then remove the layer\n        // and add it back 'from scratch'.\n        if (!isEqual(beforeLayer.source, afterLayer.source) || !isEqual(beforeLayer['source-layer'], afterLayer['source-layer']) || !isEqual(beforeLayer.type, afterLayer.type)) {\n            commands.push({command: operations.removeLayer, args: [layerId]});\n            // we add the layer back at the same position it was already in, so\n            // there's no need to update the `tracker`\n            insertBeforeLayerId = tracker[tracker.lastIndexOf(layerId) + 1];\n            commands.push({command: operations.addLayer, args: [afterLayer, insertBeforeLayerId]});\n            continue;\n        }\n\n        // layout, paint, filter, minzoom, maxzoom\n        diffLayerPropertyChanges(beforeLayer.layout, afterLayer.layout, commands, layerId, null, operations.setLayoutProperty);\n        diffLayerPropertyChanges(beforeLayer.paint, afterLayer.paint, commands, layerId, null, operations.setPaintProperty);\n        if (!isEqual(beforeLayer.filter, afterLayer.filter)) {\n            commands.push({command: operations.setFilter, args: [layerId, afterLayer.filter]});\n        }\n        if (!isEqual(beforeLayer.minzoom, afterLayer.minzoom) || !isEqual(beforeLayer.maxzoom, afterLayer.maxzoom)) {\n            commands.push({command: operations.setLayerZoomRange, args: [layerId, afterLayer.minzoom, afterLayer.maxzoom]});\n        }\n\n        // handle all other layer props, including paint.*\n        for (prop in beforeLayer) {\n            if (!beforeLayer.hasOwnProperty(prop)) continue;\n            if (prop === 'layout' || prop === 'paint' || prop === 'filter' ||\n                prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom') continue;\n            if (prop.indexOf('paint.') === 0) {\n                diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);\n            } else if (!isEqual(beforeLayer[prop], afterLayer[prop])) {\n                commands.push({command: operations.setLayerProperty, args: [layerId, prop, afterLayer[prop]]});\n            }\n        }\n        for (prop in afterLayer) {\n            if (!afterLayer.hasOwnProperty(prop) || beforeLayer.hasOwnProperty(prop)) continue;\n            if (prop === 'layout' || prop === 'paint' || prop === 'filter' ||\n                prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom') continue;\n            if (prop.indexOf('paint.') === 0) {\n                diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);\n            } else if (!isEqual(beforeLayer[prop], afterLayer[prop])) {\n                commands.push({command: operations.setLayerProperty, args: [layerId, prop, afterLayer[prop]]});\n            }\n        }\n    }\n}\n\n/**\n * Diff two stylesheet\n *\n * Creates semanticly aware diffs that can easily be applied at runtime.\n * Operations produced by the diff closely resemble the mapbox-gl-js API. Any\n * error creating the diff will fall back to the 'setStyle' operation.\n *\n * Example diff:\n * [\n *     { command: 'setConstant', args: ['@water', '#0000FF'] },\n *     { command: 'setPaintProperty', args: ['background', 'background-color', 'black'] }\n * ]\n *\n * @private\n * @param {*} [before] stylesheet to compare from\n * @param {*} after stylesheet to compare to\n * @returns Array list of changes\n */\nfunction diffStyles(before, after) {\n    if (!before) return [{command: operations.setStyle, args: [after]}];\n\n    let commands = [];\n\n    try {\n        // Handle changes to top-level properties\n        if (!isEqual(before.version, after.version)) {\n            return [{command: operations.setStyle, args: [after]}];\n        }\n        if (!isEqual(before.center, after.center)) {\n            commands.push({command: operations.setCenter, args: [after.center]});\n        }\n        if (!isEqual(before.zoom, after.zoom)) {\n            commands.push({command: operations.setZoom, args: [after.zoom]});\n        }\n        if (!isEqual(before.bearing, after.bearing)) {\n            commands.push({command: operations.setBearing, args: [after.bearing]});\n        }\n        if (!isEqual(before.pitch, after.pitch)) {\n            commands.push({command: operations.setPitch, args: [after.pitch]});\n        }\n        if (!isEqual(before.sprite, after.sprite)) {\n            commands.push({command: operations.setSprite, args: [after.sprite]});\n        }\n        if (!isEqual(before.glyphs, after.glyphs)) {\n            commands.push({command: operations.setGlyphs, args: [after.glyphs]});\n        }\n        if (!isEqual(before.transition, after.transition)) {\n            commands.push({command: operations.setTransition, args: [after.transition]});\n        }\n        if (!isEqual(before.light, after.light)) {\n            commands.push({command: operations.setLight, args: [after.light]});\n        }\n\n        // Handle changes to `sources`\n        // If a source is to be removed, we also--before the removeSource\n        // command--need to remove all the style layers that depend on it.\n        const sourcesRemoved = {};\n\n        // First collect the {add,remove}Source commands\n        const removeOrAddSourceCommands = [];\n        diffSources(before.sources, after.sources, removeOrAddSourceCommands, sourcesRemoved);\n\n        // Push a removeLayer command for each style layer that depends on a\n        // source that's being removed.\n        // Also, exclude any such layers them from the input to `diffLayers`\n        // below, so that diffLayers produces the appropriate `addLayers`\n        // command\n        const beforeLayers = [];\n        if (before.layers) {\n            before.layers.forEach((layer) => {\n                if (sourcesRemoved[layer.source]) {\n                    commands.push({command: operations.removeLayer, args: [layer.id]});\n                } else {\n                    beforeLayers.push(layer);\n                }\n            });\n        }\n        commands = commands.concat(removeOrAddSourceCommands);\n\n        // Handle changes to `layers`\n        diffLayers(beforeLayers, after.layers, commands);\n\n    } catch (e) {\n        // fall back to setStyle\n        console.warn('Unable to compute style diff:', e);\n        commands = [{command: operations.setStyle, args: [after]}];\n    }\n\n    return commands;\n}\n\nexport default diffStyles;\nexport {operations};\n","// @flow\n\n/**\n * GridIndex is a data structure for testing the intersection of\n * circles and rectangles in a 2d plane.\n * It is optimized for rapid insertion and querying.\n * GridIndex splits the plane into a set of \"cells\" and keeps track\n * of which geometries intersect with each cell. At query time,\n * full geometry comparisons are only done for items that share\n * at least one cell. As long as the geometries are relatively\n * uniformly distributed across the plane, this greatly reduces\n * the number of comparisons necessary.\n *\n * @private\n */\nclass GridIndex {\n    circleKeys: Array<any>;\n    boxKeys: Array<any>;\n    boxCells: Array<Array<number>>;\n    circleCells: Array<Array<number>>;\n    bboxes: Array<number>;\n    circles: Array<number>;\n    xCellCount: number;\n    yCellCount: number;\n    width: number;\n    height: number;\n    xScale: number;\n    yScale: number;\n    boxUid: number;\n    circleUid: number;\n\n    constructor (width: number, height: number, cellSize: number) {\n        const boxCells = this.boxCells = [];\n        const circleCells = this.circleCells = [];\n\n        // More cells -> fewer geometries to check per cell, but items tend\n        // to be split across more cells.\n        // Sweet spot allows most small items to fit in one cell\n        this.xCellCount = Math.ceil(width / cellSize);\n        this.yCellCount = Math.ceil(height / cellSize);\n\n        for (let i = 0; i < this.xCellCount * this.yCellCount; i++) {\n            boxCells.push([]);\n            circleCells.push([]);\n        }\n        this.circleKeys = [];\n        this.boxKeys = [];\n        this.bboxes = [];\n        this.circles = [];\n\n        this.width = width;\n        this.height = height;\n        this.xScale = this.xCellCount / width;\n        this.yScale = this.yCellCount / height;\n        this.boxUid = 0;\n        this.circleUid = 0;\n    }\n\n    keysLength() {\n        return this.boxKeys.length + this.circleKeys.length;\n    }\n\n    insert(key: any, x1: number, y1: number, x2: number, y2: number) {\n        this._forEachCell(x1, y1, x2, y2, this._insertBoxCell, this.boxUid++);\n        this.boxKeys.push(key);\n        this.bboxes.push(x1);\n        this.bboxes.push(y1);\n        this.bboxes.push(x2);\n        this.bboxes.push(y2);\n    }\n\n    insertCircle(key: any, x: number, y: number, radius: number) {\n        // Insert circle into grid for all cells in the circumscribing square\n        // It's more than necessary (by a factor of 4/PI), but fast to insert\n        this._forEachCell(x - radius, y - radius, x + radius, y + radius, this._insertCircleCell, this.circleUid++);\n        this.circleKeys.push(key);\n        this.circles.push(x);\n        this.circles.push(y);\n        this.circles.push(radius);\n    }\n\n    _insertBoxCell(x1: number, y1: number, x2: number, y2: number, cellIndex: number, uid: number) {\n        this.boxCells[cellIndex].push(uid);\n    }\n\n    _insertCircleCell(x1: number, y1: number, x2: number, y2: number, cellIndex: number, uid: number)  {\n        this.circleCells[cellIndex].push(uid);\n    }\n\n    _query(x1: number, y1: number, x2: number, y2: number, hitTest: boolean, predicate?: any) {\n        if (x2 < 0 || x1 > this.width || y2 < 0 || y1 > this.height) {\n            return hitTest ? false : [];\n        }\n        const result = [];\n        if (x1 <= 0 && y1 <= 0 && this.width <= x2 && this.height <= y2) {\n            if (hitTest) {\n                return true;\n            }\n            for (let boxUid = 0; boxUid < this.boxKeys.length; boxUid++) {\n                result.push({\n                    key: this.boxKeys[boxUid],\n                    x1: this.bboxes[boxUid * 4],\n                    y1: this.bboxes[boxUid * 4 + 1],\n                    x2: this.bboxes[boxUid * 4 + 2],\n                    y2: this.bboxes[boxUid * 4 + 3]\n                });\n            }\n            for (let circleUid = 0; circleUid < this.circleKeys.length; circleUid++) {\n                const x = this.circles[circleUid * 3];\n                const y = this.circles[circleUid * 3 + 1];\n                const radius = this.circles[circleUid * 3 + 2];\n                result.push({\n                    key: this.circleKeys[circleUid],\n                    x1: x - radius,\n                    y1: y - radius,\n                    x2: x + radius,\n                    y2: y + radius\n                });\n            }\n            return predicate ? result.filter(predicate) : result;\n        } else {\n            const queryArgs = {\n                hitTest,\n                seenUids: {box: {}, circle: {}}\n            };\n            this._forEachCell(x1, y1, x2, y2, this._queryCell, result, queryArgs, predicate);\n            return hitTest ? result.length > 0 : result;\n        }\n    }\n\n    _queryCircle(x: number, y: number, radius: number, hitTest: boolean, predicate?: any) {\n        // Insert circle into grid for all cells in the circumscribing square\n        // It's more than necessary (by a factor of 4/PI), but fast to insert\n        const x1 = x - radius;\n        const x2 = x + radius;\n        const y1 = y - radius;\n        const y2 = y + radius;\n        if (x2 < 0 || x1 > this.width || y2 < 0 || y1 > this.height) {\n            return hitTest ? false : [];\n        }\n\n        // Box query early exits if the bounding box is larger than the grid, but we don't do\n        // the equivalent calculation for circle queries because early exit is less likely\n        // and the calculation is more expensive\n        const result = [];\n        const queryArgs = {\n            hitTest,\n            circle: {x, y, radius},\n            seenUids: {box: {}, circle: {}}\n        };\n        this._forEachCell(x1, y1, x2, y2, this._queryCellCircle, result, queryArgs, predicate);\n        return hitTest ? result.length > 0 : result;\n    }\n\n    query(x1: number, y1: number, x2: number, y2: number, predicate?: any): Array<any> {\n        return (this._query(x1, y1, x2, y2, false, predicate): any);\n    }\n\n    hitTest(x1: number, y1: number, x2: number, y2: number, predicate?: any): boolean  {\n        return (this._query(x1, y1, x2, y2, true, predicate): any);\n    }\n\n    hitTestCircle(x: number, y: number, radius: number, predicate?: any): boolean {\n        return (this._queryCircle(x, y, radius, true, predicate): any);\n    }\n\n    _queryCell(x1: number, y1: number, x2: number, y2: number, cellIndex: number, result: any, queryArgs: any, predicate?: any) {\n        const seenUids = queryArgs.seenUids;\n        const boxCell = this.boxCells[cellIndex];\n        if (boxCell !== null) {\n            const bboxes = this.bboxes;\n            for (const boxUid of boxCell) {\n                if (!seenUids.box[boxUid]) {\n                    seenUids.box[boxUid] = true;\n                    const offset = boxUid * 4;\n                    if ((x1 <= bboxes[offset + 2]) &&\n                        (y1 <= bboxes[offset + 3]) &&\n                        (x2 >= bboxes[offset + 0]) &&\n                        (y2 >= bboxes[offset + 1]) &&\n                        (!predicate || predicate(this.boxKeys[boxUid]))) {\n                        if (queryArgs.hitTest) {\n                            result.push(true);\n                            return true;\n                        } else {\n                            result.push({\n                                key: this.boxKeys[boxUid],\n                                x1: bboxes[offset],\n                                y1: bboxes[offset + 1],\n                                x2: bboxes[offset + 2],\n                                y2: bboxes[offset + 3]\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        const circleCell = this.circleCells[cellIndex];\n        if (circleCell !== null) {\n            const circles = this.circles;\n            for (const circleUid of circleCell) {\n                if (!seenUids.circle[circleUid]) {\n                    seenUids.circle[circleUid] = true;\n                    const offset = circleUid * 3;\n                    if (this._circleAndRectCollide(\n                        circles[offset],\n                        circles[offset + 1],\n                        circles[offset + 2],\n                        x1,\n                        y1,\n                        x2,\n                        y2) &&\n                        (!predicate || predicate(this.circleKeys[circleUid]))) {\n                        if (queryArgs.hitTest) {\n                            result.push(true);\n                            return true;\n                        } else {\n                            const x = circles[offset];\n                            const y = circles[offset + 1];\n                            const radius = circles[offset + 2];\n                            result.push({\n                                key: this.circleKeys[circleUid],\n                                x1: x - radius,\n                                y1: y - radius,\n                                x2: x + radius,\n                                y2: y + radius\n                            });\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    _queryCellCircle(x1: number, y1: number, x2: number, y2: number, cellIndex: number, result: any, queryArgs: any, predicate?: any) {\n        const circle = queryArgs.circle;\n        const seenUids = queryArgs.seenUids;\n        const boxCell = this.boxCells[cellIndex];\n        if (boxCell !== null) {\n            const bboxes = this.bboxes;\n            for (const boxUid of boxCell) {\n                if (!seenUids.box[boxUid]) {\n                    seenUids.box[boxUid] = true;\n                    const offset = boxUid * 4;\n                    if (this._circleAndRectCollide(\n                        circle.x,\n                        circle.y,\n                        circle.radius,\n                        bboxes[offset + 0],\n                        bboxes[offset + 1],\n                        bboxes[offset + 2],\n                        bboxes[offset + 3]) &&\n                        (!predicate || predicate(this.boxKeys[boxUid]))) {\n                        result.push(true);\n                        return true;\n                    }\n                }\n            }\n        }\n\n        const circleCell = this.circleCells[cellIndex];\n        if (circleCell !== null) {\n            const circles = this.circles;\n            for (const circleUid of circleCell) {\n                if (!seenUids.circle[circleUid]) {\n                    seenUids.circle[circleUid] = true;\n                    const offset = circleUid * 3;\n                    if (this._circlesCollide(\n                        circles[offset],\n                        circles[offset + 1],\n                        circles[offset + 2],\n                        circle.x,\n                        circle.y,\n                        circle.radius) &&\n                        (!predicate || predicate(this.circleKeys[circleUid]))) {\n                        result.push(true);\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n\n    _forEachCell(x1: number, y1: number, x2: number, y2: number, fn: any, arg1: any, arg2?: any, predicate?: any) {\n        const cx1 = this._convertToXCellCoord(x1);\n        const cy1 = this._convertToYCellCoord(y1);\n        const cx2 = this._convertToXCellCoord(x2);\n        const cy2 = this._convertToYCellCoord(y2);\n\n        for (let x = cx1; x <= cx2; x++) {\n            for (let y = cy1; y <= cy2; y++) {\n                const cellIndex = this.xCellCount * y + x;\n                if (fn.call(this, x1, y1, x2, y2, cellIndex, arg1, arg2, predicate)) return;\n            }\n        }\n    }\n\n    _convertToXCellCoord(x: number) {\n        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(x * this.xScale)));\n    }\n\n    _convertToYCellCoord(y: number) {\n        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(y * this.yScale)));\n    }\n\n    _circlesCollide(x1: number, y1: number, r1: number, x2: number, y2: number, r2: number): boolean {\n        const dx = x2 - x1;\n        const dy = y2 - y1;\n        const bothRadii = r1 + r2;\n        return (bothRadii * bothRadii) > (dx * dx + dy * dy);\n    }\n\n    _circleAndRectCollide(circleX: number, circleY: number, radius: number, x1: number, y1: number, x2: number, y2: number): boolean {\n        const halfRectWidth = (x2 - x1) / 2;\n        const distX = Math.abs(circleX - (x1 + halfRectWidth));\n        if (distX > (halfRectWidth + radius)) {\n            return false;\n        }\n\n        const halfRectHeight = (y2 - y1) / 2;\n        const distY = Math.abs(circleY - (y1 + halfRectHeight));\n        if (distY > (halfRectHeight + radius)) {\n            return false;\n        }\n\n        if (distX <= halfRectWidth || distY <= halfRectHeight) {\n            return true;\n        }\n\n        const dx = distX - halfRectWidth;\n        const dy = distY - halfRectHeight;\n        return (dx * dx + dy * dy <= (radius * radius));\n    }\n}\n\nexport default GridIndex;\n","// @flow\n\nimport Point from '@mapbox/point-geometry';\n\nimport {mat4, vec4} from 'gl-matrix';\nimport * as symbolSize from './symbol_size';\nimport {addDynamicAttributes} from '../data/bucket/symbol_bucket';\n\nimport type Painter from '../render/painter';\nimport type Transform from '../geo/transform';\nimport type SymbolBucket from '../data/bucket/symbol_bucket';\nimport type {\n    GlyphOffsetArray,\n    SymbolLineVertexArray,\n    SymbolDynamicLayoutArray\n} from '../data/array_types';\nimport {WritingMode} from '../symbol/shaping';\n\nexport {updateLineLabels, hideGlyphs, getLabelPlaneMatrix, getGlCoordMatrix, project, placeFirstAndLastGlyph, xyTransformMat4};\n\n/*\n * # Overview of coordinate spaces\n *\n * ## Tile coordinate spaces\n * Each label has an anchor. Some labels have corresponding line geometries.\n * The points for both anchors and lines are stored in tile units. Each tile has it's own\n * coordinate space going from (0, 0) at the top left to (EXTENT, EXTENT) at the bottom right.\n *\n * ## GL coordinate space\n * At the end of everything, the vertex shader needs to produce a position in GL coordinate space,\n * which is (-1, 1) at the top left and (1, -1) in the bottom right.\n *\n * ## Map pixel coordinate spaces\n * Each tile has a pixel coordinate space. It's just the tile units scaled so that one unit is\n * whatever counts as 1 pixel at the current zoom.\n * This space is used for pitch-alignment=map, rotation-alignment=map\n *\n * ## Rotated map pixel coordinate spaces\n * Like the above, but rotated so axis of the space are aligned with the viewport instead of the tile.\n * This space is used for pitch-alignment=map, rotation-alignment=viewport\n *\n * ## Viewport pixel coordinate space\n * (0, 0) is at the top left of the canvas and (pixelWidth, pixelHeight) is at the bottom right corner\n * of the canvas. This space is used for pitch-alignment=viewport\n *\n *\n * # Vertex projection\n * It goes roughly like this:\n * 1. project the anchor and line from tile units into the correct label coordinate space\n *      - map pixel space           pitch-alignment=map         rotation-alignment=map\n *      - rotated map pixel space   pitch-alignment=map         rotation-alignment=viewport\n *      - viewport pixel space      pitch-alignment=viewport    rotation-alignment=*\n * 2. if the label follows a line, find the point along the line that is the correct distance from the anchor.\n * 3. add the glyph's corner offset to the point from step 3\n * 4. convert from the label coordinate space to gl coordinates\n *\n * For horizontal labels we want to do step 1 in the shader for performance reasons (no cpu work).\n *      This is what `u_label_plane_matrix` is used for.\n * For labels aligned with lines we have to steps 1 and 2 on the cpu since we need access to the line geometry.\n *      This is what `updateLineLabels(...)` does.\n *      Since the conversion is handled on the cpu we just set `u_label_plane_matrix` to an identity matrix.\n *\n * Steps 3 and 4 are done in the shaders for all labels.\n */\n\n/*\n * Returns a matrix for converting from tile units to the correct label coordinate space.\n */\nfunction getLabelPlaneMatrix(posMatrix: mat4,\n                             pitchWithMap: boolean,\n                             rotateWithMap: boolean,\n                             transform: Transform,\n                             pixelsToTileUnits: number) {\n    const m = mat4.create();\n    if (pitchWithMap) {\n        mat4.scale(m, m, [1 / pixelsToTileUnits, 1 / pixelsToTileUnits, 1]);\n        if (!rotateWithMap) {\n            mat4.rotateZ(m, m, transform.angle);\n        }\n    } else {\n        mat4.multiply(m, transform.labelPlaneMatrix, posMatrix);\n    }\n    return m;\n}\n\n/*\n * Returns a matrix for converting from the correct label coordinate space to gl coords.\n */\nfunction getGlCoordMatrix(posMatrix: mat4,\n                          pitchWithMap: boolean,\n                          rotateWithMap: boolean,\n                          transform: Transform,\n                          pixelsToTileUnits: number) {\n    if (pitchWithMap) {\n        const m = mat4.clone(posMatrix);\n        mat4.scale(m, m, [pixelsToTileUnits, pixelsToTileUnits, 1]);\n        if (!rotateWithMap) {\n            mat4.rotateZ(m, m, -transform.angle);\n        }\n        return m;\n    } else {\n        return transform.glCoordMatrix;\n    }\n}\n\nfunction project(point: Point, matrix: mat4) {\n    const pos = [point.x, point.y, 0, 1];\n    xyTransformMat4(pos, pos, matrix);\n    const w = pos[3];\n    return {\n        point: new Point(pos[0] / w, pos[1] / w),\n        signedDistanceFromCamera: w\n    };\n}\n\nfunction isVisible(anchorPos: [number, number, number, number],\n                   clippingBuffer: [number, number]) {\n    const x = anchorPos[0] / anchorPos[3];\n    const y = anchorPos[1] / anchorPos[3];\n    const inPaddedViewport = (\n        x >= -clippingBuffer[0] &&\n        x <= clippingBuffer[0] &&\n        y >= -clippingBuffer[1] &&\n        y <= clippingBuffer[1]);\n    return inPaddedViewport;\n}\n\n/*\n *  Update the `dynamicLayoutVertexBuffer` for the buffer with the correct glyph positions for the current map view.\n *  This is only run on labels that are aligned with lines. Horizontal labels are handled entirely in the shader.\n */\nfunction updateLineLabels(bucket: SymbolBucket,\n                          posMatrix: mat4,\n                          painter: Painter,\n                          isText: boolean,\n                          labelPlaneMatrix: mat4,\n                          glCoordMatrix: mat4,\n                          pitchWithMap: boolean,\n                          keepUpright: boolean) {\n\n    const sizeData = isText ? bucket.textSizeData : bucket.iconSizeData;\n    const partiallyEvaluatedSize = symbolSize.evaluateSizeForZoom(sizeData, painter.transform.zoom);\n\n    const clippingBuffer = [256 / painter.width * 2 + 1, 256 / painter.height * 2 + 1];\n\n    const dynamicLayoutVertexArray = isText ?\n        bucket.text.dynamicLayoutVertexArray :\n        bucket.icon.dynamicLayoutVertexArray;\n    dynamicLayoutVertexArray.clear();\n\n    const lineVertexArray = bucket.lineVertexArray;\n    const placedSymbols = isText ? bucket.text.placedSymbolArray : bucket.icon.placedSymbolArray;\n\n    const aspectRatio = painter.transform.width / painter.transform.height;\n\n    let useVertical = false;\n\n    for (let s = 0; s < placedSymbols.length; s++) {\n        const symbol: any = placedSymbols.get(s);\n        // Don't do calculations for vertical glyphs unless the previous symbol was horizontal\n        // and we determined that vertical glyphs were necessary.\n        // Also don't do calculations for symbols that are collided and fully faded out\n        if (symbol.hidden || symbol.writingMode === WritingMode.vertical && !useVertical) {\n            hideGlyphs(symbol.numGlyphs, dynamicLayoutVertexArray);\n            continue;\n        }\n        // Awkward... but we're counting on the paired \"vertical\" symbol coming immediately after its horizontal counterpart\n        useVertical = false;\n\n        const anchorPos = [symbol.anchorX, symbol.anchorY, 0, 1];\n        vec4.transformMat4(anchorPos, anchorPos, posMatrix);\n\n        // Don't bother calculating the correct point for invisible labels.\n        if (!isVisible(anchorPos, clippingBuffer)) {\n            hideGlyphs(symbol.numGlyphs, dynamicLayoutVertexArray);\n            continue;\n        }\n\n        const cameraToAnchorDistance = anchorPos[3];\n        const perspectiveRatio = 0.5 + 0.5 * (cameraToAnchorDistance / painter.transform.cameraToCenterDistance);\n\n        const fontSize = symbolSize.evaluateSizeForFeature(sizeData, partiallyEvaluatedSize, symbol);\n        const pitchScaledFontSize = pitchWithMap ?\n            fontSize * perspectiveRatio :\n            fontSize / perspectiveRatio;\n\n        const tileAnchorPoint = new Point(symbol.anchorX, symbol.anchorY);\n        const anchorPoint = project(tileAnchorPoint, labelPlaneMatrix).point;\n        const projectionCache = {};\n\n        const placeUnflipped: any = placeGlyphsAlongLine(symbol, pitchScaledFontSize, false /*unflipped*/, keepUpright, posMatrix, labelPlaneMatrix, glCoordMatrix,\n            bucket.glyphOffsetArray, lineVertexArray, dynamicLayoutVertexArray, anchorPoint, tileAnchorPoint, projectionCache, aspectRatio);\n\n        useVertical = placeUnflipped.useVertical;\n\n        if (placeUnflipped.notEnoughRoom || useVertical ||\n            (placeUnflipped.needsFlipping &&\n             placeGlyphsAlongLine(symbol, pitchScaledFontSize, true /*flipped*/, keepUpright, posMatrix, labelPlaneMatrix, glCoordMatrix,\n                 bucket.glyphOffsetArray, lineVertexArray, dynamicLayoutVertexArray, anchorPoint, tileAnchorPoint, projectionCache, aspectRatio).notEnoughRoom)) {\n            hideGlyphs(symbol.numGlyphs, dynamicLayoutVertexArray);\n        }\n    }\n\n    if (isText) {\n        bucket.text.dynamicLayoutVertexBuffer.updateData(dynamicLayoutVertexArray);\n    } else {\n        bucket.icon.dynamicLayoutVertexBuffer.updateData(dynamicLayoutVertexArray);\n    }\n}\n\nfunction placeFirstAndLastGlyph(fontScale: number, glyphOffsetArray: GlyphOffsetArray, lineOffsetX: number, lineOffsetY: number, flip: boolean, anchorPoint: Point, tileAnchorPoint: Point, symbol: any, lineVertexArray: SymbolLineVertexArray, labelPlaneMatrix: mat4, projectionCache: any, returnTileDistance: boolean) {\n    const glyphEndIndex = symbol.glyphStartIndex + symbol.numGlyphs;\n    const lineStartIndex = symbol.lineStartIndex;\n    const lineEndIndex = symbol.lineStartIndex + symbol.lineLength;\n\n    const firstGlyphOffset = glyphOffsetArray.getoffsetX(symbol.glyphStartIndex);\n    const lastGlyphOffset = glyphOffsetArray.getoffsetX(glyphEndIndex - 1);\n\n    const firstPlacedGlyph = placeGlyphAlongLine(fontScale * firstGlyphOffset, lineOffsetX, lineOffsetY, flip, anchorPoint, tileAnchorPoint, symbol.segment,\n        lineStartIndex, lineEndIndex, lineVertexArray, labelPlaneMatrix, projectionCache, returnTileDistance);\n    if (!firstPlacedGlyph)\n        return null;\n\n    const lastPlacedGlyph = placeGlyphAlongLine(fontScale * lastGlyphOffset, lineOffsetX, lineOffsetY, flip, anchorPoint, tileAnchorPoint, symbol.segment,\n        lineStartIndex, lineEndIndex, lineVertexArray, labelPlaneMatrix, projectionCache, returnTileDistance);\n    if (!lastPlacedGlyph)\n        return null;\n\n    return {first: firstPlacedGlyph, last: lastPlacedGlyph};\n}\n\nfunction requiresOrientationChange(writingMode, firstPoint, lastPoint, aspectRatio) {\n    if (writingMode === WritingMode.horizontal) {\n        // On top of choosing whether to flip, choose whether to render this version of the glyphs or the alternate\n        // vertical glyphs. We can't just filter out vertical glyphs in the horizontal range because the horizontal\n        // and vertical versions can have slightly different projections which could lead to angles where both or\n        // neither showed.\n        const rise = Math.abs(lastPoint.y - firstPoint.y);\n        const run = Math.abs(lastPoint.x - firstPoint.x) * aspectRatio;\n        if (rise > run) {\n            return {useVertical: true};\n        }\n    }\n\n    if (writingMode === WritingMode.vertical ? firstPoint.y < lastPoint.y : firstPoint.x > lastPoint.x) {\n        // Includes \"horizontalOnly\" case for labels without vertical glyphs\n        return {needsFlipping: true};\n    }\n\n    return null;\n}\n\nfunction placeGlyphsAlongLine(symbol, fontSize, flip, keepUpright, posMatrix, labelPlaneMatrix, glCoordMatrix, glyphOffsetArray, lineVertexArray, dynamicLayoutVertexArray, anchorPoint, tileAnchorPoint, projectionCache, aspectRatio) {\n    const fontScale = fontSize / 24;\n    const lineOffsetX = symbol.lineOffsetX * fontScale;\n    const lineOffsetY = symbol.lineOffsetY * fontScale;\n\n    let placedGlyphs;\n    if (symbol.numGlyphs > 1) {\n        const glyphEndIndex = symbol.glyphStartIndex + symbol.numGlyphs;\n        const lineStartIndex = symbol.lineStartIndex;\n        const lineEndIndex = symbol.lineStartIndex + symbol.lineLength;\n\n        // Place the first and the last glyph in the label first, so we can figure out\n        // the overall orientation of the label and determine whether it needs to be flipped in keepUpright mode\n        const firstAndLastGlyph = placeFirstAndLastGlyph(fontScale, glyphOffsetArray, lineOffsetX, lineOffsetY, flip, anchorPoint, tileAnchorPoint, symbol, lineVertexArray, labelPlaneMatrix, projectionCache, false);\n        if (!firstAndLastGlyph) {\n            return {notEnoughRoom: true};\n        }\n        const firstPoint = project(firstAndLastGlyph.first.point, glCoordMatrix).point;\n        const lastPoint = project(firstAndLastGlyph.last.point, glCoordMatrix).point;\n\n        if (keepUpright && !flip) {\n            const orientationChange = requiresOrientationChange(symbol.writingMode, firstPoint, lastPoint, aspectRatio);\n            if (orientationChange) {\n                return orientationChange;\n            }\n        }\n\n        placedGlyphs = [firstAndLastGlyph.first];\n        for (let glyphIndex = symbol.glyphStartIndex + 1; glyphIndex < glyphEndIndex - 1; glyphIndex++) {\n            // Since first and last glyph fit on the line, we're sure that the rest of the glyphs can be placed\n            // $FlowFixMe\n            placedGlyphs.push(placeGlyphAlongLine(fontScale * glyphOffsetArray.getoffsetX(glyphIndex), lineOffsetX, lineOffsetY, flip, anchorPoint, tileAnchorPoint, symbol.segment,\n                lineStartIndex, lineEndIndex, lineVertexArray, labelPlaneMatrix, projectionCache, false));\n        }\n        placedGlyphs.push(firstAndLastGlyph.last);\n    } else {\n        // Only a single glyph to place\n        // So, determine whether to flip based on projected angle of the line segment it's on\n        if (keepUpright && !flip) {\n            const a = project(tileAnchorPoint, posMatrix).point;\n            const tileVertexIndex = (symbol.lineStartIndex + symbol.segment + 1);\n            // $FlowFixMe\n            const tileSegmentEnd = new Point(lineVertexArray.getx(tileVertexIndex), lineVertexArray.gety(tileVertexIndex));\n            const projectedVertex = project(tileSegmentEnd, posMatrix);\n            // We know the anchor will be in the viewport, but the end of the line segment may be\n            // behind the plane of the camera, in which case we can use a point at any arbitrary (closer)\n            // point on the segment.\n            const b = (projectedVertex.signedDistanceFromCamera > 0) ?\n                projectedVertex.point :\n                projectTruncatedLineSegment(tileAnchorPoint, tileSegmentEnd, a, 1, posMatrix);\n\n            const orientationChange = requiresOrientationChange(symbol.writingMode, a, b, aspectRatio);\n            if (orientationChange) {\n                return orientationChange;\n            }\n        }\n        // $FlowFixMe\n        const singleGlyph = placeGlyphAlongLine(fontScale * glyphOffsetArray.getoffsetX(symbol.glyphStartIndex), lineOffsetX, lineOffsetY, flip, anchorPoint, tileAnchorPoint, symbol.segment,\n            symbol.lineStartIndex, symbol.lineStartIndex + symbol.lineLength, lineVertexArray, labelPlaneMatrix, projectionCache, false);\n        if (!singleGlyph)\n            return {notEnoughRoom: true};\n\n        placedGlyphs = [singleGlyph];\n    }\n\n    for (const glyph: any of placedGlyphs) {\n        addDynamicAttributes(dynamicLayoutVertexArray, glyph.point, glyph.angle);\n    }\n    return {};\n}\n\nfunction projectTruncatedLineSegment(previousTilePoint: Point, currentTilePoint: Point, previousProjectedPoint: Point, minimumLength: number, projectionMatrix: mat4) {\n    // We are assuming \"previousTilePoint\" won't project to a point within one unit of the camera plane\n    // If it did, that would mean our label extended all the way out from within the viewport to a (very distant)\n    // point near the plane of the camera. We wouldn't be able to render the label anyway once it crossed the\n    // plane of the camera.\n    const projectedUnitVertex = project(previousTilePoint.add(previousTilePoint.sub(currentTilePoint)._unit()), projectionMatrix).point;\n    const projectedUnitSegment = previousProjectedPoint.sub(projectedUnitVertex);\n\n    return previousProjectedPoint.add(projectedUnitSegment._mult(minimumLength / projectedUnitSegment.mag()));\n}\n\nfunction placeGlyphAlongLine(offsetX: number,\n                             lineOffsetX: number,\n                             lineOffsetY: number,\n                             flip: boolean,\n                             anchorPoint: Point,\n                             tileAnchorPoint: Point,\n                             anchorSegment: number,\n                             lineStartIndex: number,\n                             lineEndIndex: number,\n                             lineVertexArray: SymbolLineVertexArray,\n                             labelPlaneMatrix: mat4,\n                             projectionCache: {[number]: Point},\n                             returnTileDistance: boolean) {\n\n    const combinedOffsetX = flip ?\n        offsetX - lineOffsetX :\n        offsetX + lineOffsetX;\n\n    let dir = combinedOffsetX > 0 ? 1 : -1;\n\n    let angle = 0;\n    if (flip) {\n        // The label needs to be flipped to keep text upright.\n        // Iterate in the reverse direction.\n        dir *= -1;\n        angle = Math.PI;\n    }\n\n    if (dir < 0) angle += Math.PI;\n\n    let currentIndex = dir > 0 ?\n        lineStartIndex + anchorSegment :\n        lineStartIndex + anchorSegment + 1;\n\n    const initialIndex = currentIndex;\n    let current = anchorPoint;\n    let prev = anchorPoint;\n    let distanceToPrev = 0;\n    let currentSegmentDistance = 0;\n    const absOffsetX = Math.abs(combinedOffsetX);\n\n    while (distanceToPrev + currentSegmentDistance <= absOffsetX) {\n        currentIndex += dir;\n\n        // offset does not fit on the projected line\n        if (currentIndex < lineStartIndex || currentIndex >= lineEndIndex)\n            return null;\n\n        prev = current;\n\n        current = projectionCache[currentIndex];\n        if (current === undefined) {\n            const currentVertex = new Point(lineVertexArray.getx(currentIndex), lineVertexArray.gety(currentIndex));\n            const projection = project(currentVertex, labelPlaneMatrix);\n            if (projection.signedDistanceFromCamera > 0) {\n                current = projectionCache[currentIndex] = projection.point;\n            } else {\n                // The vertex is behind the plane of the camera, so we can't project it\n                // Instead, we'll create a vertex along the line that's far enough to include the glyph\n                const previousLineVertexIndex = currentIndex - dir;\n                const previousTilePoint = distanceToPrev === 0 ?\n                    tileAnchorPoint :\n                    new Point(lineVertexArray.getx(previousLineVertexIndex), lineVertexArray.gety(previousLineVertexIndex));\n                // Don't cache because the new vertex might not be far enough out for future glyphs on the same segment\n                current = projectTruncatedLineSegment(previousTilePoint, currentVertex, prev, absOffsetX - distanceToPrev + 1, labelPlaneMatrix);\n            }\n        }\n\n        distanceToPrev += currentSegmentDistance;\n        currentSegmentDistance = prev.dist(current);\n    }\n\n    // The point is on the current segment. Interpolate to find it.\n    const segmentInterpolationT = (absOffsetX - distanceToPrev) / currentSegmentDistance;\n    const prevToCurrent = current.sub(prev);\n    const p = prevToCurrent.mult(segmentInterpolationT)._add(prev);\n\n    // offset the point from the line to text-offset and icon-offset\n    p._add(prevToCurrent._unit()._perp()._mult(lineOffsetY * dir));\n\n    const segmentAngle = angle + Math.atan2(current.y - prev.y, current.x - prev.x);\n\n    return {\n        point: p,\n        angle: segmentAngle,\n        tileDistance: returnTileDistance ?\n            {\n                prevTileDistance: (currentIndex - dir) === initialIndex ? 0 : lineVertexArray.gettileUnitDistanceFromAnchor(currentIndex - dir),\n                lastSegmentViewportDistance: absOffsetX - distanceToPrev\n            } : null\n    };\n}\n\nconst hiddenGlyphAttributes = new Float32Array([-Infinity, -Infinity, 0, -Infinity, -Infinity, 0, -Infinity, -Infinity, 0, -Infinity, -Infinity, 0]);\n\n// Hide them by moving them offscreen. We still need to add them to the buffer\n// because the dynamic buffer is paired with a static buffer that doesn't get updated.\nfunction hideGlyphs(num: number, dynamicLayoutVertexArray: SymbolDynamicLayoutArray) {\n    for (let i = 0; i < num; i++) {\n        const offset = dynamicLayoutVertexArray.length;\n        dynamicLayoutVertexArray.resize(offset + 4);\n        // Since all hidden glyphs have the same attributes, we can build up the array faster with a single call to Float32Array.set\n        // for each set of four vertices, instead of calling addDynamicAttributes for each vertex.\n        dynamicLayoutVertexArray.float32.set(hiddenGlyphAttributes, offset * 3);\n    }\n}\n\n// For line label layout, we're not using z output and our w input is always 1\n// This custom matrix transformation ignores those components to make projection faster\nfunction xyTransformMat4(out: vec4, a: vec4, m: mat4) {\n    const x = a[0], y = a[1];\n    out[0] = m[0] * x + m[4] * y + m[12];\n    out[1] = m[1] * x + m[5] * y + m[13];\n    out[3] = m[3] * x + m[7] * y + m[15];\n    return out;\n}\n","// @flow\n\nimport {mat4} from 'gl-matrix';\nimport EXTENT from '../data/extent';\nimport {PosArray} from '../data/array_types';\nimport {LineIndexArray} from '../data/index_array_type';\nimport posAttributes from '../data/pos_attributes';\nimport SegmentVector from '../data/segment';\nimport DepthMode from '../gl/depth_mode';\nimport StencilMode from '../gl/stencil_mode';\nimport CullFaceMode from '../gl/cull_face_mode';\nimport {debugUniformValues} from './program/debug_program';\nimport Color from '../style-spec/util/color';\n\nimport type Painter from './painter';\nimport type SourceCache from '../source/source_cache';\nimport type {OverscaledTileID} from '../source/tile_id';\n\nexport default drawDebug;\n\nfunction drawDebug(painter: Painter, sourceCache: SourceCache, coords: Array<OverscaledTileID>) {\n    for (let i = 0; i < coords.length; i++) {\n        drawDebugTile(painter, sourceCache, coords[i]);\n    }\n}\n\nfunction drawDebugTile(painter, sourceCache, coord) {\n    const context = painter.context;\n    const gl = context.gl;\n\n    const posMatrix = coord.posMatrix;\n    const program = painter.useProgram('debug');\n\n    const depthMode = DepthMode.disabled;\n    const stencilMode = StencilMode.disabled;\n    const colorMode = painter.colorModeForRenderPass();\n    const id = '$debug';\n\n    program.draw(context, gl.LINE_STRIP, depthMode, stencilMode, colorMode, CullFaceMode.disabled,\n        debugUniformValues(posMatrix, Color.red), id,\n        painter.debugBuffer, painter.tileBorderIndexBuffer, painter.debugSegments);\n\n    const tileRawData = sourceCache.getTileByID(coord.key).latestRawTileData;\n    const tileByteLength = (tileRawData && tileRawData.byteLength) || 0;\n    const tileSizeKb = Math.floor(tileByteLength / 1024);\n    const tileSize = sourceCache.getTile(coord).tileSize;\n    const scaleRatio = 512 / Math.min(tileSize, 512);\n    const vertices = createTextVertices(`${coord.toString()} ${tileSizeKb}kb`, 50, 200 * scaleRatio, 5 * scaleRatio);\n    const debugTextArray = new PosArray();\n    const debugTextIndices = new LineIndexArray();\n    for (let v = 0; v < vertices.length; v += 2) {\n        debugTextArray.emplaceBack(vertices[v], vertices[v + 1]);\n        debugTextIndices.emplaceBack(v, v + 1);\n    }\n    const debugTextBuffer = context.createVertexBuffer(debugTextArray, posAttributes.members);\n    const debugTextIndexBuffer = context.createIndexBuffer(debugTextIndices);\n    const debugTextSegment = SegmentVector.simpleSegment(0, 0, debugTextArray.length / 2, debugTextArray.length / 2);\n\n    // Draw the halo with multiple 1px lines instead of one wider line because\n    // the gl spec doesn't guarantee support for lines with width > 1.\n    const onePixel = EXTENT / (Math.pow(2, painter.transform.zoom - coord.overscaledZ) * tileSize * scaleRatio);\n\n    const haloWidth = 1;\n    const translations = [];\n    for (let x = -haloWidth; x <= haloWidth; x++) {\n        for (let y = -haloWidth; y <= haloWidth; y++) {\n            if (x === 0 && y === 0) {\n                // don't draw the halo at 0,0 since the text is drawn there\n                break;\n            }\n\n            translations.push([x, y]);\n        }\n    }\n\n    for (let i = 0; i < translations.length; i++) {\n        const translation = translations[i];\n\n        program.draw(context, gl.LINES, depthMode, stencilMode, colorMode, CullFaceMode.disabled,\n            debugUniformValues(\n                mat4.translate([], posMatrix, [\n                    onePixel * translation[0],\n                    onePixel * translation[1], 0]),\n                Color.white),\n            id, debugTextBuffer, debugTextIndexBuffer, debugTextSegment);\n    }\n\n    program.draw(context, gl.LINES, depthMode, stencilMode, colorMode, CullFaceMode.disabled,\n        debugUniformValues(posMatrix, Color.black), id,\n        debugTextBuffer, debugTextIndexBuffer, debugTextSegment);\n\n    debugTextBuffer.destroy();\n    debugTextIndexBuffer.destroy();\n    debugTextSegment.destroy();\n}\n\n// Font data From Hershey Simplex Font\n// http://paulbourke.net/dataformats/hershey/\nconst simplexFont = {\n    \" \": [16, []],\n    \"!\": [10, [5, 21, 5, 7, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],\n    \"\\\"\": [16, [4, 21, 4, 14, -1, -1, 12, 21, 12, 14]],\n    \"#\": [21, [11, 25, 4, -7, -1, -1, 17, 25, 10, -7, -1, -1, 4, 12, 18, 12, -1, -1, 3, 6, 17, 6]],\n    \"$\": [20, [8, 25, 8, -4, -1, -1, 12, 25, 12, -4, -1, -1, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],\n    \"%\": [24, [21, 21, 3, 0, -1, -1, 8, 21, 10, 19, 10, 17, 9, 15, 7, 14, 5, 14, 3, 16, 3, 18, 4, 20, 6, 21, 8, 21, 10, 20, 13, 19, 16, 19, 19, 20, 21, 21, -1, -1, 17, 7, 15, 6, 14, 4, 14, 2, 16, 0, 18, 0, 20, 1, 21, 3, 21, 5, 19, 7, 17, 7]],\n    \"&\": [26, [23, 12, 23, 13, 22, 14, 21, 14, 20, 13, 19, 11, 17, 6, 15, 3, 13, 1, 11, 0, 7, 0, 5, 1, 4, 2, 3, 4, 3, 6, 4, 8, 5, 9, 12, 13, 13, 14, 14, 16, 14, 18, 13, 20, 11, 21, 9, 20, 8, 18, 8, 16, 9, 13, 11, 10, 16, 3, 18, 1, 20, 0, 22, 0, 23, 1, 23, 2]],\n    \"'\": [10, [5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15]],\n    \"(\": [14, [11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, -2, 9, -5, 11, -7]],\n    \")\": [14, [3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, -2, 5, -5, 3, -7]],\n    \"*\": [16, [8, 21, 8, 9, -1, -1, 3, 18, 13, 12, -1, -1, 13, 18, 3, 12]],\n    \"+\": [26, [13, 18, 13, 0, -1, -1, 4, 9, 22, 9]],\n    \",\": [10, [6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],\n    \"-\": [26, [4, 9, 22, 9]],\n    \".\": [10, [5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],\n    \"/\": [22, [20, 25, 2, -7]],\n    \"0\": [20, [9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12, 16, 17, 14, 20, 11, 21, 9, 21]],\n    \"1\": [20, [6, 17, 8, 18, 11, 21, 11, 0]],\n    \"2\": [20, [4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0]],\n    \"3\": [20, [5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],\n    \"4\": [20, [13, 21, 3, 7, 18, 7, -1, -1, 13, 21, 13, 0]],\n    \"5\": [20, [15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],\n    \"6\": [20, [16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14, 1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7]],\n    \"7\": [20, [17, 21, 7, 0, -1, -1, 3, 21, 17, 21]],\n    \"8\": [20, [8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15, 1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16, 18, 15, 20, 12, 21, 8, 21]],\n    \"9\": [20, [16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10, 21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3]],\n    \":\": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],\n    \";\": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],\n    \"<\": [24, [20, 18, 4, 9, 20, 0]],\n    \"=\": [26, [4, 12, 22, 12, -1, -1, 4, 6, 22, 6]],\n    \">\": [24, [4, 18, 20, 9, 4, 0]],\n    \"?\": [18, [3, 16, 3, 17, 4, 19, 5, 20, 7, 21, 11, 21, 13, 20, 14, 19, 15, 17, 15, 15, 14, 13, 13, 12, 9, 10, 9, 7, -1, -1, 9, 2, 8, 1, 9, 0, 10, 1, 9, 2]],\n    \"@\": [27, [18, 13, 17, 15, 15, 16, 12, 16, 10, 15, 9, 14, 8, 11, 8, 8, 9, 6, 11, 5, 14, 5, 16, 6, 17, 8, -1, -1, 12, 16, 10, 14, 9, 11, 9, 8, 10, 6, 11, 5, -1, -1, 18, 16, 17, 8, 17, 6, 19, 5, 21, 5, 23, 7, 24, 10, 24, 12, 23, 15, 22, 17, 20, 19, 18, 20, 15, 21, 12, 21, 9, 20, 7, 19, 5, 17, 4, 15, 3, 12, 3, 9, 4, 6, 5, 4, 7, 2, 9, 1, 12, 0, 15, 0, 18, 1, 20, 2, 21, 3, -1, -1, 19, 16, 18, 8, 18, 6, 19, 5]],\n    \"A\": [18, [9, 21, 1, 0, -1, -1, 9, 21, 17, 0, -1, -1, 4, 7, 14, 7]],\n    \"B\": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, -1, -1, 4, 11, 13, 11, 16, 10, 17, 9, 18, 7, 18, 4, 17, 2, 16, 1, 13, 0, 4, 0]],\n    \"C\": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5]],\n    \"D\": [21, [4, 21, 4, 0, -1, -1, 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0]],\n    \"E\": [19, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11, -1, -1, 4, 0, 17, 0]],\n    \"F\": [18, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11]],\n    \"G\": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 18, 8, -1, -1, 13, 8, 18, 8]],\n    \"H\": [22, [4, 21, 4, 0, -1, -1, 18, 21, 18, 0, -1, -1, 4, 11, 18, 11]],\n    \"I\": [8, [4, 21, 4, 0]],\n    \"J\": [16, [12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7]],\n    \"K\": [21, [4, 21, 4, 0, -1, -1, 18, 21, 4, 7, -1, -1, 9, 12, 18, 0]],\n    \"L\": [17, [4, 21, 4, 0, -1, -1, 4, 0, 16, 0]],\n    \"M\": [24, [4, 21, 4, 0, -1, -1, 4, 21, 12, 0, -1, -1, 20, 21, 12, 0, -1, -1, 20, 21, 20, 0]],\n    \"N\": [22, [4, 21, 4, 0, -1, -1, 4, 21, 18, 0, -1, -1, 18, 21, 18, 0]],\n    \"O\": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21]],\n    \"P\": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10]],\n    \"Q\": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, -1, -1, 12, 4, 18, -2]],\n    \"R\": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, 4, 11, -1, -1, 11, 11, 18, 0]],\n    \"S\": [20, [17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],\n    \"T\": [16, [8, 21, 8, 0, -1, -1, 1, 21, 15, 21]],\n    \"U\": [22, [4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21]],\n    \"V\": [18, [1, 21, 9, 0, -1, -1, 17, 21, 9, 0]],\n    \"W\": [24, [2, 21, 7, 0, -1, -1, 12, 21, 7, 0, -1, -1, 12, 21, 17, 0, -1, -1, 22, 21, 17, 0]],\n    \"X\": [20, [3, 21, 17, 0, -1, -1, 17, 21, 3, 0]],\n    \"Y\": [18, [1, 21, 9, 11, 9, 0, -1, -1, 17, 21, 9, 11]],\n    \"Z\": [20, [17, 21, 3, 0, -1, -1, 3, 21, 17, 21, -1, -1, 3, 0, 17, 0]],\n    \"[\": [14, [4, 25, 4, -7, -1, -1, 5, 25, 5, -7, -1, -1, 4, 25, 11, 25, -1, -1, 4, -7, 11, -7]],\n    \"\\\\\": [14, [0, 21, 14, -3]],\n    \"]\": [14, [9, 25, 9, -7, -1, -1, 10, 25, 10, -7, -1, -1, 3, 25, 10, 25, -1, -1, 3, -7, 10, -7]],\n    \"^\": [16, [6, 15, 8, 18, 10, 15, -1, -1, 3, 12, 8, 17, 13, 12, -1, -1, 8, 17, 8, 0]],\n    \"_\": [16, [0, -2, 16, -2]],\n    \"`\": [10, [6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17]],\n    \"a\": [19, [15, 14, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"b\": [19, [4, 21, 4, 0, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],\n    \"c\": [18, [15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"d\": [19, [15, 21, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"e\": [18, [3, 8, 15, 8, 15, 10, 14, 12, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"f\": [12, [10, 21, 8, 21, 6, 20, 5, 17, 5, 0, -1, -1, 2, 14, 9, 14]],\n    \"g\": [19, [15, 14, 15, -2, 14, -5, 13, -6, 11, -7, 8, -7, 6, -6, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"h\": [19, [4, 21, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],\n    \"i\": [8, [3, 21, 4, 20, 5, 21, 4, 22, 3, 21, -1, -1, 4, 14, 4, 0]],\n    \"j\": [10, [5, 21, 6, 20, 7, 21, 6, 22, 5, 21, -1, -1, 6, 14, 6, -3, 5, -6, 3, -7, 1, -7]],\n    \"k\": [17, [4, 21, 4, 0, -1, -1, 14, 14, 4, 4, -1, -1, 8, 8, 15, 0]],\n    \"l\": [8, [4, 21, 4, 0]],\n    \"m\": [30, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, -1, -1, 15, 10, 18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0]],\n    \"n\": [19, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],\n    \"o\": [19, [8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3, 16, 6, 16, 8, 15, 11, 13, 13, 11, 14, 8, 14]],\n    \"p\": [19, [4, 14, 4, -7, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],\n    \"q\": [19, [15, 14, 15, -7, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"r\": [13, [4, 14, 4, 0, -1, -1, 4, 8, 5, 11, 7, 13, 9, 14, 12, 14]],\n    \"s\": [17, [14, 11, 13, 13, 10, 14, 7, 14, 4, 13, 3, 11, 4, 9, 6, 8, 11, 7, 13, 6, 14, 4, 14, 3, 13, 1, 10, 0, 7, 0, 4, 1, 3, 3]],\n    \"t\": [12, [5, 21, 5, 4, 6, 1, 8, 0, 10, 0, -1, -1, 2, 14, 9, 14]],\n    \"u\": [19, [4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, -1, -1, 15, 14, 15, 0]],\n    \"v\": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0]],\n    \"w\": [22, [3, 14, 7, 0, -1, -1, 11, 14, 7, 0, -1, -1, 11, 14, 15, 0, -1, -1, 19, 14, 15, 0]],\n    \"x\": [17, [3, 14, 14, 0, -1, -1, 14, 14, 3, 0]],\n    \"y\": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7]],\n    \"z\": [17, [14, 14, 3, 0, -1, -1, 3, 14, 14, 14, -1, -1, 3, 0, 14, 0]],\n    \"{\": [14, [9, 25, 7, 24, 6, 23, 5, 21, 5, 19, 6, 17, 7, 16, 8, 14, 8, 12, 6, 10, -1, -1, 7, 24, 6, 22, 6, 20, 7, 18, 8, 17, 9, 15, 9, 13, 8, 11, 4, 9, 8, 7, 9, 5, 9, 3, 8, 1, 7, 0, 6, -2, 6, -4, 7, -6, -1, -1, 6, 8, 8, 6, 8, 4, 7, 2, 6, 1, 5, -1, 5, -3, 6, -5, 7, -6, 9, -7]],\n    \"|\": [8, [4, 25, 4, -7]],\n    \"}\": [14, [5, 25, 7, 24, 8, 23, 9, 21, 9, 19, 8, 17, 7, 16, 6, 14, 6, 12, 8, 10, -1, -1, 7, 24, 8, 22, 8, 20, 7, 18, 6, 17, 5, 15, 5, 13, 6, 11, 10, 9, 6, 7, 5, 5, 5, 3, 6, 1, 7, 0, 8, -2, 8, -4, 7, -6, -1, -1, 8, 8, 6, 6, 6, 4, 7, 2, 8, 1, 9, -1, 9, -3, 8, -5, 7, -6, 5, -7]],\n    \"~\": [24, [3, 6, 3, 8, 4, 11, 6, 12, 8, 12, 10, 11, 14, 8, 16, 7, 18, 7, 20, 8, 21, 10, -1, -1, 3, 8, 4, 10, 6, 11, 8, 11, 10, 10, 14, 7, 16, 6, 18, 6, 20, 7, 21, 10, 21, 12]]\n};\n\nfunction createTextVertices(text, left, baseline, scale) {\n    scale = scale || 1;\n\n    const strokes = [];\n    let i, len, j, len2, glyph, x, y, prev;\n\n    for (i = 0, len = text.length; i < len; i++) {\n        glyph = simplexFont[text[i]];\n        if (!glyph) continue;\n        prev = null;\n\n        for (j = 0, len2 = glyph[1].length; j < len2; j += 2) {\n            if (glyph[1][j] === -1 && glyph[1][j + 1] === -1) {\n                prev = null;\n\n            } else {\n                x = left + glyph[1][j] * scale;\n                y = baseline - glyph[1][j + 1] * scale;\n                if (prev) {\n                    strokes.push(prev.x, prev.y, x, y);\n                }\n                prev = {x, y};\n            }\n        }\n        left += glyph[0] * scale;\n    }\n\n    return strokes;\n}\n","// @flow\n\nimport {\n    bindAll,\n    extend,\n    deepEqual,\n    warnOnce,\n    clamp,\n    wrap,\n    ease as defaultEasing,\n    pick\n} from '../util/util';\nimport {number as interpolate} from '../style-spec/util/interpolate';\nimport browser from '../util/browser';\nimport LngLat from '../geo/lng_lat';\nimport LngLatBounds from '../geo/lng_lat_bounds';\nimport Point from '@mapbox/point-geometry';\nimport {Event, Evented} from '../util/evented';\n\nimport type Transform from '../geo/transform';\nimport type {LngLatLike} from '../geo/lng_lat';\nimport type {LngLatBoundsLike} from '../geo/lng_lat_bounds';\nimport type {TaskID} from '../util/task_queue';\nimport type {PointLike} from '@mapbox/point-geometry';\n\n/**\n * Options common to {@link Map#jumpTo}, {@link Map#easeTo}, and {@link Map#flyTo}, controlling the desired location,\n * zoom, bearing, and pitch of the camera. All properties are optional, and when a property is omitted, the current\n * camera value for that property will remain unchanged.\n *\n * @typedef {Object} CameraOptions\n * @property {LngLatLike} center The desired center.\n * @property {number} zoom The desired zoom level.\n * @property {number} bearing The desired bearing, in degrees. The bearing is the compass direction that\n * is \"up\"; for example, a bearing of 90Â° orients the map so that east is up.\n * @property {number} pitch The desired pitch, in degrees.\n * @property {LngLatLike} around If `zoom` is specified, `around` determines the point around which the zoom is centered.\n */\nexport type CameraOptions = {\n    center?: LngLatLike,\n    zoom?: number,\n    bearing?: number,\n    pitch?: number,\n    around?: LngLatLike\n};\n\n/**\n * Options common to map movement methods that involve animation, such as {@link Map#panBy} and\n * {@link Map#easeTo}, controlling the duration and easing function of the animation. All properties\n * are optional.\n *\n * @typedef {Object} AnimationOptions\n * @property {number} duration The animation's duration, measured in milliseconds.\n * @property {Function} easing A function taking a time in the range 0..1 and returning a number where 0 is\n *   the initial state and 1 is the final state.\n * @property {PointLike} offset of the target center relative to real map container center at the end of animation.\n * @property {boolean} animate If `false`, no animation will occur.\n */\nexport type AnimationOptions = {\n    duration?: number,\n    easing?: (number) => number,\n    offset?: PointLike,\n    animate?: boolean\n};\n\n/**\n * Options for setting padding on a call to {@link Map#fitBounds}. All properties of this object must be\n * non-negative integers.\n *\n * @typedef {Object} PaddingOptions\n * @property {number} top Padding in pixels from the top of the map canvas.\n * @property {number} bottom Padding in pixels from the bottom of the map canvas.\n * @property {number} left Padding in pixels from the left of the map canvas.\n * @property {number} right Padding in pixels from the right of the map canvas.\n */\n\nclass Camera extends Evented {\n    transform: Transform;\n    _moving: boolean;\n    _zooming: boolean;\n    _rotating: boolean;\n    _pitching: boolean;\n\n    _bearingSnap: number;\n    _easeEndTimeoutID: TimeoutID;\n    _easeStart: number;\n    _easeOptions: {duration: number, easing: (number) => number};\n\n    _onEaseFrame: (number) => void;\n    _onEaseEnd: () => void;\n    _easeFrameId: ?TaskID;\n\n    +_requestRenderFrame: (() => void) => TaskID;\n    +_cancelRenderFrame: (TaskID) => void;\n\n    constructor(transform: Transform, options: {bearingSnap: number}) {\n        super();\n        this._moving = false;\n        this._zooming = false;\n        this.transform = transform;\n        this._bearingSnap = options.bearingSnap;\n\n        bindAll(['_renderFrameCallback'], this);\n    }\n\n    /**\n     * Returns the map's geographical centerpoint.\n     *\n     * @memberof Map#\n     * @returns The map's geographical centerpoint.\n     */\n    getCenter(): LngLat { return new LngLat(this.transform.center.lng, this.transform.center.lat); }\n\n    /**\n     * Sets the map's geographical centerpoint. Equivalent to `jumpTo({center: center})`.\n     *\n     * @memberof Map#\n     * @param center The centerpoint to set.\n     * @param eventData Additional properties to be added to event objects of events triggered by this method.\n     * @fires movestart\n     * @fires moveend\n     * @returns {Map} `this`\n     * @example\n     * map.setCenter([-74, 38]);\n     */\n    setCenter(center: LngLatLike, eventData?: Object) {\n        return this.jumpTo({center}, eventData);\n    }\n\n    /**\n     * Pans the map by the specified offset.\n     *\n     * @memberof Map#\n     * @param offset `x` and `y` coordinates by which to pan the map.\n     * @param options\n     * @param eventData Additional properties to be added to event objects of events triggered by this method.\n     * @fires movestart\n     * @fires moveend\n     * @returns {Map} `this`\n     * @see [Navigate the map with game-like controls](https://www.mapbox.com/mapbox-gl-js/example/game-controls/)\n     */\n    panBy(offset: PointLike, options?: AnimationOptions, eventData?: Object) {\n        offset = Point.convert(offset).mult(-1);\n        return this.panTo(this.transform.center, extend({offset}, options), eventData);\n    }\n\n    /**\n     * Pans the map to the specified location, with an animated transition.\n     *\n     * @memberof Map#\n     * @param lnglat The location to pan the map to.\n     * @param options\n     * @param eventData Additional properties to be added to event objects of events triggered by this method.\n     * @fires movestart\n     * @fires moveend\n     * @returns {Map} `this`\n     */\n    panTo(lnglat: LngLatLike, options?: AnimationOptions, eventData?: Object) {\n        return this.easeTo(extend({\n            center: lnglat\n        }, options), eventData);\n    }\n\n    /**\n     * Returns the map's current zoom level.\n     *\n     * @memberof Map#\n     * @returns The map's current zoom level.\n     */\n    getZoom(): number { return this.transform.zoom; }\n\n    /**\n     * Sets the map's zoom level. Equivalent to `jumpTo({zoom: zoom})`.\n     *\n     * @memberof Map#\n     * @param zoom The zoom level to set (0-20).\n     * @param eventData Additional properties to be added to event objects of events triggered by this method.\n     * @fires movestart\n     * @fires zoomstart\n     * @fires move\n     * @fires zoom\n     * @fires moveend\n     * @fires zoomend\n     * @returns {Map} `this`\n     * @example\n     * // zoom the map to 5\n     * map.setZoom(5);\n     */\n    setZoom(zoom: number, eventData?: Object) {\n        this.jumpTo({zoom}, eventData);\n        return this;\n    }\n\n    /**\n     * Zooms the map to the specified zoom level, with an animated transition.\n     *\n     * @memberof Map#\n     * @param zoom The zoom level to transition to.\n     * @param options\n     * @param eventData Additional properties to be added to event objects of events triggered by this method.\n     * @fires movestart\n     * @fires zoomstart\n     * @fires move\n     * @fires zoom\n     * @fires moveend\n     * @fires zoomend\n     * @returns {Map} `this`\n     */\n    zoomTo(zoom: number, options: ? AnimationOptions, eventData?: Object) {\n        return this.easeTo(extend({\n            zoom\n        }, options), eventData);\n    }\n\n    /**\n     * Increases the map's zoom level by 1.\n     *\n     * @memberof Map#\n     * @param options\n     * @param eventData Additional properties to be added to event objects of events triggered by this method.\n     * @fires movestart\n     * @fires zoomstart\n     * @fires move\n     * @fires zoom\n     * @fires moveend\n     * @fires zoomend\n     * @returns {Map} `this`\n     */\n    zoomIn(options?: AnimationOptions, eventData?: Object) {\n        this.zoomTo(this.getZoom() + 1, options, eventData);\n        return this;\n    }\n\n    /**\n     * Decreases the map's zoom level by 1.\n     *\n     * @memberof Map#\n     * @param options\n     * @param eventData Additional properties to be added to event objects of events triggered by this method.\n     * @fires movestart\n     * @fires zoomstart\n     * @fires move\n     * @fires zoom\n     * @fires moveend\n     * @fires zoomend\n     * @returns {Map} `this`\n     */\n    zoomOut(options?: AnimationOptions, eventData?: Object) {\n        this.zoomTo(this.getZoom() - 1, options, eventData);\n        return this;\n    }\n\n    /**\n     * Returns the map's current bearing. The bearing is the compass direction that is \\\"up\\\"; for example, a bearing\n     * of 90Â° orients the map so that east is up.\n     *\n     * @memberof Map#\n     * @returns The map's current bearing.\n     * @see [Navigate the map with game-like controls](https://www.mapbox.com/mapbox-gl-js/example/game-controls/)\n     */\n    getBearing(): number { return this.transform.bearing; }\n\n    /**\n     * Sets the map's bearing (rotation). The bearing is the compass direction that is \\\"up\\\"; for example, a bearing\n     * of 90Â° orients the map so that east is up.\n     *\n     * Equivalent to `jumpTo({bearing: bearing})`.\n     *\n     * @memberof Map#\n     * @param bearing The desired bearing.\n     * @param eventData Additional properties to be added to event objects of events triggered by this method.\n     * @fires movestart\n     * @fires moveend\n     * @returns {Map} `this`\n     * @example\n     * // rotate the map to 90 degrees\n     * map.setBearing(90);\n     */\n    setBearing(bearing: number, eventData?: Object) {\n        this.jumpTo({bearing}, eventData);\n        return this;\n    }\n\n    /**\n     * Rotates the map to the specified bearing, with an animated transition. The bearing is the compass direction\n     * that is \\\"up\\\"; for example, a bearing of 90Â° orients the map so that east is up.\n     *\n     * @memberof Map#\n     * @param bearing The desired bearing.\n     * @param options\n     * @param eventData Additional properties to be added to event objects of events triggered by this method.\n     * @fires movestart\n     * @fires moveend\n     * @returns {Map} `this`\n     */\n    rotateTo(bearing: number, options?: AnimationOptions, eventData?: Object) {\n        return this.easeTo(extend({\n            bearing\n        }, options), eventData);\n    }\n\n    /**\n     * Rotates the map so that north is up (0Â° bearing), with an animated transition.\n     *\n     * @memberof Map#\n     * @param options\n     * @param eventData Additional properties to be added to event objects of events triggered by this method.\n     * @fires movestart\n     * @fires moveend\n     * @returns {Map} `this`\n     */\n    resetNorth(options?: AnimationOptions, eventData?: Object) {\n        this.rotateTo(0, extend({duration: 1000}, options), eventData);\n        return this;\n    }\n\n    /**\n     * Rotates and pitches the map so that north is up (0Â° bearing) and pitch is 0Â°, with an animated transition.\n     *\n     * @memberof Map#\n     * @param options\n     * @param eventData Additional properties to be added to event objects of events triggered by this method.\n     * @fires movestart\n     * @fires moveend\n     * @returns {Map} `this`\n     */\n    resetNorthPitch(options?: AnimationOptions, eventData?: Object) {\n        this.easeTo(extend({\n            bearing: 0,\n            pitch: 0,\n            duration: 1000\n        }, options), eventData);\n        return this;\n    }\n\n    /**\n     * Snaps the map so that north is up (0Â° bearing), if the current bearing is close enough to it (i.e. within the\n     * `bearingSnap` threshold).\n     *\n     * @memberof Map#\n     * @param options\n     * @param eventData Additional properties to be added to event objects of events triggered by this method.\n     * @fires movestart\n     * @fires moveend\n     * @returns {Map} `this`\n     */\n    snapToNorth(options?: AnimationOptions, eventData?: Object) {\n        if (Math.abs(this.getBearing()) < this._bearingSnap) {\n            return this.resetNorth(options, eventData);\n        }\n        return this;\n    }\n\n    /**\n     * Returns the map's current pitch (tilt).\n     *\n     * @memberof Map#\n     * @returns The map's current pitch, measured in degrees away from the plane of the screen.\n     */\n    getPitch(): number { return this.transform.pitch; }\n\n    /**\n     * Sets the map's pitch (tilt). Equivalent to `jumpTo({pitch: pitch})`.\n     *\n     * @memberof Map#\n     * @param pitch The pitch to set, measured in degrees away from the plane of the screen (0-60).\n     * @param eventData Additional properties to be added to event objects of events triggered by this method.\n     * @fires pitchstart\n     * @fires movestart\n     * @fires moveend\n     * @returns {Map} `this`\n     */\n    setPitch(pitch: number, eventData?: Object) {\n        this.jumpTo({pitch}, eventData);\n        return this;\n    }\n\n    /**\n     * @memberof Map#\n     * @param {LatLngBoundsLike} bounds Calculate the center for these bounds in the viewport and use\n     *      the highest zoom level up to and including `Map#getMaxZoom()` that fits\n     *      in the viewport. LatLngBounds represent a box that is always axis-aligned with bearing 0.\n     * @param options\n     * @param {number | PaddingOptions} [options.padding] The amount of padding in pixels to add to the given bounds.\n     * @param {PointLike} [options.offset=[0, 0]] The center of the given bounds relative to the map's center, measured in pixels.\n     * @param {number} [options.maxZoom] The maximum zoom level to allow when the camera would transition to the specified bounds.\n     * @returns {CameraOptions | void} If map is able to fit to provided bounds, returns `CameraOptions` with\n     *      `center`, `zoom`, and `bearing`. If map is unable to fit, method will warn and return undefined.\n     * @example\n     * var bbox = [[-79, 43], [-73, 45]];\n     * var newCameraTransform = map.cameraForBounds(bbox, {\n     *   padding: {top: 10, bottom:25, left: 15, right: 5}\n     * });\n     */\n    cameraForBounds(bounds: LngLatBoundsLike, options?: CameraOptions): void | CameraOptions & AnimationOptions {\n        bounds = LngLatBounds.convert(bounds);\n        return this._cameraForBoxAndBearing(bounds.getNorthWest(), bounds.getSouthEast(), 0, options);\n    }\n\n    /**\n     * Calculate the center of these two points in the viewport and use\n     * the highest zoom level up to and including `Map#getMaxZoom()` that fits\n     * the points in the viewport at the specified bearing.\n     * @memberof Map#\n     * @param {LngLatLike} p0 First point\n     * @param {LngLatLike} p1 Second point\n     * @param bearing Desired map bearing at end of animation, in degrees\n     * @param options\n     * @param {number | PaddingOptions} [options.padding] The amount of padding in pixels to add to the given bounds.\n     * @param {PointLike} [options.offset=[0, 0]] The center of the given bounds relative to the map's center, measured in pixels.\n     * @param {number} [options.maxZoom] The maximum zoom level to allow when the camera would transition to the specified bounds.\n     * @returns {CameraOptions | void} If map is able to fit to provided bounds, returns `CameraOptions` with\n     *      `center`, `zoom`, and `bearing`. If map is unable to fit, method will warn and return undefined.\n     * @private\n     * @example\n     * var p0 = [-79, 43];\n     * var p1 = [-73, 45];\n     * var bearing = 90;\n     * var newCameraTransform = map._cameraForBoxAndBearing(p0, p1, bearing, {\n     *   padding: {top: 10, bottom:25, left: 15, right: 5}\n     * });\n     */\n    _cameraForBoxAndBearing(p0: LngLatLike, p1: LngLatLike, bearing: number, options?: CameraOptions): void | CameraOptions & AnimationOptions {\n        options = extend({\n            padding: {\n                top: 0,\n                bottom: 0,\n                right: 0,\n                left: 0\n            },\n            offset: [0, 0],\n            maxZoom: this.transform.maxZoom\n        }, options);\n\n        if (typeof options.padding === 'number') {\n            const p = options.padding;\n            options.padding = {\n                top: p,\n                bottom: p,\n                right: p,\n                left: p\n            };\n        }\n        if (!deepEqual(Object.keys(options.padding).sort((a, b) => {\n            if (a < b) return -1;\n            if (a > b) return 1;\n            return 0;\n        }), [\"bottom\", \"left\", \"right\", \"top\"])) {\n            warnOnce(\n                \"options.padding must be a positive number, or an Object with keys 'bottom', 'left', 'right', 'top'\"\n            );\n            return;\n        }\n\n        const tr = this.transform;\n\n        // We want to calculate the upper right and lower left of the box defined by p0 and p1\n        // in a coordinate system rotate to match the destination bearing.\n        const p0world = tr.project(LngLat.convert(p0));\n        const p1world = tr.project(LngLat.convert(p1));\n        const p0rotated = p0world.rotate(-bearing * Math.PI / 180);\n        const p1rotated = p1world.rotate(-bearing * Math.PI / 180);\n\n        const upperRight = new Point(Math.max(p0rotated.x, p1rotated.x), Math.max(p0rotated.y, p1rotated.y));\n        const lowerLeft = new Point(Math.min(p0rotated.x, p1rotated.x), Math.min(p0rotated.y, p1rotated.y));\n\n        // Calculate zoom: consider the original bbox and padding.\n        const size = upperRight.sub(lowerLeft);\n        const scaleX = (tr.width - options.padding.left - options.padding.right) / size.x;\n        const scaleY = (tr.height - options.padding.top - options.padding.bottom) / size.y;\n\n        if (scaleY < 0 || scaleX < 0) {\n            warnOnce(\n                'Map cannot fit within canvas with the given bounds, padding, and/or offset.'\n            );\n            return;\n        }\n\n        const zoom = Math.min(tr.scaleZoom(tr.scale * Math.min(scaleX, scaleY)), options.maxZoom);\n\n        // Calculate center: apply the zoom, the configured offset, as well as offset that exists as a result of padding.\n        const offset = Point.convert(options.offset);\n        const paddingOffsetX = (options.padding.left - options.padding.right) / 2;\n        const paddingOffsetY = (options.padding.top - options.padding.bottom) / 2;\n        const offsetAtInitialZoom = new Point(offset.x + paddingOffsetX, offset.y + paddingOffsetY);\n        const offsetAtFinalZoom = offsetAtInitialZoom.mult(tr.scale / tr.zoomScale(zoom));\n\n        const center =  tr.unproject(p0world.add(p1world).div(2).sub(offsetAtFinalZoom));\n\n        return {\n            center,\n            zoom,\n            bearing\n        };\n    }\n\n    /**\n     * Pans and zooms the map to contain its visible area within the specified geographical bounds.\n     * This function will also reset the map's bearing to 0 if bearing is nonzero.\n     *\n     * @memberof Map#\n     * @param bounds Center these bounds in the viewport and use the highest\n     *      zoom level up to and including `Map#getMaxZoom()` that fits them in the viewport.\n     * @param {Object} [options] Options supports all properties from {@link AnimationOptions} and {@link CameraOptions} in addition to the fields below.\n     * @param {number | PaddingOptions} [options.padding] The amount of padding in pixels to add to the given bounds.\n     * @param {boolean} [options.linear=false] If `true`, the map transitions using\n     *     {@link Map#easeTo}. If `false`, the map transitions using {@link Map#flyTo}. See\n     *     those functions and {@link AnimationOptions} for information about options available.\n     * @param {Function} [options.easing] An easing function for the animated transition. See {@link AnimationOptions}.\n     * @param {PointLike} [options.offset=[0, 0]] The center of the given bounds relative to the map's center, measured in pixels.\n     * @param {number} [options.maxZoom] The maximum zoom level to allow when the map view transitions to the specified bounds.\n     * @param {Object} [eventData] Additional properties to be added to event objects of events triggered by this method.\n     * @fires movestart\n     * @fires moveend\n     * @returns {Map} `this`\n\t * @example\n     * var bbox = [[-79, 43], [-73, 45]];\n     * map.fitBounds(bbox, {\n     *   padding: {top: 10, bottom:25, left: 15, right: 5}\n     * });\n     * @see [Fit a map to a bounding box](https://www.mapbox.com/mapbox-gl-js/example/fitbounds/)\n     */\n    fitBounds(bounds: LngLatBoundsLike, options?: AnimationOptions & CameraOptions, eventData?: Object) {\n        return this._fitInternal(\n            this.cameraForBounds(bounds, options),\n            options,\n            eventData);\n    }\n\n    /**\n     * Pans, rotates and zooms the map to to fit the box made by points p0 and p1\n     * once the map is rotated to the specified bearing. To zoom without rotating,\n     * pass in the current map bearing.\n     *\n     * @memberof Map#\n     * @param p0 First point on screen, in pixel coordinates\n     * @param p1 Second point on screen, in pixel coordinates\n     * @param bearing Desired map bearing at end of animation, in degrees\n     * @param options\n     * @param {number | PaddingOptions} [options.padding] The amount of padding in pixels to add to the given bounds.\n     * @param {boolean} [options.linear=false] If `true`, the map transitions using\n     *     {@link Map#easeTo}. If `false`, the map transitions using {@link Map#flyTo}. See\n     *     those functions and {@link AnimationOptions} for information about options available.\n     * @param {Function} [options.easing] An easing function for the animated transition. See {@link AnimationOptions}.\n     * @param {PointLike} [options.offset=[0, 0]] The center of the given bounds relative to the map's center, measured in pixels.\n     * @param {number} [options.maxZoom] The maximum zoom level to allow when the map view transitions to the specified bounds.\n     * @param eventData Additional properties to be added to event objects of events triggered by this method.\n     * @fires movestart\n     * @fires moveend\n     * @returns {Map} `this`\n\t * @example\n     * var p0 = [220, 400];\n     * var p1 = [500, 900];\n     * map.fitScreenCoordinates(p0, p1, map.getBearing(), {\n     *   padding: {top: 10, bottom:25, left: 15, right: 5}\n     * });\n     * @see [Used by BoxZoomHandler](https://www.mapbox.com/mapbox-gl-js/api/#boxzoomhandler)\n     */\n    fitScreenCoordinates(p0: PointLike, p1: PointLike, bearing: number, options?: AnimationOptions & CameraOptions, eventData?: Object) {\n        return this._fitInternal(\n            this._cameraForBoxAndBearing(\n                this.transform.pointLocation(Point.convert(p0)),\n                this.transform.pointLocation(Point.convert(p1)),\n                bearing,\n                options),\n            options,\n            eventData);\n    }\n\n    _fitInternal(calculatedOptions?: CameraOptions & AnimationOptions, options?: AnimationOptions & CameraOptions, eventData?: Object) {\n        // cameraForBounds warns + returns undefined if unable to fit:\n        if (!calculatedOptions) return this;\n\n        options = extend(calculatedOptions, options);\n\n        return options.linear ?\n            this.easeTo(options, eventData) :\n            this.flyTo(options, eventData);\n    }\n\n    /**\n     * Changes any combination of center, zoom, bearing, and pitch, without\n     * an animated transition. The map will retain its current values for any\n     * details not specified in `options`.\n     *\n     * @memberof Map#\n     * @param options\n     * @param eventData Additional properties to be added to event objects of events triggered by this method.\n     * @fires movestart\n     * @fires zoomstart\n     * @fires pitchstart\n     * @fires rotate\n     * @fires move\n     * @fires zoom\n     * @fires pitch\n     * @fires moveend\n     * @fires zoomend\n     * @fires pitchend\n     * @returns {Map} `this`\n     */\n    jumpTo(options: CameraOptions, eventData?: Object) {\n        this.stop();\n\n        const tr = this.transform;\n        let zoomChanged = false,\n            bearingChanged = false,\n            pitchChanged = false;\n\n        if ('zoom' in options && tr.zoom !== +options.zoom) {\n            zoomChanged = true;\n            tr.zoom = +options.zoom;\n        }\n\n        if (options.center !== undefined) {\n            tr.center = LngLat.convert(options.center);\n        }\n\n        if ('bearing' in options && tr.bearing !== +options.bearing) {\n            bearingChanged = true;\n            tr.bearing = +options.bearing;\n        }\n\n        if ('pitch' in options && tr.pitch !== +options.pitch) {\n            pitchChanged = true;\n            tr.pitch = +options.pitch;\n        }\n\n        this.fire(new Event('movestart', eventData))\n            .fire(new Event('move', eventData));\n\n        if (zoomChanged) {\n            this.fire(new Event('zoomstart', eventData))\n                .fire(new Event('zoom', eventData))\n                .fire(new Event('zoomend', eventData));\n        }\n\n        if (bearingChanged) {\n            this.fire(new Event('rotatestart', eventData))\n                .fire(new Event('rotate', eventData))\n                .fire(new Event('rotateend', eventData));\n        }\n\n        if (pitchChanged) {\n            this.fire(new Event('pitchstart', eventData))\n                .fire(new Event('pitch', eventData))\n                .fire(new Event('pitchend', eventData));\n        }\n\n        return this.fire(new Event('moveend', eventData));\n    }\n\n    /**\n     * Changes any combination of center, zoom, bearing, and pitch, with an animated transition\n     * between old and new values. The map will retain its current values for any\n     * details not specified in `options`.\n     *\n     * Note: The transition will happen instantly if the user has enabled\n     * the `reduced motion` accesibility feature enabled in their operating system.\n     *\n     * @memberof Map#\n     * @param options Options describing the destination and animation of the transition.\n     *            Accepts {@link CameraOptions} and {@link AnimationOptions}.\n     * @param eventData Additional properties to be added to event objects of events triggered by this method.\n     * @fires movestart\n     * @fires zoomstart\n     * @fires pitchstart\n     * @fires rotate\n     * @fires move\n     * @fires zoom\n     * @fires pitch\n     * @fires moveend\n     * @fires zoomend\n     * @fires pitchend\n     * @returns {Map} `this`\n     * @see [Navigate the map with game-like controls](https://www.mapbox.com/mapbox-gl-js/example/game-controls/)\n     */\n    easeTo(options: CameraOptions & AnimationOptions & {delayEndEvents?: number}, eventData?: Object) {\n        this.stop();\n\n        options = extend({\n            offset: [0, 0],\n            duration: 500,\n            easing: defaultEasing\n        }, options);\n\n        if (options.animate === false || browser.prefersReducedMotion) options.duration = 0;\n\n        const tr = this.transform,\n            startZoom = this.getZoom(),\n            startBearing = this.getBearing(),\n            startPitch = this.getPitch(),\n\n            zoom = 'zoom' in options ? +options.zoom : startZoom,\n            bearing = 'bearing' in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing,\n            pitch = 'pitch' in options ? +options.pitch : startPitch;\n\n        const pointAtOffset = tr.centerPoint.add(Point.convert(options.offset));\n        const locationAtOffset = tr.pointLocation(pointAtOffset);\n        const center = LngLat.convert(options.center || locationAtOffset);\n        this._normalizeCenter(center);\n\n        const from = tr.project(locationAtOffset);\n        const delta = tr.project(center).sub(from);\n        const finalScale = tr.zoomScale(zoom - startZoom);\n\n        let around, aroundPoint;\n\n        if (options.around) {\n            around = LngLat.convert(options.around);\n            aroundPoint = tr.locationPoint(around);\n        }\n\n        this._zooming = (zoom !== startZoom);\n        this._rotating = (startBearing !== bearing);\n        this._pitching = (pitch !== startPitch);\n\n        this._prepareEase(eventData, options.noMoveStart);\n\n        clearTimeout(this._easeEndTimeoutID);\n\n        this._ease((k) => {\n            if (this._zooming) {\n                tr.zoom = interpolate(startZoom, zoom, k);\n            }\n            if (this._rotating) {\n                tr.bearing = interpolate(startBearing, bearing, k);\n            }\n            if (this._pitching) {\n                tr.pitch = interpolate(startPitch, pitch, k);\n            }\n\n            if (around) {\n                tr.setLocationAtPoint(around, aroundPoint);\n            } else {\n                const scale = tr.zoomScale(tr.zoom - startZoom);\n                const base = zoom > startZoom ?\n                    Math.min(2, finalScale) :\n                    Math.max(0.5, finalScale);\n                const speedup = Math.pow(base, 1 - k);\n                const newCenter = tr.unproject(from.add(delta.mult(k * speedup)).mult(scale));\n                tr.setLocationAtPoint(tr.renderWorldCopies ? newCenter.wrap() : newCenter, pointAtOffset);\n            }\n\n            this._fireMoveEvents(eventData);\n\n        }, () => {\n            if (options.delayEndEvents) {\n                this._easeEndTimeoutID = setTimeout(() => this._afterEase(eventData), options.delayEndEvents);\n            } else {\n                this._afterEase(eventData);\n            }\n        }, options);\n\n        return this;\n    }\n\n    _prepareEase(eventData?: Object, noMoveStart: boolean) {\n        this._moving = true;\n\n        if (!noMoveStart) {\n            this.fire(new Event('movestart', eventData));\n        }\n        if (this._zooming) {\n            this.fire(new Event('zoomstart', eventData));\n        }\n        if (this._rotating) {\n            this.fire(new Event('rotatestart', eventData));\n        }\n        if (this._pitching) {\n            this.fire(new Event('pitchstart', eventData));\n        }\n    }\n\n    _fireMoveEvents(eventData?: Object) {\n        this.fire(new Event('move', eventData));\n        if (this._zooming) {\n            this.fire(new Event('zoom', eventData));\n        }\n        if (this._rotating) {\n            this.fire(new Event('rotate', eventData));\n        }\n        if (this._pitching) {\n            this.fire(new Event('pitch', eventData));\n        }\n    }\n\n    _afterEase(eventData?: Object) {\n        const wasZooming = this._zooming;\n        const wasRotating = this._rotating;\n        const wasPitching = this._pitching;\n        this._moving = false;\n        this._zooming = false;\n        this._rotating = false;\n        this._pitching = false;\n\n        if (wasZooming) {\n            this.fire(new Event('zoomend', eventData));\n        }\n        if (wasRotating) {\n            this.fire(new Event('rotateend', eventData));\n        }\n        if (wasPitching) {\n            this.fire(new Event('pitchend', eventData));\n        }\n        this.fire(new Event('moveend', eventData));\n    }\n\n    /**\n     * Changes any combination of center, zoom, bearing, and pitch, animating the transition along a curve that\n     * evokes flight. The animation seamlessly incorporates zooming and panning to help\n     * the user maintain her bearings even after traversing a great distance.\n     *\n     * Note: The animation will be skipped, and this will behave equivalently to `jumpTo`\n     * if the user has the `reduced motion` accesibility feature enabled in their operating system.\n     *\n     * @memberof Map#\n     * @param {Object} options Options describing the destination and animation of the transition.\n     *     Accepts {@link CameraOptions}, {@link AnimationOptions},\n     *     and the following additional options.\n     * @param {number} [options.curve=1.42] The zooming \"curve\" that will occur along the\n     *     flight path. A high value maximizes zooming for an exaggerated animation, while a low\n     *     value minimizes zooming for an effect closer to {@link Map#easeTo}. 1.42 is the average\n     *     value selected by participants in the user study discussed in\n     *     [van Wijk (2003)](https://www.win.tue.nl/~vanwijk/zoompan.pdf). A value of\n     *     `Math.pow(6, 0.25)` would be equivalent to the root mean squared average velocity. A\n     *     value of 1 would produce a circular motion.\n     * @param {number} [options.minZoom] The zero-based zoom level at the peak of the flight path. If\n     *     `options.curve` is specified, this option is ignored.\n     * @param {number} [options.speed=1.2] The average speed of the animation defined in relation to\n     *     `options.curve`. A speed of 1.2 means that the map appears to move along the flight path\n     *     by 1.2 times `options.curve` screenfuls every second. A _screenful_ is the map's visible span.\n     *     It does not correspond to a fixed physical distance, but varies by zoom level.\n     * @param {number} [options.screenSpeed] The average speed of the animation measured in screenfuls\n     *     per second, assuming a linear timing curve. If `options.speed` is specified, this option is ignored.\n     * @param {number} [options.maxDuration] The animation's maximum duration, measured in milliseconds.\n     *     If duration exceeds maximum duration, it resets to 0.\n     * @param eventData Additional properties to be added to event objects of events triggered by this method.\n     * @fires movestart\n     * @fires zoomstart\n     * @fires pitchstart\n     * @fires move\n     * @fires zoom\n     * @fires rotate\n     * @fires pitch\n     * @fires moveend\n     * @fires zoomend\n     * @fires pitchend\n     * @returns {Map} `this`\n     * @example\n     * // fly with default options to null island\n     * map.flyTo({center: [0, 0], zoom: 9});\n     * // using flyTo options\n     * map.flyTo({\n     *   center: [0, 0],\n     *   zoom: 9,\n     *   speed: 0.2,\n     *   curve: 1,\n     *   easing(t) {\n     *     return t;\n     *   }\n     * });\n     * @see [Fly to a location](https://www.mapbox.com/mapbox-gl-js/example/flyto/)\n     * @see [Slowly fly to a location](https://www.mapbox.com/mapbox-gl-js/example/flyto-options/)\n     * @see [Fly to a location based on scroll position](https://www.mapbox.com/mapbox-gl-js/example/scroll-fly-to/)\n     */\n    flyTo(options: Object, eventData?: Object) {\n        // Fall through to jumpTo if user has set prefers-reduced-motion\n        if (browser.prefersReducedMotion) {\n            const coercedOptions = (pick(options, ['center', 'zoom', 'bearing', 'pitch', 'around']): CameraOptions);\n            return this.jumpTo(coercedOptions, eventData);\n        }\n\n        // This method implements an âoptimal pathâ animation, as detailed in:\n        //\n        // Van Wijk, Jarke J.; Nuij, Wim A. A. âSmooth and efficient zooming and panning.â INFOVIS\n        //   â03. pp. 15â22. <https://www.win.tue.nl/~vanwijk/zoompan.pdf#page=5>.\n        //\n        // Where applicable, local variable documentation begins with the associated variable or\n        // function in van Wijk (2003).\n\n        this.stop();\n\n        options = extend({\n            offset: [0, 0],\n            speed: 1.2,\n            curve: 1.42,\n            easing: defaultEasing\n        }, options);\n\n        const tr = this.transform,\n            startZoom = this.getZoom(),\n            startBearing = this.getBearing(),\n            startPitch = this.getPitch();\n\n        const zoom = 'zoom' in options ? clamp(+options.zoom, tr.minZoom, tr.maxZoom) : startZoom;\n        const bearing = 'bearing' in options ? this._normalizeBearing(options.bearing, startBearing) : startBearing;\n        const pitch = 'pitch' in options ? +options.pitch : startPitch;\n\n        const scale = tr.zoomScale(zoom - startZoom);\n        const pointAtOffset = tr.centerPoint.add(Point.convert(options.offset));\n        const locationAtOffset = tr.pointLocation(pointAtOffset);\n        const center = LngLat.convert(options.center || locationAtOffset);\n        this._normalizeCenter(center);\n\n        const from = tr.project(locationAtOffset);\n        const delta = tr.project(center).sub(from);\n\n        let rho = options.curve;\n\n        // wâ: Initial visible span, measured in pixels at the initial scale.\n        const w0 = Math.max(tr.width, tr.height),\n            // wâ: Final visible span, measured in pixels with respect to the initial scale.\n            w1 = w0 / scale,\n            // Length of the flight path as projected onto the ground plane, measured in pixels from\n            // the world image origin at the initial scale.\n            u1 = delta.mag();\n\n        if ('minZoom' in options) {\n            const minZoom = clamp(Math.min(options.minZoom, startZoom, zoom), tr.minZoom, tr.maxZoom);\n            // w<sub>m</sub>: Maximum visible span, measured in pixels with respect to the initial\n            // scale.\n            const wMax = w0 / tr.zoomScale(minZoom - startZoom);\n            rho = Math.sqrt(wMax / u1 * 2);\n        }\n\n        // ÏÂ²\n        const rho2 = rho * rho;\n\n        /**\n         * ráµ¢: Returns the zoom-out factor at one end of the animation.\n         *\n         * @param i 0 for the ascent or 1 for the descent.\n         * @private\n         */\n        function r(i) {\n            const b = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1);\n            return Math.log(Math.sqrt(b * b + 1) - b);\n        }\n\n        function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }\n        function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }\n        function tanh(n) { return sinh(n) / cosh(n); }\n\n        // râ: Zoom-out factor during ascent.\n        const r0 = r(0);\n\n        // w(s): Returns the visible span on the ground, measured in pixels with respect to the\n        // initial scale. Assumes an angular field of view of 2 arctan Â½ â 53Â°.\n        let w: (number) => number = function (s) {\n            return (cosh(r0) / cosh(r0 + rho * s));\n        };\n\n        // u(s): Returns the distance along the flight path as projected onto the ground plane,\n        // measured in pixels from the world image origin at the initial scale.\n        let u: (number) => number = function (s) {\n            return w0 * ((cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2) / u1;\n        };\n\n        // S: Total length of the flight path, measured in Ï-screenfuls.\n        let S = (r(1) - r0) / rho;\n\n        // When uâ = uâ, the optimal path doesnât require both ascent and descent.\n        if (Math.abs(u1) < 0.000001 || !isFinite(S)) {\n            // Perform a more or less instantaneous transition if the path is too short.\n            if (Math.abs(w0 - w1) < 0.000001) return this.easeTo(options, eventData);\n\n            const k = w1 < w0 ? -1 : 1;\n            S = Math.abs(Math.log(w1 / w0)) / rho;\n\n            u = function() { return 0; };\n            w = function(s) { return Math.exp(k * rho * s); };\n        }\n\n        if ('duration' in options) {\n            options.duration = +options.duration;\n        } else {\n            const V = 'screenSpeed' in options ? +options.screenSpeed / rho : +options.speed;\n            options.duration = 1000 * S / V;\n        }\n\n        if (options.maxDuration && options.duration > options.maxDuration) {\n            options.duration = 0;\n        }\n\n        this._zooming = true;\n        this._rotating = (startBearing !== bearing);\n        this._pitching = (pitch !== startPitch);\n\n        this._prepareEase(eventData, false);\n\n        this._ease((k) => {\n            // s: The distance traveled along the flight path, measured in Ï-screenfuls.\n            const s = k * S;\n            const scale = 1 / w(s);\n            tr.zoom = k === 1 ? zoom : startZoom + tr.scaleZoom(scale);\n\n            if (this._rotating) {\n                tr.bearing = interpolate(startBearing, bearing, k);\n            }\n            if (this._pitching) {\n                tr.pitch = interpolate(startPitch, pitch, k);\n            }\n\n            const newCenter = k === 1 ? center : tr.unproject(from.add(delta.mult(u(s))).mult(scale));\n            tr.setLocationAtPoint(tr.renderWorldCopies ? newCenter.wrap() : newCenter, pointAtOffset);\n\n            this._fireMoveEvents(eventData);\n\n        }, () => this._afterEase(eventData), options);\n\n        return this;\n    }\n\n    isEasing() {\n        return !!this._easeFrameId;\n    }\n\n    /**\n     * Stops any animated transition underway.\n     *\n     * @memberof Map#\n     * @returns {Map} `this`\n     */\n    stop(): this {\n        if (this._easeFrameId) {\n            this._cancelRenderFrame(this._easeFrameId);\n            delete this._easeFrameId;\n            delete this._onEaseFrame;\n        }\n\n        if (this._onEaseEnd) {\n            // The _onEaseEnd function might emit events which trigger new\n            // animation, which sets a new _onEaseEnd. Ensure we don't delete\n            // it unintentionally.\n            const onEaseEnd = this._onEaseEnd;\n            delete this._onEaseEnd;\n            onEaseEnd.call(this);\n        }\n        return this;\n    }\n\n    _ease(frame: (number) => void,\n          finish: () => void,\n          options: {animate: boolean, duration: number, easing: (number) => number}) {\n        if (options.animate === false || options.duration === 0) {\n            frame(1);\n            finish();\n        } else {\n            this._easeStart = browser.now();\n            this._easeOptions = options;\n            this._onEaseFrame = frame;\n            this._onEaseEnd = finish;\n            this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback);\n        }\n    }\n\n    // Callback for map._requestRenderFrame\n    _renderFrameCallback() {\n        const t = Math.min((browser.now() - this._easeStart) / this._easeOptions.duration, 1);\n        this._onEaseFrame(this._easeOptions.easing(t));\n        if (t < 1) {\n            this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback);\n        } else {\n            this.stop();\n        }\n    }\n\n    // convert bearing so that it's numerically close to the current one so that it interpolates properly\n    _normalizeBearing(bearing: number, currentBearing: number) {\n        bearing = wrap(bearing, -180, 180);\n        const diff = Math.abs(bearing - currentBearing);\n        if (Math.abs(bearing - 360 - currentBearing) < diff) bearing -= 360;\n        if (Math.abs(bearing + 360 - currentBearing) < diff) bearing += 360;\n        return bearing;\n    }\n\n    // If a path crossing the antimeridian would be shorter, extend the final coordinate so that\n    // interpolating between the two endpoints will cross it.\n    _normalizeCenter(center: LngLat) {\n        const tr = this.transform;\n        if (!tr.renderWorldCopies || tr.lngRange) return;\n\n        const delta = center.lng - tr.center.lng;\n        center.lng +=\n            delta > 180 ? -360 :\n            delta < -180 ? 360 : 0;\n    }\n}\n\nexport default Camera;\n","// @flow\n\nimport DOM from '../../util/dom';\nimport {bindAll} from '../../util/util';\nimport config from '../../util/config';\n\nimport type Map from '../map';\n\ntype Options = {\n    compact?: boolean,\n    customAttribution?: string | Array<string>\n};\n\n/**\n * An `AttributionControl` control presents the map's [attribution information](https://www.mapbox.com/help/attribution/).\n *\n * @implements {IControl}\n * @param {Object} [options]\n * @param {boolean} [options.compact] If `true` force a compact attribution that shows the full attribution on mouse hover, or if `false` force the full attribution control. The default is a responsive attribution that collapses when the map is less than 640 pixels wide.\n * @param {string | Array<string>} [options.customAttribution] String or strings to show in addition to any other attributions.\n * @example\n * var map = new mapboxgl.Map({attributionControl: false})\n *     .addControl(new mapboxgl.AttributionControl({\n *         compact: true\n *     }));\n */\nclass AttributionControl {\n    options: Options;\n    _map: Map;\n    _container: HTMLElement;\n    _innerContainer: HTMLElement;\n    _editLink: ?HTMLAnchorElement;\n    _attribHTML: string;\n    styleId: string;\n    styleOwner: string;\n\n    constructor(options: Options = {}) {\n        this.options = options;\n\n        bindAll([\n            '_updateEditLink',\n            '_updateData',\n            '_updateCompact'\n        ], this);\n    }\n\n    getDefaultPosition() {\n        return 'bottom-right';\n    }\n\n    onAdd(map: Map) {\n        const compact = this.options && this.options.compact;\n\n        this._map = map;\n        this._container = DOM.create('div', 'mapboxgl-ctrl mapboxgl-ctrl-attrib');\n        this._innerContainer = DOM.create('div', 'mapboxgl-ctrl-attrib-inner', this._container);\n\n        if (compact) {\n            this._container.classList.add('mapboxgl-compact');\n        }\n\n        this._updateAttributions();\n        this._updateEditLink();\n\n        this._map.on('styledata', this._updateData);\n        this._map.on('sourcedata', this._updateData);\n        this._map.on('moveend', this._updateEditLink);\n\n        if (compact === undefined) {\n            this._map.on('resize', this._updateCompact);\n            this._updateCompact();\n        }\n\n        return this._container;\n    }\n\n    onRemove() {\n        DOM.remove(this._container);\n\n        this._map.off('styledata', this._updateData);\n        this._map.off('sourcedata', this._updateData);\n        this._map.off('moveend', this._updateEditLink);\n        this._map.off('resize', this._updateCompact);\n\n        this._map = (undefined: any);\n    }\n\n    _updateEditLink() {\n        let editLink = this._editLink;\n        if (!editLink) {\n            editLink = this._editLink = (this._container.querySelector('.mapbox-improve-map'): any);\n        }\n\n        const params = [\n            {key: \"owner\", value: this.styleOwner},\n            {key: \"id\", value: this.styleId},\n            {key: \"access_token\", value: this._map._requestManager._customAccessToken || config.ACCESS_TOKEN}\n        ];\n\n        if (editLink) {\n            const paramString = params.reduce((acc, next, i) => {\n                if (next.value) {\n                    acc += `${next.key}=${next.value}${i < params.length - 1 ? '&' : ''}`;\n                }\n                return acc;\n            }, `?`);\n            editLink.href = `${config.FEEDBACK_URL}/${paramString}${this._map._hash ? this._map._hash.getHashString(true) : ''}`;\n            editLink.rel = \"noopener nofollow\";\n        }\n    }\n\n    _updateData(e: any) {\n        if (e && (e.sourceDataType === 'metadata' || e.dataType === 'style')) {\n            this._updateAttributions();\n            this._updateEditLink();\n        }\n    }\n\n    _updateAttributions() {\n        if (!this._map.style) return;\n        let attributions: Array<string> = [];\n        if (this.options.customAttribution) {\n            if (Array.isArray(this.options.customAttribution)) {\n                attributions = attributions.concat(\n                    this.options.customAttribution.map(attribution => {\n                        if (typeof attribution !== 'string') return '';\n                        return attribution;\n                    })\n                );\n            } else if (typeof this.options.customAttribution === 'string') {\n                attributions.push(this.options.customAttribution);\n            }\n        }\n\n        if (this._map.style.stylesheet) {\n            const stylesheet: any = this._map.style.stylesheet;\n            this.styleOwner = stylesheet.owner;\n            this.styleId = stylesheet.id;\n        }\n\n        const sourceCaches = this._map.style.sourceCaches;\n        for (const id in sourceCaches) {\n            const sourceCache = sourceCaches[id];\n            if (sourceCache.used) {\n                const source = sourceCache.getSource();\n                if (source.attribution && attributions.indexOf(source.attribution) < 0) {\n                    attributions.push(source.attribution);\n                }\n            }\n        }\n\n        // remove any entries that are substrings of another entry.\n        // first sort by length so that substrings come first\n        attributions.sort((a, b) => a.length - b.length);\n        attributions = attributions.filter((attrib, i) => {\n            for (let j = i + 1; j < attributions.length; j++) {\n                if (attributions[j].indexOf(attrib) >= 0) { return false; }\n            }\n            return true;\n        });\n\n        // check if attribution string is different to minimize DOM changes\n        const attribHTML = attributions.join(' | ');\n        if (attribHTML === this._attribHTML) return;\n\n        this._attribHTML = attribHTML;\n\n        if (attributions.length) {\n            this._innerContainer.innerHTML = attribHTML;\n            this._container.classList.remove('mapboxgl-attrib-empty');\n        } else {\n            this._container.classList.add('mapboxgl-attrib-empty');\n        }\n        // remove old DOM node from _editLink\n        this._editLink = null;\n    }\n\n    _updateCompact() {\n        if (this._map.getCanvasContainer().offsetWidth <= 640) {\n            this._container.classList.add('mapboxgl-compact');\n        } else {\n            this._container.classList.remove('mapboxgl-compact');\n        }\n    }\n\n}\n\nexport default AttributionControl;\n","// @flow\n\nimport DOM from '../../util/dom';\n\nimport {bindAll} from '../../util/util';\n\nimport type Map from '../map';\n\n/**\n * A `LogoControl` is a control that adds the Mapbox watermark\n * to the map as required by the [terms of service](https://www.mapbox.com/tos/) for Mapbox\n * vector tiles and core styles.\n *\n * @implements {IControl}\n * @private\n**/\n\nclass LogoControl {\n    _map: Map;\n    _container: HTMLElement;\n\n    constructor() {\n        bindAll(['_updateLogo'], this);\n        bindAll(['_updateCompact'], this);\n    }\n\n    onAdd(map: Map) {\n        this._map = map;\n        this._container = DOM.create('div', 'mapboxgl-ctrl');\n        const anchor = DOM.create('a', 'mapboxgl-ctrl-logo');\n        anchor.target = \"_blank\";\n        anchor.rel = \"noopener nofollow\";\n        anchor.href = \"https://www.mapbox.com/\";\n        anchor.setAttribute(\"aria-label\", \"Mapbox logo\");\n        anchor.setAttribute(\"rel\", \"noopener nofollow\");\n        this._container.appendChild(anchor);\n        this._container.style.display = 'none';\n\n        this._map.on('sourcedata', this._updateLogo);\n        this._updateLogo();\n\n        this._map.on('resize', this._updateCompact);\n        this._updateCompact();\n\n        return this._container;\n    }\n\n    onRemove() {\n        DOM.remove(this._container);\n        this._map.off('sourcedata', this._updateLogo);\n        this._map.off('resize', this._updateCompact);\n    }\n\n    getDefaultPosition() {\n        return 'bottom-left';\n    }\n\n    _updateLogo(e: any) {\n        if (!e || e.sourceDataType === 'metadata') {\n            this._container.style.display = this._logoRequired() ? 'block' : 'none';\n        }\n    }\n\n    _logoRequired() {\n        if (!this._map.style) return;\n\n        const sourceCaches = this._map.style.sourceCaches;\n        for (const id in sourceCaches) {\n            const source = sourceCaches[id].getSource();\n            if (source.mapbox_logo) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    _updateCompact() {\n        const containerChildren = this._container.children;\n        if (containerChildren.length) {\n            const anchor = containerChildren[0];\n            if (this._map.getCanvasContainer().offsetWidth < 250) {\n                anchor.classList.add('mapboxgl-compact');\n            } else {\n                anchor.classList.remove('mapboxgl-compact');\n            }\n        }\n    }\n\n}\n\nexport default LogoControl;\n","// @flow strict\nimport assert from 'assert';\n\nexport type TaskID = number; // can't mark opaque due to https://github.com/flowtype/flow-remove-types/pull/61\ntype Task = {\n    callback: () => void;\n    id: TaskID;\n    cancelled: boolean;\n};\n\nclass TaskQueue {\n    _queue: Array<Task>;\n    _id: TaskID;\n    _cleared: boolean;\n    _currentlyRunning: Array<Task> | false;\n\n    constructor()  {\n        this._queue = [];\n        this._id = 0;\n        this._cleared = false;\n        this._currentlyRunning = false;\n    }\n\n    add(callback: () => void): TaskID {\n        const id = ++this._id;\n        const queue = this._queue;\n        queue.push({callback, id, cancelled: false});\n        return id;\n    }\n\n    remove(id: TaskID) {\n        const running = this._currentlyRunning;\n        const queue = running ? this._queue.concat(running) : this._queue;\n        for (const task of queue) {\n            if (task.id === id) {\n                task.cancelled = true;\n                return;\n            }\n        }\n    }\n\n    run() {\n        assert(!this._currentlyRunning);\n        const queue = this._currentlyRunning = this._queue;\n\n        // Tasks queued by callbacks in the current queue should be executed\n        // on the next run, not the current run.\n        this._queue = [];\n\n        for (const task of queue) {\n            if (task.cancelled) continue;\n            task.callback();\n            if (this._cleared) break;\n        }\n\n        this._cleared = false;\n        this._currentlyRunning = false;\n    }\n\n    clear() {\n        if (this._currentlyRunning) {\n            this._cleared = true;\n        }\n        this._queue = [];\n    }\n}\n\nexport default TaskQueue;\n","// @flow\n\nimport {version} from '../../package.json';\nimport {extend, bindAll, warnOnce, uniqueId} from '../util/util';\nimport browser from '../util/browser';\nimport window from '../util/window';\nconst {HTMLImageElement, HTMLElement} = window;\nimport DOM from '../util/dom';\nimport {getImage, getJSON, ResourceType} from '../util/ajax';\nimport {RequestManager} from '../util/mapbox';\nimport Style from '../style/style';\nimport EvaluationParameters from '../style/evaluation_parameters';\nimport Painter from '../render/painter';\nimport Transform from '../geo/transform';\nimport Hash from './hash';\nimport bindHandlers from './bind_handlers';\nimport Camera from './camera';\nimport LngLat from '../geo/lng_lat';\nimport LngLatBounds from '../geo/lng_lat_bounds';\nimport Point from '@mapbox/point-geometry';\nimport AttributionControl from './control/attribution_control';\nimport LogoControl from './control/logo_control';\nimport isSupported from '@mapbox/mapbox-gl-supported';\nimport {RGBAImage} from '../util/image';\nimport {Event, ErrorEvent} from '../util/evented';\nimport {MapMouseEvent} from './events';\nimport TaskQueue from '../util/task_queue';\nimport webpSupported from '../util/webp_supported';\nimport {setCacheLimits} from '../util/tile_request_cache';\n\nimport type {PointLike} from '@mapbox/point-geometry';\nimport type {RequestTransformFunction} from '../util/mapbox';\nimport type {LngLatLike} from '../geo/lng_lat';\nimport type {LngLatBoundsLike} from '../geo/lng_lat_bounds';\nimport type {StyleOptions, StyleSetterOptions} from '../style/style';\nimport type {MapEvent, MapDataEvent} from './events';\nimport type {CustomLayerInterface} from '../style/style_layer/custom_style_layer';\nimport type {StyleImageInterface} from '../style/style_image';\n\nimport type ScrollZoomHandler from './handler/scroll_zoom';\nimport type BoxZoomHandler from './handler/box_zoom';\nimport type DragRotateHandler from './handler/drag_rotate';\nimport type DragPanHandler from './handler/drag_pan';\nimport type KeyboardHandler from './handler/keyboard';\nimport type DoubleClickZoomHandler from './handler/dblclick_zoom';\nimport type TouchZoomRotateHandler from './handler/touch_zoom_rotate';\nimport type {TaskID} from '../util/task_queue';\nimport type {Cancelable} from '../types/cancelable';\nimport type {\n    LayerSpecification,\n    FilterSpecification,\n    StyleSpecification,\n    LightSpecification,\n    SourceSpecification\n} from '../style-spec/types';\n\ntype ControlPosition = 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\n/* eslint-disable no-use-before-define */\ntype IControl = {\n    onAdd(map: Map): HTMLElement;\n    onRemove(map: Map): void;\n\n    +getDefaultPosition?: () => ControlPosition;\n}\n/* eslint-enable no-use-before-define */\n\ntype MapOptions = {\n    hash?: boolean | string,\n    interactive?: boolean,\n    container: HTMLElement | string,\n    bearingSnap?: number,\n    attributionControl?: boolean,\n    customAttribution?: string | Array<string>,\n    logoPosition?: ControlPosition,\n    failIfMajorPerformanceCaveat?: boolean,\n    preserveDrawingBuffer?: boolean,\n    antialias?: boolean,\n    refreshExpiredTiles?: boolean,\n    maxBounds?: LngLatBoundsLike,\n    scrollZoom?: boolean,\n    minZoom?: ?number,\n    maxZoom?: ?number,\n    boxZoom?: boolean,\n    dragRotate?: boolean,\n    dragPan?: boolean,\n    keyboard?: boolean,\n    doubleClickZoom?: boolean,\n    touchZoomRotate?: boolean,\n    trackResize?: boolean,\n    center?: LngLatLike,\n    zoom?: number,\n    bearing?: number,\n    pitch?: number,\n    renderWorldCopies?: boolean,\n    maxTileCacheSize?: number,\n    transformRequest?: RequestTransformFunction,\n    accessToken: string\n};\n\nconst defaultMinZoom = 0;\nconst defaultMaxZoom = 22;\nconst defaultOptions = {\n    center: [0, 0],\n    zoom: 0,\n    bearing: 0,\n    pitch: 0,\n\n    minZoom: defaultMinZoom,\n    maxZoom: defaultMaxZoom,\n\n    interactive: true,\n    scrollZoom: true,\n    boxZoom: true,\n    dragRotate: true,\n    dragPan: true,\n    keyboard: true,\n    doubleClickZoom: true,\n    touchZoomRotate: true,\n\n    bearingSnap: 7,\n    clickTolerance: 3,\n\n    hash: false,\n    attributionControl: true,\n\n    failIfMajorPerformanceCaveat: false,\n    preserveDrawingBuffer: false,\n    trackResize: true,\n    renderWorldCopies: true,\n    refreshExpiredTiles: true,\n    maxTileCacheSize: null,\n    localIdeographFontFamily: 'sans-serif',\n    transformRequest: null,\n    accessToken: null,\n    fadeDuration: 300,\n    crossSourceCollisions: true\n};\n\n/**\n * The `Map` object represents the map on your page. It exposes methods\n * and properties that enable you to programmatically change the map,\n * and fires events as users interact with it.\n *\n * You create a `Map` by specifying a `container` and other options.\n * Then Mapbox GL JS initializes the map on the page and returns your `Map`\n * object.\n *\n * @extends Evented\n * @param {Object} options\n * @param {HTMLElement|string} options.container The HTML element in which Mapbox GL JS will render the map, or the element's string `id`. The specified element must have no children.\n * @param {number} [options.minZoom=0] The minimum zoom level of the map (0-24).\n * @param {number} [options.maxZoom=22] The maximum zoom level of the map (0-24).\n * @param {Object|string} [options.style] The map's Mapbox style. This must be an a JSON object conforming to\n * the schema described in the [Mapbox Style Specification](https://mapbox.com/mapbox-gl-style-spec/), or a URL to\n * such JSON.\n *\n * To load a style from the Mapbox API, you can use a URL of the form `mapbox://styles/:owner/:style`,\n * where `:owner` is your Mapbox account name and `:style` is the style ID. Or you can use one of the following\n * [the predefined Mapbox styles](https://www.mapbox.com/maps/):\n *\n *  * `mapbox://styles/mapbox/streets-v10`\n *  * `mapbox://styles/mapbox/outdoors-v10`\n *  * `mapbox://styles/mapbox/light-v9`\n *  * `mapbox://styles/mapbox/dark-v9`\n *  * `mapbox://styles/mapbox/satellite-v9`\n *  * `mapbox://styles/mapbox/satellite-streets-v10`\n *  * `mapbox://styles/mapbox/navigation-preview-day-v2`\n *  * `mapbox://styles/mapbox/navigation-preview-night-v2`\n *  * `mapbox://styles/mapbox/navigation-guidance-day-v2`\n *  * `mapbox://styles/mapbox/navigation-guidance-night-v2`\n *\n * Tilesets hosted with Mapbox can be style-optimized if you append `?optimize=true` to the end of your style URL, like `mapbox://styles/mapbox/streets-v9?optimize=true`.\n * Learn more about style-optimized vector tiles in our [API documentation](https://www.mapbox.com/api-documentation/maps/#retrieve-tiles).\n *\n * @param {(boolean|string)} [options.hash=false] If `true`, the map's position (zoom, center latitude, center longitude, bearing, and pitch) will be synced with the hash fragment of the page's URL.\n *   For example, `http://path/to/my/page.html#2.59/39.26/53.07/-24.1/60`.\n *   An additional string may optionally be provided to indicate a parameter-styled hash,\n *   e.g. http://path/to/my/page.html#map=2.59/39.26/53.07/-24.1/60&foo=bar, where foo\n *   is a custom parameter and bar is an arbitrary hash distinct from the map hash.\n * @param {boolean} [options.interactive=true] If `false`, no mouse, touch, or keyboard listeners will be attached to the map, so it will not respond to interaction.\n * @param {number} [options.bearingSnap=7] The threshold, measured in degrees, that determines when the map's\n *   bearing will snap to north. For example, with a `bearingSnap` of 7, if the user rotates\n *   the map within 7 degrees of north, the map will automatically snap to exact north.\n * @param {boolean} [options.pitchWithRotate=true] If `false`, the map's pitch (tilt) control with \"drag to rotate\" interaction will be disabled.\n * @param {number} [options.clickTolerance=3] The max number of pixels a user can shift the mouse pointer during a click for it to be considered a valid click (as opposed to a mouse drag).\n * @param {boolean} [options.attributionControl=true] If `true`, an {@link AttributionControl} will be added to the map.\n * @param {string | Array<string>} [options.customAttribution] String or strings to show in an {@link AttributionControl}. Only applicable if `options.attributionControl` is `true`.\n * @param {string} [options.logoPosition='bottom-left'] A string representing the position of the Mapbox wordmark on the map. Valid options are `top-left`,`top-right`, `bottom-left`, `bottom-right`.\n * @param {boolean} [options.failIfMajorPerformanceCaveat=false] If `true`, map creation will fail if the performance of Mapbox\n *   GL JS would be dramatically worse than expected (i.e. a software renderer would be used).\n * @param {boolean} [options.preserveDrawingBuffer=false] If `true`, the map's canvas can be exported to a PNG using `map.getCanvas().toDataURL()`. This is `false` by default as a performance optimization.\n * @param {boolean} [options.antialias] If `true`, the gl context will be created with MSAA antialiasing, which can be useful for antialiasing custom layers. this is `false` by default as a performance optimization.\n * @param {boolean} [options.refreshExpiredTiles=true] If `false`, the map won't attempt to re-request tiles once they expire per their HTTP `cacheControl`/`expires` headers.\n * @param {LngLatBoundsLike} [options.maxBounds] If set, the map will be constrained to the given bounds.\n * @param {boolean|Object} [options.scrollZoom=true] If `true`, the \"scroll to zoom\" interaction is enabled. An `Object` value is passed as options to {@link ScrollZoomHandler#enable}.\n * @param {boolean} [options.boxZoom=true] If `true`, the \"box zoom\" interaction is enabled (see {@link BoxZoomHandler}).\n * @param {boolean} [options.dragRotate=true] If `true`, the \"drag to rotate\" interaction is enabled (see {@link DragRotateHandler}).\n * @param {boolean} [options.dragPan=true] If `true`, the \"drag to pan\" interaction is enabled (see {@link DragPanHandler}).\n * @param {boolean} [options.keyboard=true] If `true`, keyboard shortcuts are enabled (see {@link KeyboardHandler}).\n * @param {boolean} [options.doubleClickZoom=true] If `true`, the \"double click to zoom\" interaction is enabled (see {@link DoubleClickZoomHandler}).\n * @param {boolean|Object} [options.touchZoomRotate=true] If `true`, the \"pinch to rotate and zoom\" interaction is enabled. An `Object` value is passed as options to {@link TouchZoomRotateHandler#enable}.\n * @param {boolean} [options.trackResize=true]  If `true`, the map will automatically resize when the browser window resizes.\n * @param {LngLatLike} [options.center=[0, 0]] The inital geographical centerpoint of the map. If `center` is not specified in the constructor options, Mapbox GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `[0, 0]` Note: Mapbox GL uses longitude, latitude coordinate order (as opposed to latitude, longitude) to match GeoJSON.\n * @param {number} [options.zoom=0] The initial zoom level of the map. If `zoom` is not specified in the constructor options, Mapbox GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `0`.\n * @param {number} [options.bearing=0] The initial bearing (rotation) of the map, measured in degrees counter-clockwise from north. If `bearing` is not specified in the constructor options, Mapbox GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `0`.\n * @param {number} [options.pitch=0] The initial pitch (tilt) of the map, measured in degrees away from the plane of the screen (0-60). If `pitch` is not specified in the constructor options, Mapbox GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `0`.\n * @param {LngLatBoundsLike} [options.bounds] The initial bounds of the map. If `bounds` is specified, it overrides `center` and `zoom` constructor options.\n * @param {Object} [options.fitBoundsOptions] A [`fitBounds`](#map#fitbounds) options object to use _only_ when fitting the initial `bounds` provided above.\n * @param {boolean} [options.renderWorldCopies=true]  If `true`, multiple copies of the world will be rendered side by side beyond -180 and 180 degrees longitude. If set to `false`:\n * - When the map is zoomed out far enough that a single representation of the world does not fill the map's entire\n * container, there will be blank space beyond 180 and -180 degrees longitude.\n * - Features that cross 180 and -180 degrees longitude will be cut in two (with one portion on the right edge of the\n * map and the other on the left edge of the map) at every zoom level.\n * @param {number} [options.maxTileCacheSize=null]  The maximum number of tiles stored in the tile cache for a given source. If omitted, the cache will be dynamically sized based on the current viewport.\n * @param {string} [options.localIdeographFontFamily='sans-serif'] Defines a CSS\n *   font-family for locally overriding generation of glyphs in the 'CJK Unified Ideographs', 'Hiragana', 'Katakana' and 'Hangul Syllables' ranges.\n *   In these ranges, font settings from the map's style will be ignored, except for font-weight keywords (light/regular/medium/bold).\n *   Set to `false`, to enable font settings from the map's style for these glyph ranges.  Note that [Mapbox Studio](https://studio.mapbox.com/) sets this value to `false` by default.\n *   The purpose of this option is to avoid bandwidth-intensive glyph server requests. (See [Use locally generated ideographs](https://www.mapbox.com/mapbox-gl-js/example/local-ideographs).)\n * @param {RequestTransformFunction} [options.transformRequest=null] A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.\n *   Expected to return an object with a `url` property and optionally `headers` and `credentials` properties.\n * @param {boolean} [options.collectResourceTiming=false] If `true`, Resource Timing API information will be collected for requests made by GeoJSON and Vector Tile web workers (this information is normally inaccessible from the main Javascript thread). Information will be returned in a `resourceTiming` property of relevant `data` events.\n * @param {number} [options.fadeDuration=300] Controls the duration of the fade-in/fade-out animation for label collisions, in milliseconds. This setting affects all symbol layers. This setting does not affect the duration of runtime styling transitions or raster tile cross-fading.\n * @param {boolean} [options.crossSourceCollisions=true] If `true`, symbols from multiple sources can collide with each other during collision detection. If `false`, collision detection is run separately for the symbols in each source.\n * @param {string} [options.accessToken=null] If specified, map will use this token instead of the one defined in mapboxgl.accessToken.\n\n * @example\n * var map = new mapboxgl.Map({\n *   container: 'map',\n *   center: [-122.420679, 37.772537],\n *   zoom: 13,\n *   style: style_object,\n *   hash: true,\n *   transformRequest: (url, resourceType)=> {\n *     if(resourceType === 'Source' && url.startsWith('http://myHost')) {\n *       return {\n *        url: url.replace('http', 'https'),\n *        headers: { 'my-custom-header': true},\n *        credentials: 'include'  // Include cookies for cross-origin requests\n *      }\n *     }\n *   }\n * });\n * @see [Display a map](https://www.mapbox.com/mapbox-gl-js/examples/)\n */\nclass Map extends Camera {\n    style: Style;\n    painter: Painter;\n\n    _container: HTMLElement;\n    _missingCSSCanary: HTMLElement;\n    _canvasContainer: HTMLElement;\n    _controlContainer: HTMLElement;\n    _controlPositions: {[string]: HTMLElement};\n    _interactive: ?boolean;\n    _showTileBoundaries: ?boolean;\n    _showCollisionBoxes: ?boolean;\n    _showOverdrawInspector: boolean;\n    _repaint: ?boolean;\n    _vertices: ?boolean;\n    _canvas: HTMLCanvasElement;\n    _maxTileCacheSize: number;\n    _frame: ?Cancelable;\n    _styleDirty: ?boolean;\n    _sourcesDirty: ?boolean;\n    _placementDirty: ?boolean;\n    _loaded: boolean;\n    _trackResize: boolean;\n    _preserveDrawingBuffer: boolean;\n    _failIfMajorPerformanceCaveat: boolean;\n    _antialias: boolean;\n    _refreshExpiredTiles: boolean;\n    _hash: Hash;\n    _delegatedListeners: any;\n    _fadeDuration: number;\n    _crossSourceCollisions: boolean;\n    _crossFadingFactor: number;\n    _collectResourceTiming: boolean;\n    _renderTaskQueue: TaskQueue;\n    _controls: Array<IControl>;\n    _mapId: number;\n    _localIdeographFontFamily: string;\n    _requestManager: RequestManager;\n\n    /**\n     * The map's {@link ScrollZoomHandler}, which implements zooming in and out with a scroll wheel or trackpad.\n     * Find more details and examples using `scrollZoom` in the {@link ScrollZoomHandler} section.\n     */\n    scrollZoom: ScrollZoomHandler;\n\n    /**\n     * The map's {@link BoxZoomHandler}, which implements zooming using a drag gesture with the Shift key pressed.\n     * Find more details and examples using `boxZoom` in the {@link BoxZoomHandler} section.\n     */\n    boxZoom: BoxZoomHandler;\n\n    /**\n     * The map's {@link DragRotateHandler}, which implements rotating the map while dragging with the right\n     * mouse button or with the Control key pressed. Find more details and examples using `dragRotate`\n     * in the {@link DragRotateHandler} section.\n     */\n    dragRotate: DragRotateHandler;\n\n    /**\n     * The map's {@link DragPanHandler}, which implements dragging the map with a mouse or touch gesture.\n     * Find more details and examples using `dragPan` in the {@link DragPanHandler} section.\n     */\n    dragPan: DragPanHandler;\n\n    /**\n     * The map's {@link KeyboardHandler}, which allows the user to zoom, rotate, and pan the map using keyboard\n     * shortcuts. Find more details and examples using `keyboard` in the {@link KeyboardHandler} section.\n     */\n    keyboard: KeyboardHandler;\n\n    /**\n     * The map's {@link DoubleClickZoomHandler}, which allows the user to zoom by double clicking.\n     * Find more details and examples using `doubleClickZoom` in the {@link DoubleClickZoomHandler} section.\n     */\n    doubleClickZoom: DoubleClickZoomHandler;\n\n    /**\n     * The map's {@link TouchZoomRotateHandler}, which allows the user to zoom or rotate the map with touch gestures.\n     * Find more details and examples using `touchZoomRotate` in the {@link TouchZoomRotateHandler} section.\n     */\n    touchZoomRotate: TouchZoomRotateHandler;\n\n    constructor(options: MapOptions) {\n        options = extend({}, defaultOptions, options);\n\n        if (options.minZoom != null && options.maxZoom != null && options.minZoom > options.maxZoom) {\n            throw new Error(`maxZoom must be greater than minZoom`);\n        }\n\n        const transform = new Transform(options.minZoom, options.maxZoom, options.renderWorldCopies);\n        super(transform, options);\n\n        this._interactive = options.interactive;\n        this._maxTileCacheSize = options.maxTileCacheSize;\n        this._failIfMajorPerformanceCaveat = options.failIfMajorPerformanceCaveat;\n        this._preserveDrawingBuffer = options.preserveDrawingBuffer;\n        this._antialias = options.antialias;\n        this._trackResize = options.trackResize;\n        this._bearingSnap = options.bearingSnap;\n        this._refreshExpiredTiles = options.refreshExpiredTiles;\n        this._fadeDuration = options.fadeDuration;\n        this._crossSourceCollisions = options.crossSourceCollisions;\n        this._crossFadingFactor = 1;\n        this._collectResourceTiming = options.collectResourceTiming;\n        this._renderTaskQueue = new TaskQueue();\n        this._controls = [];\n        this._mapId = uniqueId();\n\n        this._requestManager = new RequestManager(options.transformRequest, options.accessToken);\n\n        if (typeof options.container === 'string') {\n            this._container = window.document.getElementById(options.container);\n            if (!this._container) {\n                throw new Error(`Container '${options.container}' not found.`);\n            }\n        } else if (options.container instanceof HTMLElement) {\n            this._container = options.container;\n        } else {\n            throw new Error(`Invalid type: 'container' must be a String or HTMLElement.`);\n        }\n\n        if (options.maxBounds) {\n            this.setMaxBounds(options.maxBounds);\n        }\n\n        bindAll([\n            '_onWindowOnline',\n            '_onWindowResize',\n            '_contextLost',\n            '_contextRestored'\n        ], this);\n\n        this._setupContainer();\n        this._setupPainter();\n        if (this.painter === undefined) {\n            throw new Error(`Failed to initialize WebGL.`);\n        }\n\n        this.on('move', () => this._update(false));\n        this.on('moveend', () => this._update(false));\n        this.on('zoom', () => this._update(true));\n\n        if (typeof window !== 'undefined') {\n            window.addEventListener('online', this._onWindowOnline, false);\n            window.addEventListener('resize', this._onWindowResize, false);\n        }\n\n        bindHandlers(this, options);\n\n        const hashName = (typeof options.hash === 'string' && options.hash) || undefined;\n        this._hash = options.hash && (new Hash(hashName)).addTo(this);\n        // don't set position from options if set through hash\n        if (!this._hash || !this._hash._onHashChange()) {\n            this.jumpTo({\n                center: options.center,\n                zoom: options.zoom,\n                bearing: options.bearing,\n                pitch: options.pitch\n            });\n\n            if (options.bounds) {\n                this.resize();\n                this.fitBounds(options.bounds, extend({}, options.fitBoundsOptions, {duration: 0}));\n            }\n        }\n\n        this.resize();\n\n        this._localIdeographFontFamily = options.localIdeographFontFamily;\n        if (options.style) this.setStyle(options.style, {localIdeographFontFamily: options.localIdeographFontFamily});\n\n        if (options.attributionControl)\n            this.addControl(new AttributionControl({customAttribution: options.customAttribution}));\n\n        this.addControl(new LogoControl(), options.logoPosition);\n\n        this.on('style.load', () => {\n            if (this.transform.unmodified) {\n                this.jumpTo((this.style.stylesheet: any));\n            }\n        });\n        this.on('data', (event: MapDataEvent) => {\n            this._update(event.dataType === 'style');\n            this.fire(new Event(`${event.dataType}data`, event));\n        });\n        this.on('dataloading', (event: MapDataEvent) => {\n            this.fire(new Event(`${event.dataType}dataloading`, event));\n        });\n    }\n\n    /*\n    * Returns a unique number for this map instance which is used for the MapLoadEvent\n    * to make sure we only fire one event per instantiated map object.\n    * @private\n    * @returns {number}\n    */\n    _getMapId() {\n        return this._mapId;\n    }\n\n    /**\n     * Adds an {@link IControl} to the map, calling `control.onAdd(this)`.\n     *\n     * @param {IControl} control The {@link IControl} to add.\n     * @param {string} [position] position on the map to which the control will be added.\n     * Valid values are `'top-left'`, `'top-right'`, `'bottom-left'`, and `'bottom-right'`. Defaults to `'top-right'`.\n     * @returns {Map} `this`\n     * @example\n     * // Add zoom and rotation controls to the map.\n     * map.addControl(new mapboxgl.NavigationControl());\n     * @see [Display map navigation controls](https://www.mapbox.com/mapbox-gl-js/example/navigation/)\n     */\n    addControl(control: IControl, position?: ControlPosition) {\n        if (position === undefined && control.getDefaultPosition) {\n            position = control.getDefaultPosition();\n        }\n        if (position === undefined) {\n            position = 'top-right';\n        }\n        if (!control || !control.onAdd) {\n            return this.fire(new ErrorEvent(new Error(\n                'Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.')));\n        }\n        const controlElement = control.onAdd(this);\n        this._controls.push(control);\n\n        const positionContainer = this._controlPositions[position];\n        if (position.indexOf('bottom') !== -1) {\n            positionContainer.insertBefore(controlElement, positionContainer.firstChild);\n        } else {\n            positionContainer.appendChild(controlElement);\n        }\n        return this;\n    }\n\n    /**\n     * Removes the control from the map.\n     *\n     * @param {IControl} control The {@link IControl} to remove.\n     * @returns {Map} `this`\n     * @example\n     * // Define a new navigation control.\n     * var navigation = new mapboxgl.NavigationControl();\n     * // Add zoom and rotation controls to the map.\n     * map.addControl(navigation);\n     * // Remove zoom and rotation controls from the map.\n     * map.removeControl(navigation);\n     */\n    removeControl(control: IControl) {\n        if (!control || !control.onRemove) {\n            return this.fire(new ErrorEvent(new Error(\n                'Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.')));\n        }\n        const ci = this._controls.indexOf(control);\n        if (ci > -1) this._controls.splice(ci, 1);\n        control.onRemove(this);\n        return this;\n    }\n\n    /**\n     * Resizes the map according to the dimensions of its\n     * `container` element.\n     *\n     * Checks if the map container size changed and updates the map if it has changed.\n     * This method must be called after the map's `container` is resized programmatically\n     * or when the map is shown after being initially hidden with CSS.\n     *\n     * @param eventData Additional properties to be passed to `movestart`, `move`, `resize`, and `moveend`\n     *   events that get triggered as a result of resize. This can be useful for differentiating the\n     *   source of an event (for example, user-initiated or programmatically-triggered events).\n     * @returns {Map} `this`\n     * @example\n     * // Resize the map when the map container is shown\n     * // after being initially hidden with CSS.\n     * var mapDiv = document.getElementById('map');\n     * if (mapDiv.style.visibility === true) map.resize();\n     */\n    resize(eventData?: Object) {\n        const dimensions = this._containerDimensions();\n        const width = dimensions[0];\n        const height = dimensions[1];\n\n        this._resizeCanvas(width, height);\n        this.transform.resize(width, height);\n        this.painter.resize(width, height);\n\n        this.fire(new Event('movestart', eventData))\n            .fire(new Event('move', eventData))\n            .fire(new Event('resize', eventData))\n            .fire(new Event('moveend', eventData));\n        return this;\n    }\n\n    /**\n     * Returns the map's geographical bounds. When the bearing or pitch is non-zero, the visible region is not\n     * an axis-aligned rectangle, and the result is the smallest bounds that encompasses the visible region.\n     * @example\n     * var bounds = map.getBounds();\n     */\n    getBounds(): LngLatBounds {\n        return this.transform.getBounds();\n    }\n\n    /**\n     * Returns the maximum geographical bounds the map is constrained to, or `null` if none set.\n     * @example\n     * var maxBounds = map.getMaxBounds();\n     */\n    getMaxBounds(): LngLatBounds | null {\n        return this.transform.getMaxBounds();\n    }\n\n    /**\n     * Sets or clears the map's geographical bounds.\n     *\n     * Pan and zoom operations are constrained within these bounds.\n     * If a pan or zoom is performed that would\n     * display regions outside these bounds, the map will\n     * instead display a position and zoom level\n     * as close as possible to the operation's request while still\n     * remaining within the bounds.\n     *\n     * @param {LngLatBoundsLike | null | undefined} bounds The maximum bounds to set. If `null` or `undefined` is provided, the function removes the map's maximum bounds.\n     * @returns {Map} `this`\n     * @example\n     * // Define bounds that conform to the `LngLatBoundsLike` object.\n     * var bounds = [\n     *   [-74.04728, 40.68392], // [west, south]\n     *   [-73.91058, 40.87764]  // [east, north]\n     * ];\n     * // Set the map's max bounds.\n     * map.setMaxBounds(bounds);\n     */\n    setMaxBounds(bounds: LngLatBoundsLike) {\n        this.transform.setMaxBounds(LngLatBounds.convert(bounds));\n        return this._update();\n    }\n\n    /**\n     * Sets or clears the map's minimum zoom level.\n     * If the map's current zoom level is lower than the new minimum,\n     * the map will zoom to the new minimum.\n     *\n     * @param {number | null | undefined} minZoom The minimum zoom level to set (0-24).\n     *   If `null` or `undefined` is provided, the function removes the current minimum zoom (i.e. sets it to 0).\n     * @returns {Map} `this`\n     * @example\n     * map.setMinZoom(12.25);\n     */\n    setMinZoom(minZoom?: ?number) {\n\n        minZoom = minZoom === null || minZoom === undefined ? defaultMinZoom : minZoom;\n\n        if (minZoom >= defaultMinZoom && minZoom <= this.transform.maxZoom) {\n            this.transform.minZoom = minZoom;\n            this._update();\n\n            if (this.getZoom() < minZoom) this.setZoom(minZoom);\n\n            return this;\n\n        } else throw new Error(`minZoom must be between ${defaultMinZoom} and the current maxZoom, inclusive`);\n    }\n\n    /**\n     * Returns the map's minimum allowable zoom level.\n     *\n     * @returns {number} minZoom\n     * @example\n     * var minZoom = map.getMinZoom();\n     */\n    getMinZoom() { return this.transform.minZoom; }\n\n    /**\n     * Sets or clears the map's maximum zoom level.\n     * If the map's current zoom level is higher than the new maximum,\n     * the map will zoom to the new maximum.\n     *\n     * @param {number | null | undefined} maxZoom The maximum zoom level to set.\n     *   If `null` or `undefined` is provided, the function removes the current maximum zoom (sets it to 22).\n     * @returns {Map} `this`\n     * @example\n     * map.setMaxZoom(18.75);\n     */\n    setMaxZoom(maxZoom?: ?number) {\n\n        maxZoom = maxZoom === null || maxZoom === undefined ? defaultMaxZoom : maxZoom;\n\n        if (maxZoom >= this.transform.minZoom) {\n            this.transform.maxZoom = maxZoom;\n            this._update();\n\n            if (this.getZoom() > maxZoom) this.setZoom(maxZoom);\n\n            return this;\n\n        } else throw new Error(`maxZoom must be greater than the current minZoom`);\n    }\n\n    /**\n     * Returns the map's maximum allowable zoom level.\n     *\n     * @returns {number} maxZoom\n     * @example\n     * var maxZoom = map.getMaxZoom();\n     */\n    getMaxZoom() { return this.transform.maxZoom; }\n\n    /**\n     * Returns the state of `renderWorldCopies`. If `true`, multiple copies of the world will be rendered side by side beyond -180 and 180 degrees longitude. If set to `false`:\n     * - When the map is zoomed out far enough that a single representation of the world does not fill the map's entire\n     * container, there will be blank space beyond 180 and -180 degrees longitude.\n     * - Features that cross 180 and -180 degrees longitude will be cut in two (with one portion on the right edge of the\n     * map and the other on the left edge of the map) at every zoom level.\n     * @returns {boolean} renderWorldCopies\n     * @example\n     * var worldCopiesRendered = map.getRenderWorldCopies();\n     * @see [Render world copies](https://docs.mapbox.com/mapbox-gl-js/example/render-world-copies/)\n     */\n    getRenderWorldCopies() { return this.transform.renderWorldCopies; }\n\n    /**\n     * Sets the state of `renderWorldCopies`.\n     *\n     * @param {boolean} renderWorldCopies If `true`, multiple copies of the world will be rendered side by side beyond -180 and 180 degrees longitude. If set to `false`:\n     * - When the map is zoomed out far enough that a single representation of the world does not fill the map's entire\n     * container, there will be blank space beyond 180 and -180 degrees longitude.\n     * - Features that cross 180 and -180 degrees longitude will be cut in two (with one portion on the right edge of the\n     * map and the other on the left edge of the map) at every zoom level.\n     *\n     * `undefined` is treated as `true`, `null` is treated as `false`.\n     * @returns {Map} `this`\n     * @example\n     * map.setRenderWorldCopies(true);\n     * @see [Render world copies](https://docs.mapbox.com/mapbox-gl-js/example/render-world-copies/)\n     */\n    setRenderWorldCopies(renderWorldCopies?: ?boolean) {\n        this.transform.renderWorldCopies = renderWorldCopies;\n        return this._update();\n    }\n\n    /**\n     * Returns a {@link Point} representing pixel coordinates, relative to the map's `container`,\n     * that correspond to the specified geographical location.\n     *\n     * @param {LngLatLike} lnglat The geographical location to project.\n     * @returns {Point} The {@link Point} corresponding to `lnglat`, relative to the map's `container`.\n     * @example\n     * var coordinate = [-122.420679, 37.772537];\n     * var point = map.project(coordinate);\n     */\n    project(lnglat: LngLatLike) {\n        return this.transform.locationPoint(LngLat.convert(lnglat));\n    }\n\n    /**\n     * Returns a {@link LngLat} representing geographical coordinates that correspond\n     * to the specified pixel coordinates.\n     *\n     * @param {PointLike} point The pixel coordinates to unproject.\n     * @returns {LngLat} The {@link LngLat} corresponding to `point`.\n     * @example\n     * map.on('click', function(e) {\n     *   // When the map is clicked, get the geographic coordinate.\n     *   var coordinate = map.unproject(e.point);\n     * });\n     */\n    unproject(point: PointLike) {\n        return this.transform.pointLocation(Point.convert(point));\n    }\n\n    /**\n     * Returns true if the map is panning, zooming, rotating, or pitching due to a camera animation or user gesture.\n     * @example\n     * var isMoving = map.isMoving();\n     */\n    isMoving(): boolean {\n        return this._moving ||\n            this.dragPan.isActive() ||\n            this.dragRotate.isActive() ||\n            this.scrollZoom.isActive();\n    }\n\n    /**\n     * Returns true if the map is zooming due to a camera animation or user gesture.\n     * @example\n     * var isZooming = map.isZooming();\n     */\n    isZooming(): boolean {\n        return this._zooming ||\n            this.scrollZoom.isZooming();\n    }\n\n    /**\n     * Returns true if the map is rotating due to a camera animation or user gesture.\n     * @example\n     * map.isRotating();\n     */\n    isRotating(): boolean {\n        return this._rotating ||\n            this.dragRotate.isActive();\n    }\n\n    /**\n     * Adds a listener for events of a specified type.\n     *\n     * @method\n     * @name on\n     * @memberof Map\n     * @instance\n     * @param {string} type The event type to add a listen for.\n     * @param {Function} listener The function to be called when the event is fired.\n     *   The listener function is called with the data object passed to `fire`,\n     *   extended with `target` and `type` properties.\n     * @returns {Map} `this`\n     */\n\n    /**\n     * Adds a listener for events of a specified type occurring on features in a specified style layer.\n     *\n     * @param {string} type The event type to listen for; one of `'mousedown'`, `'mouseup'`, `'click'`, `'dblclick'`,\n     * `'mousemove'`, `'mouseenter'`, `'mouseleave'`, `'mouseover'`, `'mouseout'`, `'contextmenu'`, `'touchstart'`,\n     * `'touchend'`, or `'touchcancel'`. `mouseenter` and `mouseover` events are triggered when the cursor enters\n     * a visible portion of the specified layer from outside that layer or outside the map canvas. `mouseleave`\n     * and `mouseout` events are triggered when the cursor leaves a visible portion of the specified layer, or leaves\n     * the map canvas.\n     * @param {string} layerId The ID of a style layer. Only events whose location is within a visible\n     * feature in this layer will trigger the listener. The event will have a `features` property containing\n     * an array of the matching features.\n     * @param {Function} listener The function to be called when the event is fired.\n     * @returns {Map} `this`\n     */\n    on(type: MapEvent, layerId: any, listener: any) {\n        if (listener === undefined) {\n            return super.on(type, layerId);\n        }\n\n        const delegatedListener = (() => {\n            if (type === 'mouseenter' || type === 'mouseover') {\n                let mousein = false;\n                const mousemove = (e) => {\n                    const features = this.getLayer(layerId) ? this.queryRenderedFeatures(e.point, {layers: [layerId]}) : [];\n                    if (!features.length) {\n                        mousein = false;\n                    } else if (!mousein) {\n                        mousein = true;\n                        listener.call(this, new MapMouseEvent(type, this, e.originalEvent, {features}));\n                    }\n                };\n                const mouseout = () => {\n                    mousein = false;\n                };\n                return {layer: layerId, listener, delegates: {mousemove, mouseout}};\n            } else if (type === 'mouseleave' || type === 'mouseout') {\n                let mousein = false;\n                const mousemove = (e) => {\n                    const features = this.getLayer(layerId) ? this.queryRenderedFeatures(e.point, {layers: [layerId]}) : [];\n                    if (features.length) {\n                        mousein = true;\n                    } else if (mousein) {\n                        mousein = false;\n                        listener.call(this, new MapMouseEvent(type, this, e.originalEvent));\n                    }\n                };\n                const mouseout = (e) => {\n                    if (mousein) {\n                        mousein = false;\n                        listener.call(this, new MapMouseEvent(type, this, e.originalEvent));\n                    }\n                };\n                return {layer: layerId, listener, delegates: {mousemove, mouseout}};\n            } else {\n                const delegate = (e) => {\n                    const features = this.getLayer(layerId) ? this.queryRenderedFeatures(e.point, {layers: [layerId]}) : [];\n                    if (features.length) {\n                        // Here we need to mutate the original event, so that preventDefault works as expected.\n                        e.features = features;\n                        listener.call(this, e);\n                        delete e.features;\n                    }\n                };\n                return {layer: layerId, listener, delegates: {[type]: delegate}};\n            }\n        })();\n\n        this._delegatedListeners = this._delegatedListeners || {};\n        this._delegatedListeners[type] = this._delegatedListeners[type] || [];\n        this._delegatedListeners[type].push(delegatedListener);\n\n        for (const event in delegatedListener.delegates) {\n            this.on((event: any), delegatedListener.delegates[event]);\n        }\n\n        return this;\n    }\n\n    /**\n     * Removes an event listener previously added with `Map#on`.\n     *\n     * @method\n     * @name off\n     * @memberof Map\n     * @instance\n     * @param {string} type The event type previously used to install the listener.\n     * @param {Function} listener The function previously installed as a listener.\n     * @returns {Map} `this`\n     */\n\n    /**\n     * Removes an event listener for layer-specific events previously added with `Map#on`.\n     *\n     * @param {string} type The event type previously used to install the listener.\n     * @param {string} layerId The layer ID previously used to install the listener.\n     * @param {Function} listener The function previously installed as a listener.\n     * @returns {Map} `this`\n     */\n    off(type: MapEvent, layerId: any, listener: any) {\n        if (listener === undefined) {\n            return super.off(type, layerId);\n        }\n\n        if (this._delegatedListeners && this._delegatedListeners[type]) {\n            const listeners = this._delegatedListeners[type];\n            for (let i = 0; i < listeners.length; i++) {\n                const delegatedListener = listeners[i];\n                if (delegatedListener.layer === layerId && delegatedListener.listener === listener) {\n                    for (const event in delegatedListener.delegates) {\n                        this.off((event: any), delegatedListener.delegates[event]);\n                    }\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns an array of [GeoJSON](http://geojson.org/)\n     * [Feature objects](https://tools.ietf.org/html/rfc7946#section-3.2)\n     * representing visible features that satisfy the query parameters.\n     *\n     * @param {PointLike|Array<PointLike>} [geometry] - The geometry of the query region:\n     * either a single point or southwest and northeast points describing a bounding box.\n     * Omitting this parameter (i.e. calling {@link Map#queryRenderedFeatures} with zero arguments,\n     * or with only a `options` argument) is equivalent to passing a bounding box encompassing the entire\n     * map viewport.\n     * @param {Object} [options]\n     * @param {Array<string>} [options.layers] An array of [style layer IDs](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layer-id) for the query to inspect.\n     *   Only features within these layers will be returned. If this parameter is undefined, all layers will be checked.\n     * @param {Array} [options.filter] A [filter](https://www.mapbox.com/mapbox-gl-js/style-spec/#other-filter)\n     *   to limit query results.\n     * @param {boolean} [options.validate=true] Whether to check if the [options.filter] conforms to the Mapbox GL Style Specification. Disabling validation is a performance optimization that should only be used if you have previously validated the values you will be passing to this function.\n     *\n     * @returns {Array<Object>} An array of [GeoJSON](http://geojson.org/)\n     * [feature objects](https://tools.ietf.org/html/rfc7946#section-3.2).\n     *\n     * The `properties` value of each returned feature object contains the properties of its source feature. For GeoJSON sources, only\n     * string and numeric property values are supported (i.e. `null`, `Array`, and `Object` values are not supported).\n     *\n     * Each feature includes top-level `layer`, `source`, and `sourceLayer` properties. The `layer` property is an object\n     * representing the style layer to  which the feature belongs. Layout and paint properties in this object contain values\n     * which are fully evaluated for the given zoom level and feature.\n     *\n     * Only features that are currently rendered are included. Some features will **not** be included, like:\n     *\n     * - Features from layers whose `visibility` property is `\"none\"`.\n     * - Features from layers whose zoom range excludes the current zoom level.\n     * - Symbol features that have been hidden due to text or icon collision.\n     *\n     * Features from all other layers are included, including features that may have no visible\n     * contribution to the rendered result; for example, because the layer's opacity or color alpha component is set to\n     * 0.\n     *\n     * The topmost rendered feature appears first in the returned array, and subsequent features are sorted by\n     * descending z-order. Features that are rendered multiple times (due to wrapping across the antimeridian at low\n     * zoom levels) are returned only once (though subject to the following caveat).\n     *\n     * Because features come from tiled vector data or GeoJSON data that is converted to tiles internally, feature\n     * geometries may be split or duplicated across tile boundaries and, as a result, features may appear multiple\n     * times in query results. For example, suppose there is a highway running through the bounding rectangle of a query.\n     * The results of the query will be those parts of the highway that lie within the map tiles covering the bounding\n     * rectangle, even if the highway extends into other tiles, and the portion of the highway within each map tile\n     * will be returned as a separate feature. Similarly, a point feature near a tile boundary may appear in multiple\n     * tiles due to tile buffering.\n     *\n     * @example\n     * // Find all features at a point\n     * var features = map.queryRenderedFeatures(\n     *   [20, 35],\n     *   { layers: ['my-layer-name'] }\n     * );\n     *\n     * @example\n     * // Find all features within a static bounding box\n     * var features = map.queryRenderedFeatures(\n     *   [[10, 20], [30, 50]],\n     *   { layers: ['my-layer-name'] }\n     * );\n     *\n     * @example\n     * // Find all features within a bounding box around a point\n     * var width = 10;\n     * var height = 20;\n     * var features = map.queryRenderedFeatures([\n     *   [point.x - width / 2, point.y - height / 2],\n     *   [point.x + width / 2, point.y + height / 2]\n     * ], { layers: ['my-layer-name'] });\n     *\n     * @example\n     * // Query all rendered features from a single layer\n     * var features = map.queryRenderedFeatures({ layers: ['my-layer-name'] });\n     * @see [Get features under the mouse pointer](https://www.mapbox.com/mapbox-gl-js/example/queryrenderedfeatures/)\n     * @see [Highlight features within a bounding box](https://www.mapbox.com/mapbox-gl-js/example/using-box-queryrenderedfeatures/)\n     * @see [Filter features within map view](https://www.mapbox.com/mapbox-gl-js/example/filter-features-within-map-view/)\n     */\n    queryRenderedFeatures(geometry?: PointLike | [PointLike, PointLike], options?: Object) {\n        // The first parameter can be omitted entirely, making this effectively an overloaded method\n        // with two signatures:\n        //\n        //     queryRenderedFeatures(geometry: PointLike | [PointLike, PointLike], options?: Object)\n        //     queryRenderedFeatures(options?: Object)\n        //\n        // There no way to express that in a way that's compatible with both flow and documentation.js.\n        // Related: https://github.com/facebook/flow/issues/1556\n\n        if (!this.style) {\n            return [];\n        }\n\n        if (options === undefined && geometry !== undefined && !(geometry instanceof Point) && !Array.isArray(geometry)) {\n            options = (geometry: Object);\n            geometry = undefined;\n        }\n\n        options = options || {};\n        geometry = geometry || [[0, 0], [this.transform.width, this.transform.height]];\n\n        let queryGeometry;\n        if (geometry instanceof Point || typeof geometry[0] === 'number') {\n            queryGeometry = [Point.convert(geometry)];\n        } else {\n            const tl = Point.convert(geometry[0]);\n            const br = Point.convert(geometry[1]);\n            queryGeometry = [tl, new Point(br.x, tl.y), br, new Point(tl.x, br.y), tl];\n        }\n\n        return this.style.queryRenderedFeatures(queryGeometry, options, this.transform);\n    }\n\n    /**\n     * Returns an array of [GeoJSON](http://geojson.org/)\n     * [Feature objects](https://tools.ietf.org/html/rfc7946#section-3.2)\n     * representing features within the specified vector tile or GeoJSON source that satisfy the query parameters.\n     *\n     * @param {string} sourceId The ID of the vector tile or GeoJSON source to query.\n     * @param {Object} [parameters]\n     * @param {string} [parameters.sourceLayer] The name of the [source layer](https://docs.mapbox.com/help/glossary/source-layer/)\n     *   to query. *For vector tile sources, this parameter is required.* For GeoJSON sources, it is ignored.\n     * @param {Array} [parameters.filter] A [filter](https://www.mapbox.com/mapbox-gl-js/style-spec/#other-filter)\n     *   to limit query results.\n     * @param {boolean} [parameters.validate=true] Whether to check if the [parameters.filter] conforms to the Mapbox GL Style Specification. Disabling validation is a performance optimization that should only be used if you have previously validated the values you will be passing to this function.\n     *\n     * @returns {Array<Object>} An array of [GeoJSON](http://geojson.org/)\n     * [Feature objects](https://tools.ietf.org/html/rfc7946#section-3.2).\n     *\n     * In contrast to {@link Map#queryRenderedFeatures}, this function returns all features matching the query parameters,\n     * whether or not they are rendered by the current style (i.e. visible). The domain of the query includes all currently-loaded\n     * vector tiles and GeoJSON source tiles: this function does not check tiles outside the currently\n     * visible viewport.\n     *\n     * Because features come from tiled vector data or GeoJSON data that is converted to tiles internally, feature\n     * geometries may be split or duplicated across tile boundaries and, as a result, features may appear multiple\n     * times in query results. For example, suppose there is a highway running through the bounding rectangle of a query.\n     * The results of the query will be those parts of the highway that lie within the map tiles covering the bounding\n     * rectangle, even if the highway extends into other tiles, and the portion of the highway within each map tile\n     * will be returned as a separate feature. Similarly, a point feature near a tile boundary may appear in multiple\n     * tiles due to tile buffering.\n     *\n     * @example\n     * // Find all features in one source layer in a vector source\n     * var features = map.querySourceFeatures('your-source-id', {\n     *   sourceLayer: 'your-source-layer'\n     * });\n     *\n     * @see [Highlight features containing similar data](https://www.mapbox.com/mapbox-gl-js/example/query-similar-features/)\n     */\n    querySourceFeatures(sourceId: string, parameters: ?{sourceLayer: ?string, filter: ?Array<any>, validate?: boolean}) {\n        return this.style.querySourceFeatures(sourceId, parameters);\n    }\n\n    /**\n     * Updates the map's Mapbox style object with a new value. If a style already is set and options.diff is true,\n     * this compares the style against the map's current state and performs only the changes necessary to make\n     * the map style match the desired state.\n     *\n     * @param style A JSON object conforming to the schema described in the\n     *   [Mapbox Style Specification](https://mapbox.com/mapbox-gl-style-spec/), or a URL to such JSON.\n     * @param {Object} [options]\n     * @param {boolean} [options.diff=true] If false, force a 'full' update, removing the current style\n     *   and building the given one instead of attempting a diff-based update.\n     * @param {string} [options.localIdeographFontFamily='sans-serif'] Defines a CSS\n     *   font-family for locally overriding generation of glyphs in the 'CJK Unified Ideographs', 'Hiragana', 'Katakana' and 'Hangul Syllables' ranges.\n     *   In these ranges, font settings from the map's style will be ignored, except for font-weight keywords (light/regular/medium/bold).\n     *   Set to `false`, to enable font settings from the map's style for these glyph ranges.\n     *   Forces a full update.\n     * @returns {Map} `this`\n     * @see [Change a map's style](https://www.mapbox.com/mapbox-gl-js/example/setstyle/)\n     */\n    setStyle(style: StyleSpecification | string | null, options?: {diff?: boolean} & StyleOptions) {\n        options = extend({}, {localIdeographFontFamily: this._localIdeographFontFamily}, options);\n\n        if ((options.diff !== false && options.localIdeographFontFamily === this._localIdeographFontFamily) && this.style && style) {\n            this._diffStyle(style, options);\n            return this;\n        } else {\n            this._localIdeographFontFamily = options.localIdeographFontFamily;\n            return this._updateStyle(style, options);\n        }\n    }\n\n    _updateStyle(style: StyleSpecification | string | null,  options?: {diff?: boolean} & StyleOptions) {\n        if (this.style) {\n            this.style.setEventedParent(null);\n            this.style._remove();\n        }\n\n        if (!style) {\n            delete this.style;\n            return this;\n        } else {\n            this.style = new Style(this, options || {});\n        }\n\n        this.style.setEventedParent(this, {style: this.style});\n\n        if (typeof style === 'string') {\n            this.style.loadURL(style);\n        } else {\n            this.style.loadJSON(style);\n        }\n\n        return this;\n    }\n\n    _diffStyle(style: StyleSpecification | string,  options?: {diff?: boolean} & StyleOptions) {\n        if (typeof style === 'string') {\n            const url = this._requestManager.normalizeStyleURL(style);\n            const request = this._requestManager.transformRequest(url, ResourceType.Style);\n            getJSON(request, (error: ?Error, json: ?Object) => {\n                if (error) {\n                    this.fire(new ErrorEvent(error));\n                } else if (json) {\n                    this._updateDiff(json, options);\n                }\n            });\n        } else if (typeof style === 'object') {\n            this._updateDiff(style, options);\n        }\n    }\n\n    _updateDiff(style: StyleSpecification,  options?: {diff?: boolean} & StyleOptions) {\n        try {\n            if (this.style.setState(style)) {\n                this._update(true);\n            }\n        } catch (e) {\n            warnOnce(\n                `Unable to perform style diff: ${e.message || e.error || e}.  Rebuilding the style from scratch.`\n            );\n            this._updateStyle(style, options);\n        }\n    }\n\n    /**\n     * Returns the map's Mapbox style object, which can be used to recreate the map's style.\n     *\n     * @returns {Object} The map's style object.\n     */\n    getStyle() {\n        if (this.style) {\n            return this.style.serialize();\n        }\n    }\n\n    /**\n     * Returns a Boolean indicating whether the map's style is fully loaded.\n     *\n     * @returns {boolean} A Boolean indicating whether the style is fully loaded.\n     */\n    isStyleLoaded() {\n        if (!this.style) return warnOnce('There is no style added to the map.');\n        return this.style.loaded();\n    }\n\n    /**\n     * Adds a source to the map's style.\n     *\n     * @param {string} id The ID of the source to add. Must not conflict with existing sources.\n     * @param {Object} source The source object, conforming to the\n     * Mapbox Style Specification's [source definition](https://www.mapbox.com/mapbox-gl-style-spec/#sources) or\n     * {@link CanvasSourceOptions}.\n     * @fires source.add\n     * @returns {Map} `this`\n     * @example\n     * map.addSource('my-data', {\n     *   type: 'vector',\n     *   url: 'mapbox://myusername.tilesetid'\n     * });\n     * @example\n     * map.addSource('my-data', {\n     *   \"type\": \"geojson\",\n     *   \"data\": {\n     *     \"type\": \"Feature\",\n     *     \"geometry\": {\n     *       \"type\": \"Point\",\n     *       \"coordinates\": [-77.0323, 38.9131]\n     *     },\n     *     \"properties\": {\n     *       \"title\": \"Mapbox DC\",\n     *       \"marker-symbol\": \"monument\"\n     *     }\n     *   }\n     * });\n     * @see Vector source: [Show and hide layers](https://docs.mapbox.com/mapbox-gl-js/example/toggle-layers/)\n     * @see GeoJSON source: [Add live realtime data](https://docs.mapbox.com/mapbox-gl-js/example/live-geojson/)\n     * @see Raster DEM source: [Add hillshading](https://docs.mapbox.com/mapbox-gl-js/example/hillshade/)\n     */\n    addSource(id: string, source: SourceSpecification) {\n        this.style.addSource(id, source);\n        return this._update(true);\n    }\n\n    /**\n     * Returns a Boolean indicating whether the source is loaded.\n     *\n     * @param {string} id The ID of the source to be checked.\n     * @returns {boolean} A Boolean indicating whether the source is loaded.\n     * @example\n     * var sourceLoaded = map.isSourceLoaded('bathymetry-data');\n     */\n    isSourceLoaded(id: string) {\n        const source = this.style && this.style.sourceCaches[id];\n        if (source === undefined) {\n            this.fire(new ErrorEvent(new Error(`There is no source with ID '${id}'`)));\n            return;\n        }\n        return source.loaded();\n    }\n\n    /**\n     * Returns a Boolean indicating whether all tiles in the viewport from all sources on\n     * the style are loaded.\n     *\n     * @returns {boolean} A Boolean indicating whether all tiles are loaded.\n     * @example\n     * var tilesLoaded = map.areTilesLoaded();\n     */\n\n    areTilesLoaded() {\n        const sources = this.style && this.style.sourceCaches;\n        for (const id in sources) {\n            const source = sources[id];\n            const tiles = source._tiles;\n            for (const t in tiles) {\n                const tile = tiles[t];\n                if (!(tile.state === 'loaded' || tile.state === 'errored')) return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Adds a [custom source type](#Custom Sources), making it available for use with\n     * {@link Map#addSource}.\n     * @private\n     * @param {string} name The name of the source type; source definition objects use this name in the `{type: ...}` field.\n     * @param {Function} SourceType A {@link Source} constructor.\n     * @param {Function} callback Called when the source type is ready or with an error argument if there is an error.\n     */\n    addSourceType(name: string, SourceType: any, callback: Function) {\n        return this.style.addSourceType(name, SourceType, callback);\n    }\n\n    /**\n     * Removes a source from the map's style.\n     *\n     * @param {string} id The ID of the source to remove.\n     * @returns {Map} `this`\n     * @example\n     * map.removeSource('bathymetry-data');\n     */\n    removeSource(id: string) {\n        this.style.removeSource(id);\n        return this._update(true);\n    }\n\n    /**\n     * Returns the source with the specified ID in the map's style.\n     *\n     * @param {string} id The ID of the source to get.\n     * @returns {?Object} The style source with the specified ID, or `undefined`\n     *   if the ID corresponds to no existing sources.\n     * @example\n     * var sourceObject = map.getSource('points');\n     * @see [Create a draggable point](https://www.mapbox.com/mapbox-gl-js/example/drag-a-point/)\n     * @see [Animate a point](https://www.mapbox.com/mapbox-gl-js/example/animate-point-along-line/)\n     * @see [Add live realtime data](https://www.mapbox.com/mapbox-gl-js/example/live-geojson/)\n     */\n    getSource(id: string) {\n        return this.style.getSource(id);\n    }\n\n    /**\n     * Add an image to the style. This image can be displayed on the map like any other icon in the style's\n     * [sprite](https://docs.mapbox.com/help/glossary/sprite/) using the image's ID with\n     * [`icon-image`](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-icon-image),\n     * [`background-pattern`](https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-background-background-pattern),\n     * [`fill-pattern`](https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-fill-fill-pattern),\n     * or [`line-pattern`](https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-line-line-pattern).\n     * A {@link Map#error} event will be fired if there is not enough space in the sprite to add this image.\n     *\n     * @param id The ID of the image.\n     * @param image The image as an `HTMLImageElement`, `ImageData`, or object with `width`, `height`, and `data`\n     * properties with the same format as `ImageData`.\n     * @param options\n     * @param options.pixelRatio The ratio of pixels in the image to physical pixels on the screen\n     * @param options.sdf Whether the image should be interpreted as an SDF image\n     *\n     * @example\n     * // If the style's sprite does not already contain an image with ID 'cat',\n     * // add the image 'cat-icon.png' to the style's sprite with the ID 'cat'.\n     * if (!map.hasImage('cat')) map.addImage('cat', './cat-icon.png');\n     *\n     * @see Use `HTMLImageElement`: [Add an icon to the map](https://www.mapbox.com/mapbox-gl-js/example/add-image/)\n     * @see Use `ImageData`: [Add a generated icon to the map](https://www.mapbox.com/mapbox-gl-js/example/add-image-generated/)\n     */\n    addImage(id: string,\n             image: HTMLImageElement | ImageData | {width: number, height: number, data: Uint8Array | Uint8ClampedArray} | StyleImageInterface,\n             {pixelRatio = 1, sdf = false}: {pixelRatio?: number, sdf?: boolean} = {}) {\n\n        const version = 0;\n\n        if (image instanceof HTMLImageElement) {\n            const {width, height, data} = browser.getImageData(image);\n            this.style.addImage(id, {data: new RGBAImage({width, height}, data), pixelRatio, sdf, version});\n        } else if (image.width === undefined || image.height === undefined) {\n            return this.fire(new ErrorEvent(new Error(\n                'Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, ' +\n                'or object with `width`, `height`, and `data` properties with the same format as `ImageData`')));\n        } else {\n            const {width, height, data} = image;\n            const userImage = ((image: any): StyleImageInterface);\n\n            this.style.addImage(id, {\n                data: new RGBAImage({width, height}, new Uint8Array(data)),\n                pixelRatio,\n                sdf,\n                version,\n                userImage\n            });\n\n            if (userImage.onAdd) {\n                userImage.onAdd(this, id);\n            }\n        }\n    }\n\n    /**\n     * Update an existing image in a style. This image can be displayed on the map like any other icon in the style's\n     * [sprite](https://docs.mapbox.com/help/glossary/sprite/) using the image's ID with\n     * [`icon-image`](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layout-symbol-icon-image),\n     * [`background-pattern`](https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-background-background-pattern),\n     * [`fill-pattern`](https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-fill-fill-pattern),\n     * or [`line-pattern`](https://docs.mapbox.com/mapbox-gl-js/style-spec/#paint-line-line-pattern).\n     *\n     * @param id The ID of the image.\n     * @param image The image as an `HTMLImageElement`, `ImageData`, or object with `width`, `height`, and `data`\n     * properties with the same format as `ImageData`.\n     *\n     * @example\n     * // If an image with the ID 'cat' already exists in the style's sprite,\n     * // replace that image with a new image, 'other-cat-icon.png'.\n     * if (map.hasImage('cat')) map.updateImage('cat', './other-cat-icon.png');\n     */\n    updateImage(id: string,\n        image: HTMLImageElement | ImageData | {width: number, height: number, data: Uint8Array | Uint8ClampedArray} | StyleImageInterface) {\n\n        const existingImage = this.style.getImage(id);\n        if (!existingImage) {\n            return this.fire(new ErrorEvent(new Error(\n                'The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.')));\n        }\n\n        const imageData = image instanceof HTMLImageElement ? browser.getImageData(image) : image;\n        const {width, height, data} = imageData;\n\n        if (width === undefined || height === undefined) {\n            return this.fire(new ErrorEvent(new Error(\n                'Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, ' +\n                'or object with `width`, `height`, and `data` properties with the same format as `ImageData`')));\n        }\n\n        if (width !== existingImage.data.width || height !== existingImage.data.height) {\n            return this.fire(new ErrorEvent(new Error(\n                'The width and height of the updated image must be that same as the previous version of the image')));\n        }\n\n        const copy = !(image instanceof HTMLImageElement);\n        existingImage.data.replace(data, copy);\n\n        this.style.updateImage(id, existingImage);\n    }\n\n    /**\n     * Check whether or not an image with a specific ID exists in the style. This checks both images\n     * in the style's original [sprite](https://docs.mapbox.com/help/glossary/sprite/) and any images\n     * that have been added at runtime using {@link addImage}.\n     *\n     * @param id The ID of the image.\n     *\n     * @returns {boolean}  A Boolean indicating whether the image exists.\n     * @example\n     * // Check if an image with the ID 'cat' exists in\n     * // the style's sprite.\n     * var catIconExists = map.hasImage('cat');\n     */\n    hasImage(id: string): boolean {\n        if (!id) {\n            this.fire(new ErrorEvent(new Error('Missing required image id')));\n            return false;\n        }\n\n        return !!this.style.getImage(id);\n    }\n\n    /**\n     * Remove an image from a style. This can be an image from the style's original\n     * [sprite](https://docs.mapbox.com/help/glossary/sprite/) or any images\n     * that have been added at runtime using {@link addImage}.\n     *\n     * @param id The ID of the image.\n     *\n     * @example\n     * // If an image with the ID 'cat' exists in\n     * // the style's sprite, remove it.\n     * if (map.hasImage('cat')) map.removeImage('cat');\n     */\n    removeImage(id: string) {\n        this.style.removeImage(id);\n    }\n\n    /**\n     * Load an image from an external URL to be used with `Map#addImage`. External\n     * domains must support [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS).\n     *\n     * @param {string} url The URL of the image file. Image file must be in png, webp, or jpg format.\n     * @param {Function} callback Expecting `callback(error, data)`. Called when the image has loaded or with an error argument if there is an error.\n     *\n     * @example\n     * // Load an image from an external URL.\n     * map.loadImage('http://placekitten.com/50/50', function(error, image) {\n     *   if (error) throw error;\n     *   // Add the loaded image to the style's sprite with the ID 'kitten'.\n     *   map.addImage('kitten', image);\n     * });\n     *\n     * @see [Add an icon to the map](https://www.mapbox.com/mapbox-gl-js/example/add-image/)\n     */\n    loadImage(url: string, callback: Function) {\n        getImage(this._requestManager.transformRequest(url, ResourceType.Image), callback);\n    }\n\n    /**\n    * Returns an Array of strings containing the IDs of all images currently available in the map.\n    * This includes both images from the style's original [sprite](https://docs.mapbox.com/help/glossary/sprite/)\n    * and any images that have been added at runtime using {@link addImage}.\n    *\n    * @returns {Array<string>} An Array of strings containing the names of all sprites/images currently available in the map.\n    *\n    * @example\n    * var allImages = map.listImages();\n    *\n    */\n    listImages() {\n        return this.style.listImages();\n    }\n\n    /**\n     * Adds a [Mapbox style layer](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers)\n     * to the map's style.\n     *\n     * A layer defines how data from a specified source will be styled. Read more about layer types\n     * and available paint and layout properties in the [Mapbox Style Specification](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers).\n     *\n     * @param {Object | CustomLayerInterface} layer The style layer to add, conforming to the Mapbox Style Specification's\n     *   [layer definition](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layers).\n     * @param {string} [beforeId] The ID of an existing layer to insert the new layer before.\n     *   If this argument is omitted, the layer will be appended to the end of the layers array.\n     *\n     * @returns {Map} `this`\n     *\n     * @example\n     * // Add a circle layer with a vector source.\n     * map.addLayer({\n     *   id: 'points-of-interest',\n     *   source: {\n     *     type: 'vector',\n     *     url: 'mapbox://mapbox.mapbox-streets-v8'\n     *   },\n     *   'source-layer': 'poi_label',\n     *   type: 'circle',\n     *   paint: {\n     *     // Mapbox Style Specification paint properties\n     *   },\n     *   layout: {\n     *     // Mapbox Style Specification layout properties\n     *   }\n     * });\n     *\n     * @see [Create and style clusters](https://www.mapbox.com/mapbox-gl-js/example/cluster/)\n     * @see [Add a vector tile source](https://www.mapbox.com/mapbox-gl-js/example/vector-source/)\n     * @see [Add a WMS source](https://www.mapbox.com/mapbox-gl-js/example/wms/)\n     */\n    addLayer(layer: LayerSpecification | CustomLayerInterface, beforeId?: string) {\n        this.style.addLayer(layer, beforeId);\n        return this._update(true);\n    }\n\n    /**\n     * Moves a layer to a different z-position.\n     *\n     * @param {string} id The ID of the layer to move.\n     * @param {string} [beforeId] The ID of an existing layer to insert the new layer before.\n     *   If this argument is omitted, the layer will be appended to the end of the layers array.\n     * @returns {Map} `this`\n     *\n     * @example\n     * // Move a layer with ID 'label' before the layer with ID 'waterways'.\n     * map.moveLayer('label', 'waterways');\n     */\n    moveLayer(id: string, beforeId?: string) {\n        this.style.moveLayer(id, beforeId);\n        return this._update(true);\n    }\n\n    /**\n     * Removes the layer with the given ID from the map's style.\n     *\n     * If no such layer exists, an `error` event is fired.\n     *\n     * @param {string} id id of the layer to remove\n     * @fires error\n     *\n     * @example\n     * // If a layer with ID 'state-data' exists, remove it.\n     * if (map.getLayer('state-data')) map.removeLayer('state-data');\n     */\n    removeLayer(id: string) {\n        this.style.removeLayer(id);\n        return this._update(true);\n    }\n\n    /**\n     * Returns the layer with the specified ID in the map's style.\n     *\n     * @param {string} id The ID of the layer to get.\n     * @returns {?Object} The layer with the specified ID, or `undefined`\n     *   if the ID corresponds to no existing layers.\n     *\n     * @example\n     * var stateDataLayer = map.getLayer('state-data');\n     *\n     * @see [Filter symbols by toggling a list](https://www.mapbox.com/mapbox-gl-js/example/filter-markers/)\n     * @see [Filter symbols by text input](https://www.mapbox.com/mapbox-gl-js/example/filter-markers-by-input/)\n     */\n    getLayer(id: string) {\n        return this.style.getLayer(id);\n    }\n\n    /**\n     * Sets the zoom extent for the specified style layer. The zoom extent includes the\n     * [minimum zoom level](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layer-minzoom)\n     * and [maximum zoom level](https://docs.mapbox.com/mapbox-gl-js/style-spec/#layer-maxzoom))\n     * at which the layer will be rendered.\n     *\n     * Note: For style layers using vector sources, style layers cannot be rendered at zoom levels lower than the\n     * minimum zoom level of the _source layer_ because the data does not exist at those zoom levels. If the minimum\n     * zoom level of the source layer is higher than the minimum zoom level defined in the style layer, the style\n     * layer will not be rendered at all zoom levels in the zoom range.\n     *\n     * @param {string} layerId The ID of the layer to which the zoom extent will be applied.\n     * @param {number} minzoom The minimum zoom to set (0-24).\n     * @param {number} maxzoom The maximum zoom to set (0-24).\n     * @returns {Map} `this`\n     *\n     * @example\n     * map.setLayerZoomRange('my-layer', 2, 5);\n     *\n     */\n    setLayerZoomRange(layerId: string, minzoom: number, maxzoom: number) {\n        this.style.setLayerZoomRange(layerId, minzoom, maxzoom);\n        return this._update(true);\n    }\n\n    /**\n     * Sets the filter for the specified style layer.\n     *\n     * @param {string} layerId The ID of the layer to which the filter will be applied.\n     * @param {Array | null | undefined} filter The filter, conforming to the Mapbox Style Specification's\n     *   [filter definition](https://www.mapbox.com/mapbox-gl-js/style-spec/#other-filter).  If `null` or `undefined` is provided, the function removes any existing filter from the layer.\n     * @param {Object} [options]\n     * @param {boolean} [options.validate=true] Whether to check if the filter conforms to the Mapbox GL Style Specification. Disabling validation is a performance optimization that should only be used if you have previously validated the values you will be passing to this function.\n     *\n     * @returns {Map} `this`\n     * @example\n     * map.setFilter('my-layer', ['==', 'name', 'USA']);\n     *\n     * @see [Filter features within map view](https://www.mapbox.com/mapbox-gl-js/example/filter-features-within-map-view/)\n     * @see [Highlight features containing similar data](https://www.mapbox.com/mapbox-gl-js/example/query-similar-features/)\n     * @see [Create a timeline animation](https://www.mapbox.com/mapbox-gl-js/example/timeline-animation/)\n     */\n    setFilter(layerId: string, filter: ?FilterSpecification,  options: StyleSetterOptions = {}) {\n        this.style.setFilter(layerId, filter, options);\n        return this._update(true);\n    }\n\n    /**\n     * Returns the filter applied to the specified style layer.\n     *\n     * @param {string} layerId The ID of the style layer whose filter to get.\n     * @returns {Array} The layer's filter.\n     */\n    getFilter(layerId: string) {\n        return this.style.getFilter(layerId);\n    }\n\n    /**\n     * Sets the value of a paint property in the specified style layer.\n     *\n     * @param {string} layerId The ID of the layer to set the paint property in.\n     * @param {string} name The name of the paint property to set.\n     * @param {*} value The value of the paint property to set.\n     *   Must be of a type appropriate for the property, as defined in the [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/).\n     * @param {Object} [options]\n     * @param {boolean} [options.validate=true] Whether to check if `value` conforms to the Mapbox GL Style Specification. Disabling validation is a performance optimization that should only be used if you have previously validated the values you will be passing to this function.\n     * @returns {Map} `this`\n     * @example\n     * map.setPaintProperty('my-layer', 'fill-color', '#faafee');\n     * @see [Change a layer's color with buttons](https://www.mapbox.com/mapbox-gl-js/example/color-switcher/)\n     * @see [Adjust a layer's opacity](https://www.mapbox.com/mapbox-gl-js/example/adjust-layer-opacity/)\n     * @see [Create a draggable point](https://www.mapbox.com/mapbox-gl-js/example/drag-a-point/)\n     */\n    setPaintProperty(layerId: string, name: string, value: any, options: StyleSetterOptions = {}) {\n        this.style.setPaintProperty(layerId, name, value, options);\n        return this._update(true);\n    }\n\n    /**\n     * Returns the value of a paint property in the specified style layer.\n     *\n     * @param {string} layerId The ID of the layer to get the paint property from.\n     * @param {string} name The name of a paint property to get.\n     * @returns {*} The value of the specified paint property.\n     */\n    getPaintProperty(layerId: string, name: string) {\n        return this.style.getPaintProperty(layerId, name);\n    }\n\n    /**\n     * Sets the value of a layout property in the specified style layer.\n     *\n     * @param {string} layerId The ID of the layer to set the layout property in.\n     * @param {string} name The name of the layout property to set.\n     * @param {*} value The value of the layout property. Must be of a type appropriate for the property, as defined in the [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/).\n     * @param {Object} [options]\n     * @param {boolean} [options.validate=true] Whether to check if `value` conforms to the Mapbox GL Style Specification. Disabling validation is a performance optimization that should only be used if you have previously validated the values you will be passing to this function.\n     * @returns {Map} `this`\n     * @example\n     * map.setLayoutProperty('my-layer', 'visibility', 'none');\n     */\n    setLayoutProperty(layerId: string, name: string, value: any, options: StyleSetterOptions = {}) {\n        this.style.setLayoutProperty(layerId, name, value, options);\n        return this._update(true);\n    }\n\n    /**\n     * Returns the value of a layout property in the specified style layer.\n     *\n     * @param {string} layerId The ID of the layer to get the layout property from.\n     * @param {string} name The name of the layout property to get.\n     * @returns {*} The value of the specified layout property.\n     */\n    getLayoutProperty(layerId: string, name: string) {\n        return this.style.getLayoutProperty(layerId, name);\n    }\n\n    /**\n     * Sets the any combination of light values.\n     *\n     * @param light Light properties to set. Must conform to the [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#light).\n     * @param {Object} [options]\n     * @param {boolean} [options.validate=true] Whether to check if the filter conforms to the Mapbox GL Style Specification. Disabling validation is a performance optimization that should only be used if you have previously validated the values you will be passing to this function.\n     * @returns {Map} `this`\n     */\n    setLight(light: LightSpecification, options: StyleSetterOptions = {}) {\n        this.style.setLight(light, options);\n        return this._update(true);\n    }\n\n    /**\n     * Returns the value of the light object.\n     *\n     * @returns {Object} light Light properties of the style.\n     */\n    getLight() {\n        return this.style.getLight();\n    }\n\n    /**\n     * Sets the state of a feature. The `state` object is merged in with the existing state of the feature.\n     * Features are identified by their `id` attribute, which must be an integer or a string that can be\n     * cast to an integer.\n     *\n     * @param {Object} feature Feature identifier. Feature objects returned from\n     * {@link Map#queryRenderedFeatures} or event handlers can be used as feature identifiers.\n     * @param {string | number} feature.id Unique id of the feature.\n     * @param {string} feature.source The Id of the vector source or GeoJSON source for the feature.\n     * @param {string} [feature.sourceLayer] (optional)  *For vector tile sources, the sourceLayer is\n     *  required.*\n     * @param {Object} state A set of key-value pairs. The values should be valid JSON types.\n     *\n     * This method requires the `feature.id` attribute on data sets. For GeoJSON sources without\n     * feature ids, set the `generateId` option in the `GeoJSONSourceSpecification` to auto-assign them. This\n     * option assigns ids based on a feature's index in the source data. If you change feature data using\n     * `map.getSource('some id').setData(..)`, you may need to re-apply state taking into account updated `id` values.\n     */\n    setFeatureState(feature: { source: string; sourceLayer?: string; id: string | number; }, state: Object) {\n        this.style.setFeatureState(feature, state);\n        return this._update();\n    }\n\n    /**\n     * Removes feature state, setting it back to the default behavior. If only\n     * source is specified, removes all states of that source. If\n     * target.id is also specified, removes all keys for that feature's state.\n     * If key is also specified, removes that key from that feature's state.\n     * Features are identified by their `id` attribute, which must be an integer or a string that can be\n     * cast to an integer.\n     * @param {Object} target Identifier of where to set state: can be a source, a feature, or a specific key of feature.\n     * Feature objects returned from {@link Map#queryRenderedFeatures} or event handlers can be used as feature identifiers.\n     * @param {string | number} target.id (optional) Unique id of the feature. Optional if key is not specified.\n     * @param {string} target.source The Id of the vector source or GeoJSON source for the feature.\n     * @param {string} [target.sourceLayer] (optional)  *For vector tile sources, the sourceLayer is\n     *  required.*\n     * @param {string} key (optional) The key in the feature state to reset.\n    */\n    removeFeatureState(target: { source: string; sourceLayer?: string; id?: string | number; }, key?: string) {\n        this.style.removeFeatureState(target, key);\n        return this._update();\n    }\n\n    /**\n     * Gets the state of a feature.\n     * Features are identified by their `id` attribute, which must be an integer or a string that can be\n     * cast to an integer.\n     *\n     * @param {Object} feature Feature identifier. Feature objects returned from\n     * {@link Map#queryRenderedFeatures} or event handlers can be used as feature identifiers.\n     * @param {string | number} feature.id Unique id of the feature.\n     * @param {string} feature.source The Id of the vector source or GeoJSON source for the feature.\n     * @param {string} [feature.sourceLayer] (optional)  *For vector tile sources, the sourceLayer is\n     *  required.*\n     *\n     * @returns {Object} The state of the feature.\n     */\n    getFeatureState(feature: { source: string; sourceLayer?: string; id: string | number; }): any {\n        return this.style.getFeatureState(feature);\n    }\n\n    /**\n     * Returns the map's containing HTML element.\n     *\n     * @returns {HTMLElement} The map's container.\n     */\n    getContainer() {\n        return this._container;\n    }\n\n    /**\n     * Returns the HTML element containing the map's `<canvas>` element.\n     *\n     * If you want to add non-GL overlays to the map, you should append them to this element.\n     *\n     * This is the element to which event bindings for map interactivity (such as panning and zooming) are\n     * attached. It will receive bubbled events from child elements such as the `<canvas>`, but not from\n     * map controls.\n     *\n     * @returns {HTMLElement} The container of the map's `<canvas>`.\n     * @see [Create a draggable point](https://www.mapbox.com/mapbox-gl-js/example/drag-a-point/)\n     * @see [Highlight features within a bounding box](https://www.mapbox.com/mapbox-gl-js/example/using-box-queryrenderedfeatures/)\n     */\n    getCanvasContainer() {\n        return this._canvasContainer;\n    }\n\n    /**\n     * Returns the map's `<canvas>` element.\n     *\n     * @returns {HTMLCanvasElement} The map's `<canvas>` element.\n     * @see [Measure distances](https://www.mapbox.com/mapbox-gl-js/example/measure/)\n     * @see [Display a popup on hover](https://www.mapbox.com/mapbox-gl-js/example/popup-on-hover/)\n     * @see [Center the map on a clicked symbol](https://www.mapbox.com/mapbox-gl-js/example/center-on-symbol/)\n     */\n    getCanvas() {\n        return this._canvas;\n    }\n\n    _containerDimensions() {\n        let width = 0;\n        let height = 0;\n\n        if (this._container) {\n            width = this._container.clientWidth || 400;\n            height = this._container.clientHeight || 300;\n        }\n\n        return [width, height];\n    }\n\n    _detectMissingCSS(): void {\n        const computedColor = window.getComputedStyle(this._missingCSSCanary).getPropertyValue('background-color');\n        if (computedColor !== 'rgb(250, 128, 114)') {\n            warnOnce('This page appears to be missing CSS declarations for ' +\n                'Mapbox GL JS, which may cause the map to display incorrectly. ' +\n                'Please ensure your page includes mapbox-gl.css, as described ' +\n                'in https://www.mapbox.com/mapbox-gl-js/api/.');\n        }\n    }\n\n    _setupContainer() {\n        const container = this._container;\n        container.classList.add('mapboxgl-map');\n\n        const missingCSSCanary = this._missingCSSCanary = DOM.create('div', 'mapboxgl-canary', container);\n        missingCSSCanary.style.visibility = 'hidden';\n        this._detectMissingCSS();\n\n        const canvasContainer = this._canvasContainer = DOM.create('div', 'mapboxgl-canvas-container', container);\n        if (this._interactive) {\n            canvasContainer.classList.add('mapboxgl-interactive');\n        }\n\n        this._canvas = DOM.create('canvas', 'mapboxgl-canvas', canvasContainer);\n        this._canvas.style.position = 'absolute';\n        this._canvas.addEventListener('webglcontextlost', this._contextLost, false);\n        this._canvas.addEventListener('webglcontextrestored', this._contextRestored, false);\n        this._canvas.setAttribute('tabindex', '0');\n        this._canvas.setAttribute('aria-label', 'Map');\n\n        const dimensions = this._containerDimensions();\n        this._resizeCanvas(dimensions[0], dimensions[1]);\n\n        const controlContainer = this._controlContainer = DOM.create('div', 'mapboxgl-control-container', container);\n        const positions = this._controlPositions = {};\n        ['top-left', 'top-right', 'bottom-left', 'bottom-right'].forEach((positionName) => {\n            positions[positionName] = DOM.create('div', `mapboxgl-ctrl-${positionName}`, controlContainer);\n        });\n    }\n\n    _resizeCanvas(width: number, height: number) {\n        const pixelRatio = window.devicePixelRatio || 1;\n\n        // Request the required canvas size taking the pixelratio into account.\n        this._canvas.width = pixelRatio * width;\n        this._canvas.height = pixelRatio * height;\n\n        // Maintain the same canvas size, potentially downscaling it for HiDPI displays\n        this._canvas.style.width = `${width}px`;\n        this._canvas.style.height = `${height}px`;\n    }\n\n    _setupPainter() {\n        const attributes = extend({}, isSupported.webGLContextAttributes, {\n            failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,\n            preserveDrawingBuffer: this._preserveDrawingBuffer,\n            antialias: this._antialias || false\n        });\n\n        const gl = this._canvas.getContext('webgl', attributes) ||\n            this._canvas.getContext('experimental-webgl', attributes);\n\n        if (!gl) {\n            this.fire(new ErrorEvent(new Error('Failed to initialize WebGL')));\n            return;\n        }\n\n        this.painter = new Painter(gl, this.transform);\n\n        webpSupported.testSupport(gl);\n    }\n\n    _contextLost(event: *) {\n        event.preventDefault();\n        if (this._frame) {\n            this._frame.cancel();\n            this._frame = null;\n        }\n        this.fire(new Event('webglcontextlost', {originalEvent: event}));\n    }\n\n    _contextRestored(event: *) {\n        this._setupPainter();\n        this.resize();\n        this._update();\n        this.fire(new Event('webglcontextrestored', {originalEvent: event}));\n    }\n\n    /**\n     * Returns a Boolean indicating whether the map is fully loaded.\n     *\n     * Returns `false` if the style is not yet fully loaded,\n     * or if there has been a change to the sources or style that\n     * has not yet fully loaded.\n     *\n     * @returns {boolean} A Boolean indicating whether the map is fully loaded.\n     */\n    loaded() {\n        return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();\n    }\n\n    /**\n     * Update this map's style and sources, and re-render the map.\n     *\n     * @param {boolean} updateStyle mark the map's style for reprocessing as\n     * well as its sources\n     * @returns {Map} this\n     * @private\n     */\n    _update(updateStyle?: boolean) {\n        if (!this.style) return this;\n\n        this._styleDirty = this._styleDirty || updateStyle;\n        this._sourcesDirty = true;\n        this.triggerRepaint();\n\n        return this;\n    }\n\n    /**\n     * Request that the given callback be executed during the next render\n     * frame.  Schedule a render frame if one is not already scheduled.\n     * @returns An id that can be used to cancel the callback\n     * @private\n     */\n    _requestRenderFrame(callback: () => void): TaskID {\n        this._update();\n        return this._renderTaskQueue.add(callback);\n    }\n\n    _cancelRenderFrame(id: TaskID) {\n        this._renderTaskQueue.remove(id);\n    }\n\n    /**\n     * Call when a (re-)render of the map is required:\n     * - The style has changed (`setPaintProperty()`, etc.)\n     * - Source data has changed (e.g. tiles have finished loading)\n     * - The map has is moving (or just finished moving)\n     * - A transition is in progress\n     *\n     * @returns {Map} this\n     * @private\n     */\n    _render() {\n        // A custom layer may have used the context asynchronously. Mark the state as dirty.\n        this.painter.context.setDirty();\n        this.painter.setBaseState();\n\n        this._renderTaskQueue.run();\n\n        let crossFading = false;\n\n        // If the style has changed, the map is being zoomed, or a transition or fade is in progress:\n        //  - Apply style changes (in a batch)\n        //  - Recalculate paint properties.\n        if (this.style && this._styleDirty) {\n            this._styleDirty = false;\n\n            const zoom = this.transform.zoom;\n            const now = browser.now();\n            this.style.zoomHistory.update(zoom, now);\n\n            const parameters = new EvaluationParameters(zoom, {\n                now,\n                fadeDuration: this._fadeDuration,\n                zoomHistory: this.style.zoomHistory,\n                transition: this.style.getTransition()\n            });\n\n            const factor = parameters.crossFadingFactor();\n            if (factor !== 1 || factor !== this._crossFadingFactor) {\n                crossFading = true;\n                this._crossFadingFactor = factor;\n            }\n\n            this.style.update(parameters);\n        }\n\n        // If we are in _render for any reason other than an in-progress paint\n        // transition, update source caches to check for and load any tiles we\n        // need for the current transform\n        if (this.style && this._sourcesDirty) {\n            this._sourcesDirty = false;\n            this.style._updateSources(this.transform);\n        }\n\n        this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions);\n\n        // Actually draw\n        this.painter.render(this.style, {\n            showTileBoundaries: this.showTileBoundaries,\n            showOverdrawInspector: this._showOverdrawInspector,\n            rotating: this.isRotating(),\n            zooming: this.isZooming(),\n            moving: this.isMoving(),\n            fadeDuration: this._fadeDuration\n        });\n\n        this.fire(new Event('render'));\n\n        if (this.loaded() && !this._loaded) {\n            this._loaded = true;\n            this.fire(new Event('load'));\n        }\n\n        if (this.style && (this.style.hasTransitions() || crossFading)) {\n            this._styleDirty = true;\n        }\n\n        if (this.style && !this._placementDirty) {\n            // Since no fade operations are in progress, we can release\n            // all tiles held for fading. If we didn't do this, the tiles\n            // would just sit in the SourceCaches until the next render\n            this.style._releaseSymbolFadeTiles();\n        }\n\n        // Schedule another render frame if it's needed.\n        //\n        // Even though `_styleDirty` and `_sourcesDirty` are reset in this\n        // method, synchronous events fired during Style#update or\n        // Style#_updateSources could have caused them to be set again.\n        if (this._sourcesDirty || this._repaint || this._styleDirty || this._placementDirty) {\n            this.triggerRepaint();\n        } else if (!this.isMoving() && this.loaded()) {\n            this.fire(new Event('idle'));\n        }\n        return this;\n    }\n\n    /**\n     * Clean up and release all internal resources associated with this map.\n     *\n     * This includes DOM elements, event bindings, web workers, and WebGL resources.\n     *\n     * Use this method when you are done using the map and wish to ensure that it no\n     * longer consumes browser resources. Afterwards, you must not call any other\n     * methods on the map.\n     */\n    remove() {\n        if (this._hash) this._hash.remove();\n\n        for (const control of this._controls) control.onRemove(this);\n        this._controls = [];\n\n        if (this._frame) {\n            this._frame.cancel();\n            this._frame = null;\n        }\n        this._renderTaskQueue.clear();\n        this.setStyle(null);\n        if (typeof window !== 'undefined') {\n            window.removeEventListener('resize', this._onWindowResize, false);\n            window.removeEventListener('online', this._onWindowOnline, false);\n        }\n\n        const extension = this.painter.context.gl.getExtension('WEBGL_lose_context');\n        if (extension) extension.loseContext();\n        removeNode(this._canvasContainer);\n        removeNode(this._controlContainer);\n        removeNode(this._missingCSSCanary);\n        this._container.classList.remove('mapboxgl-map');\n        this.fire(new Event('remove'));\n    }\n\n    /**\n     * Trigger the rendering of a single frame. Use this method with custom layers to\n     * repaint the map when the layer changes. Calling this multiple times before the\n     * next frame is rendered will still result in only a single frame being rendered.\n     */\n    triggerRepaint() {\n        if (this.style && !this._frame) {\n            this._frame = browser.frame(() => {\n                this._frame = null;\n                this._render();\n            });\n        }\n    }\n\n    _onWindowOnline() {\n        this._update();\n    }\n\n    _onWindowResize(event: Event) {\n        if (this._trackResize) {\n            this.resize({originalEvent: event})._update();\n        }\n    }\n\n    /**\n     * Store a draw callback to be used by a `custom-webgl` layer.\n     *\n     * @param {string} id The ID of the `custom-webgl` layer.\n     * @param {Function} callback The callback to be attached to the layer. When called, the callback will receive the WebGL context and a invalidator function that should be called every time that the WebGL context is modified asynchronously.\n     */\n    setCustomWebGLDrawCallback(id: string, callback: Function) {\n        this.painter.setCustomWebGLDrawCallback(id, callback);\n    }\n\n    /**\n     * Gets and sets a Boolean indicating whether the map will render an outline\n     * around each tile and the tile ID. These tile boundaries are useful for\n     * debugging.\n     *\n     * The uncompressed file size of the first vector source is drawn in the top left\n     * corner of each tile, next to the tile ID.\n     *\n     * @name showTileBoundaries\n     * @type {boolean}\n     * @instance\n     * @memberof Map\n     */\n    get showTileBoundaries(): boolean { return !!this._showTileBoundaries; }\n    set showTileBoundaries(value: boolean) {\n        if (this._showTileBoundaries === value) return;\n        this._showTileBoundaries = value;\n        this._update();\n    }\n\n    /**\n     * Gets and sets a Boolean indicating whether the map will render boxes\n     * around all symbols in the data source, revealing which symbols\n     * were rendered or which were hidden due to collisions.\n     * This information is useful for debugging.\n     *\n     * @name showCollisionBoxes\n     * @type {boolean}\n     * @instance\n     * @memberof Map\n     */\n    get showCollisionBoxes(): boolean { return !!this._showCollisionBoxes; }\n    set showCollisionBoxes(value: boolean) {\n        if (this._showCollisionBoxes === value) return;\n        this._showCollisionBoxes = value;\n        if (value) {\n            // When we turn collision boxes on we have to generate them for existing tiles\n            // When we turn them off, there's no cost to leaving existing boxes in place\n            this.style._generateCollisionBoxes();\n        } else {\n            // Otherwise, call an update to remove collision boxes\n            this._update();\n        }\n    }\n\n    /*\n     * Gets and sets a Boolean indicating whether the map should color-code\n     * each fragment to show how many times it has been shaded.\n     * White fragments have been shaded 8 or more times.\n     * Black fragments have been shaded 0 times.\n     * This information is useful for debugging.\n     *\n     * @name showOverdraw\n     * @type {boolean}\n     * @instance\n     * @memberof Map\n     */\n    get showOverdrawInspector(): boolean { return !!this._showOverdrawInspector; }\n    set showOverdrawInspector(value: boolean) {\n        if (this._showOverdrawInspector === value) return;\n        this._showOverdrawInspector = value;\n        this._update();\n    }\n\n    /**\n     * Gets and sets a Boolean indicating whether the map will\n     * continuously repaint. This information is useful for analyzing performance.\n     *\n     * @name repaint\n     * @type {boolean}\n     * @instance\n     * @memberof Map\n     */\n    get repaint(): boolean { return !!this._repaint; }\n    set repaint(value: boolean) {\n        if (this._repaint !== value) {\n            this._repaint = value;\n            this.triggerRepaint();\n        }\n    }\n    // show vertices\n    get vertices(): boolean { return !!this._vertices; }\n    set vertices(value: boolean) { this._vertices = value; this._update(); }\n\n    // for cache browser tests\n    _setCacheLimits(limit: number, checkThreshold: number) {\n        setCacheLimits(limit, checkThreshold);\n    }\n\n    /**\n     * The version of Mapbox GL JS in use as specified in package.json, CHANGELOG.md, and the GitHub release.\n     *\n     * @name version\n     * @instance\n     * @memberof Map\n     * @var {string} version\n     */\n\n    get version(): string { return version; }\n}\n\nexport default Map;\n\nfunction removeNode(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\n\n/**\n * Interface for interactive controls added to the map. This is a\n * specification for implementers to model: it is not\n * an exported method or class.\n *\n * Controls must implement `onAdd` and `onRemove`, and must own an\n * element, which is often a `div` element. To use Mapbox GL JS's\n * default control styling, add the `mapboxgl-ctrl` class to your control's\n * node.\n *\n * @interface IControl\n * @example\n * // Control implemented as ES6 class\n * class HelloWorldControl {\n *     onAdd(map) {\n *         this._map = map;\n *         this._container = document.createElement('div');\n *         this._container.className = 'mapboxgl-ctrl';\n *         this._container.textContent = 'Hello, world';\n *         return this._container;\n *     }\n *\n *     onRemove() {\n *         this._container.parentNode.removeChild(this._container);\n *         this._map = undefined;\n *     }\n * }\n *\n * // Control implemented as ES5 prototypical class\n * function HelloWorldControl() { }\n *\n * HelloWorldControl.prototype.onAdd = function(map) {\n *     this._map = map;\n *     this._container = document.createElement('div');\n *     this._container.className = 'mapboxgl-ctrl';\n *     this._container.textContent = 'Hello, world';\n *     return this._container;\n * };\n *\n * HelloWorldControl.prototype.onRemove = function () {\n *      this._container.parentNode.removeChild(this._container);\n *      this._map = undefined;\n * };\n */\n\n/**\n * Register a control on the map and give it a chance to register event listeners\n * and resources. This method is called by {@link Map#addControl}\n * internally.\n *\n * @function\n * @memberof IControl\n * @instance\n * @name onAdd\n * @param {Map} map the Map this control will be added to\n * @returns {HTMLElement} The control's container element. This should\n * be created by the control and returned by onAdd without being attached\n * to the DOM: the map will insert the control's element into the DOM\n * as necessary.\n */\n\n/**\n * Unregister a control on the map and give it a chance to detach event listeners\n * and resources. This method is called by {@link Map#removeControl}\n * internally.\n *\n * @function\n * @memberof IControl\n * @instance\n * @name onRemove\n * @param {Map} map the Map this control will be removed from\n * @returns {undefined} there is no required return value for this method\n */\n\n/**\n * Optionally provide a default position for this control. If this method\n * is implemented and {@link Map#addControl} is called without the `position`\n * parameter, the value returned by getDefaultPosition will be used as the\n * control's position.\n *\n * @function\n * @memberof IControl\n * @instance\n * @name getDefaultPosition\n * @returns {string} a control position, one of the values valid in addControl.\n */\n\n/**\n * A [`Point` geometry](https://github.com/mapbox/point-geometry) object, which has\n * `x` and `y` properties representing screen coordinates in pixels.\n *\n * @typedef {Object} Point\n */\n\n/**\n * A {@link Point} or an array of two numbers representing `x` and `y` screen coordinates in pixels.\n *\n * @typedef {(Point | Array<number>)} PointLike\n */\n","// @flow\n\nimport {MapMouseEvent, MapTouchEvent, MapWheelEvent} from '../ui/events';\nimport DOM from '../util/dom';\nimport type Map from './map';\nimport scrollZoom from './handler/scroll_zoom';\nimport boxZoom from './handler/box_zoom';\nimport dragRotate from './handler/drag_rotate';\nimport dragPan from './handler/drag_pan';\nimport keyboard from './handler/keyboard';\nimport doubleClickZoom from './handler/dblclick_zoom';\nimport touchZoomRotate from './handler/touch_zoom_rotate';\n\nconst handlers = {\n    scrollZoom,\n    boxZoom,\n    dragRotate,\n    dragPan,\n    keyboard,\n    doubleClickZoom,\n    touchZoomRotate\n};\n\nexport default function bindHandlers(map: Map, options: {interactive: boolean, clickTolerance: number}) {\n    const el = map.getCanvasContainer();\n    let contextMenuEvent = null;\n    let mouseDown = false;\n    let startPos = null;\n\n    for (const name in handlers) {\n        (map: any)[name] = new handlers[name](map, options);\n        if (options.interactive && options[name]) {\n            (map: any)[name].enable(options[name]);\n        }\n    }\n\n    DOM.addEventListener(el, 'mouseout', onMouseOut);\n    DOM.addEventListener(el, 'mousedown', onMouseDown);\n    DOM.addEventListener(el, 'mouseup', onMouseUp);\n    DOM.addEventListener(el, 'mousemove', onMouseMove);\n    DOM.addEventListener(el, 'mouseover', onMouseOver);\n\n    // Bind touchstart and touchmove with passive: false because, even though\n    // they only fire a map events and therefore could theoretically be\n    // passive, binding with passive: true causes iOS not to respect\n    // e.preventDefault() in _other_ handlers, even if they are non-passive\n    // (see https://bugs.webkit.org/show_bug.cgi?id=184251)\n    DOM.addEventListener(el, 'touchstart', onTouchStart, {passive: false});\n    DOM.addEventListener(el, 'touchmove', onTouchMove, {passive: false});\n\n    DOM.addEventListener(el, 'touchend', onTouchEnd);\n    DOM.addEventListener(el, 'touchcancel', onTouchCancel);\n    DOM.addEventListener(el, 'click', onClick);\n    DOM.addEventListener(el, 'dblclick', onDblClick);\n    DOM.addEventListener(el, 'contextmenu', onContextMenu);\n    DOM.addEventListener(el, 'wheel', onWheel, {passive: false});\n\n    function onMouseDown(e: MouseEvent) {\n        mouseDown = true;\n        startPos = DOM.mousePos(el, e);\n\n        const mapEvent = new MapMouseEvent('mousedown', map, e);\n        map.fire(mapEvent);\n\n        if (mapEvent.defaultPrevented) {\n            return;\n        }\n\n        if (options.interactive && !map.doubleClickZoom.isActive()) {\n            map.stop();\n        }\n\n        map.boxZoom.onMouseDown(e);\n\n        if (!map.boxZoom.isActive() && !map.dragPan.isActive()) {\n            map.dragRotate.onMouseDown(e);\n        }\n\n        if (!map.boxZoom.isActive() && !map.dragRotate.isActive()) {\n            map.dragPan.onMouseDown(e);\n        }\n    }\n\n    function onMouseUp(e: MouseEvent) {\n        const rotating = map.dragRotate.isActive();\n\n        if (contextMenuEvent && !rotating) {\n            // This will be the case for Mac\n            map.fire(new MapMouseEvent('contextmenu', map, contextMenuEvent));\n        }\n\n        contextMenuEvent = null;\n        mouseDown = false;\n\n        map.fire(new MapMouseEvent('mouseup', map, e));\n    }\n\n    function onMouseMove(e: MouseEvent) {\n        if (map.dragPan.isActive()) return;\n        if (map.dragRotate.isActive()) return;\n\n        let target: ?Node = (e.target: any);\n        while (target && target !== el) target = target.parentNode;\n        if (target !== el) return;\n\n        map.fire(new MapMouseEvent('mousemove', map, e));\n    }\n\n    function onMouseOver(e: MouseEvent) {\n        let target: ?Node = (e.target: any);\n        while (target && target !== el) target = target.parentNode;\n        if (target !== el) return;\n\n        map.fire(new MapMouseEvent('mouseover', map, e));\n    }\n\n    function onMouseOut(e: MouseEvent) {\n        map.fire(new MapMouseEvent('mouseout', map, e));\n    }\n\n    function onTouchStart(e: TouchEvent) {\n        const mapEvent = new MapTouchEvent('touchstart', map, e);\n        map.fire(mapEvent);\n\n        if (mapEvent.defaultPrevented) {\n            return;\n        }\n\n        if (options.interactive) {\n            map.stop();\n        }\n\n        if (!map.boxZoom.isActive() && !map.dragRotate.isActive()) {\n            map.dragPan.onTouchStart(e);\n        }\n\n        map.touchZoomRotate.onStart(e);\n        map.doubleClickZoom.onTouchStart(mapEvent);\n    }\n\n    function onTouchMove(e: TouchEvent) {\n        map.fire(new MapTouchEvent('touchmove', map, e));\n    }\n\n    function onTouchEnd(e: TouchEvent) {\n        map.fire(new MapTouchEvent('touchend', map, e));\n    }\n\n    function onTouchCancel(e: TouchEvent) {\n        map.fire(new MapTouchEvent('touchcancel', map, e));\n    }\n\n    function onClick(e: MouseEvent) {\n        const pos = DOM.mousePos(el, e);\n        if (!startPos || pos.equals(startPos) || pos.dist(startPos) < options.clickTolerance) {\n            map.fire(new MapMouseEvent('click', map, e));\n        }\n    }\n\n    function onDblClick(e: MouseEvent) {\n        const mapEvent = new MapMouseEvent('dblclick', map, e);\n        map.fire(mapEvent);\n\n        if (mapEvent.defaultPrevented) {\n            return;\n        }\n\n        map.doubleClickZoom.onDblClick(mapEvent);\n    }\n\n    function onContextMenu(e: MouseEvent) {\n        const rotating = map.dragRotate.isActive();\n        if (!mouseDown && !rotating) {\n            // Windows: contextmenu fired on mouseup, so fire event now\n            map.fire(new MapMouseEvent('contextmenu', map, e));\n        } else if (mouseDown) {\n            // Mac: contextmenu fired on mousedown; we save it until mouseup for consistency's sake\n            contextMenuEvent = e;\n        }\n\n        // prevent browser context menu when necessary; we don't allow it with rotation\n        // because we can't discern rotation gesture start from contextmenu on Mac\n        if (map.dragRotate.isEnabled() || map.listens('contextmenu')) {\n            e.preventDefault();\n        }\n    }\n\n    function onWheel(e: WheelEvent) {\n        if (options.interactive) {\n            map.stop();\n        }\n\n        const mapEvent = new MapWheelEvent('wheel', map, e);\n        map.fire(mapEvent);\n\n        if (mapEvent.defaultPrevented) {\n            return;\n        }\n\n        map.scrollZoom.onWheel(e);\n    }\n}\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils         = require('../utils/common');\nvar adler32       = require('./adler32');\nvar crc32         = require('./crc32');\nvar inflate_fast  = require('./inffast');\nvar inflate_table = require('./inftrees');\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction zswap32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        state.flags = 0;           /* expect zlib header */\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        else if (len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n        state.dmax = 1 << len;\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if (state.flags & 0x0200) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Array(state.head.extra_len);\n              }\n              utils.arraySet(\n                state.head.extra,\n                input,\n                next,\n                // extra field is limited to 65536 bytes\n                // - no need for additional size check\n                copy,\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if (state.flags & 0x0200) {\n              state.check = crc32(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          utils.arraySet(output, input, next, copy, put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inflate_fast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if (_out) {\n            strm.adler = state.check =\n                /*UPDATE(state.check, put - _out, _out);*/\n                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var state;\n  var dictid;\n  var ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n","// String encode/decode helpers\n'use strict';\n\n\nvar utils = require('./common');\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // use fallback for big arrays to avoid stack overflow\n  if (len < 65537) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n","'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n","'use strict';\n\n\nvar zlib_inflate = require('./zlib/inflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar c            = require('./zlib/constants');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\nvar GZheader     = require('./zlib/gzheader');\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n}\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n  var dict;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      // Convert data if needed\n      if (typeof dictionary === 'string') {\n        dict = strings.string2buf(dictionary);\n      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {\n        dict = new Uint8Array(dictionary);\n      } else {\n        dict = dictionary;\n      }\n\n      status = zlib_inflate.inflateSetDictionary(this.strm, dict);\n\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === 'string') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 aligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","import VectorTileSource from 'mapbox-gl/src/source/vector_tile_source'\nimport pako from 'pako/lib/inflate'\nimport base64js from 'base64-js'\nimport Database from './database'\n\nclass MBTilesSource extends VectorTileSource {\n\n    constructor(id, options, dispatcher, eventedParent) {\n        super(id, options, dispatcher, eventedParent);\n        this.type = \"mbtiles\";\n        this.db = this.openDatabase(options.path);\n    }\n\n    openDatabase(dbLocation) {\n        return Database.openDatabase(dbLocation)\n    }\n\n    copyDatabaseFile(dbLocation, dbName, targetDir) {\n        return Database.copyDatabaseFile(dbLocation, dbName, targetDir)\n    }\n\n    readTile(z, x, y, callback) {\n        const query = 'SELECT BASE64(tile_data) AS base64_tile_data FROM tiles WHERE zoom_level=? AND tile_column=? AND tile_row=?';\n        const params = [z, x, y];\n        this.db.then(function(db) {\n            db.transaction(function (txn) {\n                txn.executeSql(query, params, function (tx, res) {\n                    if (res.rows.length) {\n                        const base64Data = res.rows.item(0).base64_tile_data;\n                        if (!base64Data) {\n                          callback(undefined, '');\n                          return;\n                        }\n\n                        try {\n                          const rawData = pako.inflate(base64js.toByteArray(base64Data));\n                          callback(undefined, base64js.fromByteArray(rawData)); // Tile contents read, callback success.\n                        } catch(err) {\n                          // The tile maybe was not compressed?\n                          callback(undefined, base64Data);\n                        }\n                    } else {\n                        callback(new Error('tile ' + params.join(',') + ' not found'));\n                    }\n                });\n            }, function (error) {\n                callback(error); // Error executing SQL\n            });\n        }).catch(function(err) {\n            callback(err);\n        });\n    }\n\n    loadTile(tile, callback) {\n        const coord = tile.tileID.canonical;\n        const overscaling = coord.z > this.maxzoom ? Math.pow(2, coord.z - this.maxzoom) : 1;\n\n        const z = Math.min(coord.z, this.maxzoom || coord.z); // Don't try to get data over maxzoom\n        const x = coord.x;\n        const y = Math.pow(2,z)-coord.y-1; // Tiles on database are tms (inverted y axis)\n\n        this.readTile(z, x, y, dispatch.bind(this));\n\n        function dispatch(err, base64Data) {\n            if (err) {\n                if (this.url && window.allowMapboxOfflineMapOnlineTile) {\n                  return super.loadTile(tile, callback);\n                } else {\n                  return callback(err);\n                }\n            }\n            if (base64Data === undefined) {\n              return callback(new Error(\"empty data\"));\n            }\n\n            const params = {\n                request: { url: \"data:application/x-protobuf;base64,\" + base64Data },\n                uid: tile.uid,\n                tileID: tile.tileID,\n                zoom: coord.z,\n                tileSize: this.tileSize * overscaling,\n                type: this.type,\n                source: this.id,\n                pixelRatio: window.devicePixelRatio || 1,\n                overscaling: overscaling,\n                showCollisionBoxes: this.map.showCollisionBoxes\n            };\n\n            if (!tile.actor || tile.state === 'expired') {\n              tile.actor = this.dispatcher.getActor();\n              tile.request = tile.actor.send('loadTile', params, done.bind(this));\n            } else if (tile.state === 'loading') {\n                // schedule tile reloading after it has been loaded\n                tile.reloadCallback = callback;\n            } else {\n                tile.request = tile.actor.send('reloadTile', params, done.bind(this));\n            }\n\n            function done(err, data) {\n                delete tile.request;\n                if (tile.aborted)\n                    return;\n\n                if (err) {\n                    return callback(err);\n                }\n\n                if (this.map._refreshExpiredTiles) tile.setExpiryData(data);\n                tile.loadVectorData(data, this.map.painter);\n\n                callback(null);\n\n                if (tile.reloadCallback) {\n                    this.loadTile(tile, tile.reloadCallback);\n                    tile.reloadCallback = null;\n                }\n            }\n        }\n    }\n}\n\nexport default MBTilesSource;\n","// @flow\n\n'use strict';\n\nimport MBTilesSource from './mbtiles_source'\nimport RasterTileSourceOffline from \"./raster_tile_offline_source\"\nimport RasterDEMTileSourceOffline from \"./raster_dem_offline_tile_source\"\nimport Map from 'mapbox-gl/src/ui/map'\nimport {extend} from 'mapbox-gl/src/util/util'\n//import window from 'mapbox-gl/src/util/window'\n\nconst readJSON = (url) => new Promise((resolve, reject) => {\n    const xhr = new window.XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.setRequestHeader('Accept', 'application/json');\n    xhr.onerror = (e) => reject(e);\n    xhr.onload = () => {\n        const isFile = xhr.responseURL.indexOf('file://') === 0;\n        if (((xhr.status >= 200 && xhr.status < 300) || isFile) && xhr.response) {\n            try {\n                resolve(JSON.parse(xhr.response));\n            } catch (err) {\n                reject(err);\n            }\n        } else {\n            reject(new Error(xhr.statusText, xhr.status));\n        }\n    };\n    xhr.send();\n    return xhr;\n});\n\nconst originalFetch = window.fetch;\nfunction newFetch(resource, init) {\n  if (typeof(resource.url) == 'string' && resource.url.match(/^file:/)) {\n    return readJSON(resource.url).then(function (data) {\n      return {\n        ok: true,\n        json: () => Promise.resolve(data),\n        headers: {\n          get: () => ''\n        }\n      };\n    });\n  }\n  return originalFetch(resource, init);\n}\nwindow.fetch = newFetch;\n\nconst dereferenceStyle = (options) => {\n    if (typeof options.style === 'string' || options.style instanceof String) {\n        return readJSON(options.style).then((style) => extend({}, options, {style: style}));\n    } else {\n        return Promise.resolve(options);\n    }\n};\n\nconst absoluteSpriteUrl = (options) => {\n    const style = options.style;\n    const hasProtocol = /^.+:\\/\\//;\n    const path = window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/');\n\n    if (('sprite' in style) && !style.sprite.match(hasProtocol) &&\n        ('glyphs' in style) && !style.glyphs.match(hasProtocol)) {\n        style.sprite = path + '/' +  style.sprite; // eslint-disable-line prefer-template\n        style.glyphs = path + '/' +  style.glyphs; // eslint-disable-line prefer-template\n    }\n    return options;\n};\n\nconst createEmptyMap = (options) => new Promise((resolve) => {\n    const emptyMapStyle = extend({}, options.style, {\n        sources: {},\n        layers: []\n    });\n    const emptyMapOptions = extend({}, options, {style: emptyMapStyle});\n    const map = new Map(emptyMapOptions);\n    map.once('load', () => {\n        let mbTilesSourceLoaded = new Promise((resolve) => {\n            map.addSourceType('mbtiles', MBTilesSource, () => resolve())\n        });\n        let rasterOfflineSourceLoaded = new Promise((resolve) => {\n            map.addSourceType('rasteroffline', RasterTileSourceOffline, () => resolve())\n        });\n        let rasterDEMOfflineSourceLoaded = new Promise((resolve) => {\n            map.addSourceType('raster-dem-offline', RasterDEMTileSourceOffline, () => resolve())\n        });\n\n        Promise.all([\n\t  mbTilesSourceLoaded,\n\t  rasterOfflineSourceLoaded,\n\t  rasterDEMOfflineSourceLoaded\n\t]).then(() => resolve(map))\n    });\n});\n\nconst loadSources = (style) => (map) => {\n    Object.keys(style.sources).map((sourceName) => map.addSource(sourceName, style.sources[sourceName]));\n    return map;\n};\n\nconst loadLayers = (style) => (map) => {\n    style.layers.map((layer) => map.addLayer(layer));\n    return map;\n};\n\nconst OfflineMap = (options) =>\n    dereferenceStyle(options).then(absoluteSpriteUrl).then((newOptions) =>\n        createEmptyMap(newOptions)\n            .then(loadSources(newOptions.style))\n            .then(loadLayers(newOptions.style))\n    );\n\nexport default OfflineMap\n","import Map from 'mapbox-gl/src/ui/map'\n\n/* @preserve\n * derived from * https://github.com/klokantech/openmaptiles-language\n * (c) 2018 Klokan Technologies GmbH\n */\nconst language = () => {\n  var langFallbackDecorate = function(style, cfg) {\n    var layers = style.layers;\n    var lf = cfg['layer-filter'];\n    var decorators = cfg['decorators'];\n    var lfProp = lf[1];\n    var lfValues = lf.slice(2);\n\n    for (var i = layers.length-1; i >= 0; i--) {\n      var layer = layers[i];\n      if(!(\n          lf[0]==='in'\n          && lfProp==='layout.text-field'\n          && layer.layout && layer.layout['text-field']\n          && lfValues.indexOf(layer.layout['text-field'])>=0\n      )) {\n        continue;\n      }\n      for (var j = decorators.length-1; j >= 0; j--) {\n        var decorator = decorators[j];\n        var postfix = decorator['layer-name-postfix'] || '';\n        postfix = postfix.replace(/(^-+|-+$)/g, '');\n\n        if(j>0) {\n          var newLayer = JSON.parse(JSON.stringify(layer));\n          layers.splice(i+1, 0, newLayer);\n        } else {\n          newLayer = layer;\n        }\n        newLayer.id += postfix ? '-'+postfix : '';\n        newLayer.layout['text-field'] = decorator['layout.text-field'];\n        if(newLayer.layout['symbol-placement']==='line') {\n          newLayer.layout['text-field'] =\n              newLayer.layout['text-field'].replace('\\n', ' ');\n        }\n        var filterPart = decorator['filter-all-part'].concat();\n        if(!newLayer.filter) {\n          newLayer.filter = filterPart;\n        } else if(newLayer.filter[0]=='all') {\n          newLayer.filter.push(filterPart);\n        } else {\n          newLayer.filter = [\n            'all',\n            newLayer.filter,\n            filterPart\n          ];\n        }\n      }\n    }\n  };\n\n  var setStyleMutex = false;\n  var origSetStyle = Map.prototype.setStyle;\n  Map.prototype.setStyle = function() {\n    origSetStyle.apply(this, arguments);\n\n    if (!setStyleMutex) {\n      if (this.styleUndecorated) {\n        this.styleUndecorated = undefined;\n      }\n      this.once('styledata', function() {\n        if (this.languageOptions) {\n          this.setLanguage(\n            this.languageOptions.language,\n            this.languageOptions.noAlt\n          );\n        }\n      }.bind(this));\n    }\n  };\n\n  Map.prototype.setLanguage = function(language, noAlt) {\n    this.languageOptions = {\n      language: language,\n      noAlt: noAlt\n    };\n    if (!this.styleUndecorated) {\n      try {\n        this.styleUndecorated = this.getStyle();\n      } catch (e) {}\n    }\n    if (!this.styleUndecorated) {\n      return;\n    }\n\n    var isNonlatin = [\n      'ar', 'hy', 'be', 'bg', 'zh', 'ka', 'el', 'he',\n      'ja', 'ja_kana', 'kn', 'kk', 'ko', 'mk', 'ru', 'sr',\n      'th', 'uk'\n    ].indexOf(language) >= 0;\n\n    var style = JSON.parse(JSON.stringify(this.styleUndecorated));\n    var langCfg = {\n      \"layer-filter\": [\n        \"in\",\n        \"layout.text-field\",\n        \"{name}\",\n        \"{name_de}\",\n        \"{name_en}\",\n        \"{name:latin}\",\n        \"{name:latin} {name:nonlatin}\",\n        \"{name:latin}\\n{name:nonlatin}\"\n      ],\n      \"decorators\": [\n        {\n          \"layout.text-field\": \"{name:latin}\" + (noAlt ? \"\" : \"\\n{name:nonlatin}\"),\n          \"filter-all-part\": [\n            \"!has\",\n            \"name:\" + language\n          ]\n        },\n        {\n          \"layer-name-postfix\": language,\n          \"layout.text-field\": \"{name:\" + language + \"}\" + (noAlt ? \"\" : \"\\n{name:\" + (isNonlatin ? 'latin' : 'nonlatin') + \"}\"),\n          \"filter-all-part\": [\n            \"has\",\n            \"name:\" + language\n          ]\n        }\n      ]\n    };\n    if (language == 'native') {\n      langCfg['decorators'] = [\n        {\n          \"layout.text-field\": \"{name}\",\n          \"filter-all-part\": [\"all\"]\n        }\n      ];\n    }\n    langFallbackDecorate(style, langCfg);\n\n    setStyleMutex = true;\n    this.setStyle(style);\n    setStyleMutex = false;\n  };\n\n  Map.prototype.autodetectLanguage = function(opt_fallback) {\n    this.setLanguage(navigator.language.split('-')[0] || opt_fallback || 'native');\n  };\n};\nexport default language;\n","import mapboxgl from 'mapbox-gl/src/index'\n\nimport offlineMap from './offline_map'\nimport language from './openmaptiles-language.js'\nimport Database from './database.js'\n\nmapboxgl.Database = Database;\nmapboxgl.OfflineMap = offlineMap;\nlanguage(mapboxgl);\n\nexport default mapboxgl\n","//\n// Our custom intro provides a specialized \"define()\" function, called by the\n// AMD modules below, that sets up the worker blob URL and then executes the\n// main module, storing its exported value as 'mapboxgl'\n\n// The three \"chunks\" imported here are produced by a first Rollup pass,\n// which outputs them as AMD modules.\n\n// Shared dependencies, i.e.:\n/*\ndefine(['exports'], function (exports) {\n    // Code for all common dependencies\n    // Each module's exports are attached attached to 'exports' (with\n    // names rewritten to avoid collisions, etc.)\n})\n*/\nimport './build/mapboxgl/shared';\n\n// Worker and its unique dependencies, i.e.:\n/*\ndefine(['./shared.js'], function (__shared__js) {\n    //  Code for worker script and its unique dependencies.\n    //  Expects the output of 'shared' module to be passed in as an argument,\n    //  since all references to common deps look like, e.g.,\n    //  __shared__js.shapeText().\n});\n*/\n// When this wrapper function is passed to our custom define() above,\n// it gets stringified, together with the shared wrapper (using\n// Function.toString()), and the resulting string of code is made into a\n// Blob URL that gets used by the main module to create the web workers.\nimport './build/mapboxgl/worker';\n\n// Main module and its unique dependencies\n/*\ndefine(['./shared.js'], function (__shared__js) {\n    //  Code for main GL JS module and its unique dependencies.\n    //  Expects the output of 'shared' module to be passed in as an argument,\n    //  since all references to common deps look like, e.g.,\n    //  __shared__js.shapeText().\n    //\n    //  Returns the actual mapboxgl (i.e. src/index.js)\n});\n*/\nimport './build/mapboxgl/index';\n\nexport default mapboxgl;\n"],"names":["this","z","floorZ","lastIntegerZoom","lastIntegerZoomTime","now","lastFloorZoom","unicodeBlockLookup","char","Arabic","Unified Canadian Aboriginal Syllabics Extended","Miscellaneous Technical","Optical Character Recognition","Geometric Shapes","Miscellaneous Symbols","CJK Radicals Supplement","Hiragana","Katakana","Hangul Compatibility Jamo","CJK Unified Ideographs Extension A","Yi Syllables","Yi Radicals","Hangul Syllables","Hangul Jamo Extended-B","CJK Compatibility Ideographs","Arabic Presentation Forms-A","Vertical Forms","CJK Compatibility Forms","Arabic Presentation Forms-B","Halfwidth and Fullwidth Forms","chars","charAllowsLetterSpacing","isChar","charHasRotatedVerticalOrientation","charHasNeutralVerticalOrientation","canRenderRTL","_completionCallback","status","EvaluationParameters","zoom","options","zoomHistory","str","crossFadingFactor","fadeDuration","Math","min","getCrossfadeParameters","const","fraction","PropertyValue","constructor","property","value","expression","result","join","specification","type","Color","constant","normalizePropertyExpression","undefined","kind","possiblyEvaluate","TransitionablePropertyValue","transitioned","TransitioningPropertyValue","extend","transition","parameters","Transitionable","create","DataConstantProperty","DataDrivenProperty","styleSpec","text-rotate","text-allow-overlap","text-ignore-placement","text-optional","Properties","icon-halo-color","icon-halo-blur","icon-translate","icon-translate-anchor","text-color","runtimeType","getOverride","o","text-halo-width","text-halo-blur","FormatSectionOverride","evaluate","ctx","formattedSection","overrides","defaultValue","eachChild","layer","super","properties","recalculate","availableImages","layout","get","_values","writingModes","m","feature","unevaluated","_unevaluatedLayout","isDataDriven","key","String","_setPaintOverrides","overriden","paint","override","ZoomConstantExpression","styleExpression","overridable","sections","section","hasOverrides","textField","Literal","checkSections","formatted","FormatExpression","checkExpression","SymbolStyleLayer","background-pattern","BackgroundStyleLayer","StyleLayer","raster-brightness-min","raster-brightness-max","raster-contrast","raster-fade-duration","CustomStyleLayer","implementation","renderingMode","hasTransition","serialize","onAdd","map","painter","context","onRemove","fill-extrusion","symbol","boxes","let","box","max","maxWidth","sort","i","length","space","height","y","w","last","spaces","h","push","pixelRatio","paddedRect","version","tl","br","x","tlbr","displaySize","padding","patterns","iconPositions","icons","bins","addImages","potpack","image","RGBAImage","id","src","data","bin","width","copy","patternPositions","positions","images","ImagePosition","hasRenderCallback","haveRenderCallbacks","patchUpdatedImages","texture","updatedImages","patchUpdatedImage","getImage","ImageAtlas","position","register","format","update","resize","size","gl","Boolean","useMipmap","TEXTURE_2D","set","HTMLImageElement","HTMLCanvasElement","HTMLVideoElement","ImageData","UNSIGNED_BYTE","texSubImage2D","Texture","minFilter","bindTexture","LINEAR_MIPMAP_NEAREST","filter","wrap","TEXTURE_WRAP_S","texParameteri","TEXTURE_WRAP_T","isSizePowerOfTwo","destroy","exports","buffer","offset","nBytes","mLen","eMax","eLen","d","isLE","s","e","nBits","eBias","NaN","Infinity","pow","glyphPositionMap","horizontal","vertical","text","textOffset","spacingIfAllowed","spacing","variableTextAnchor","radialOffset","INVALID_TEXT_OFFSET","textAlongLine","symbolPlacement","ONE_EM","addVerticalShapingForPointLabelIfNeeded","shapedTextOrientations","shapeText","fontstack","textJustify","justification","justifications","singleLine","shaping","WritingMode","glyphMap","textAnchor","unformattedText","lineHeight","name","icon","iconAnchor","getAnchorAlignment","verticalAlign","dy","x1","y1","bottom","sdfIcons","warnOnce","iconsNeedLinear","constantOr","keys","shapedIcon","layoutTextSize","sizes","layoutIconSize","textMaxSize","layers","iconOffset","defaultHorizontalShaping","horizontalShaping","tilePixelRatio","textMaxBoxScale","textPadding","bucket","textMaxAngle","PI","textRepeatDistance","symbolMinDistance","iconTextFit","allowVerticalPlacement","verticallyShapedIcon","fontScale","fitIconToText","anchor","line","sourceLayerIndex","iconBoxScale","lineArray","addToLineVertexArray","numIconVertices","t","featureIndex","bucketIndex","verticalIconCollisionFeature","collisionBoxArray","iconRotate","getIconQuads","iconPadding","overscaling","iconQuads","iconSizeData","sizeData","SIZE_PACK_FACTOR","addSymbols","placedIconSymbolIndex","verticalIconQuads","textCollisionFeature","murmur3","CollisionFeature","textRotate","placedTextSymbolIndices","boxStartIndex","boxEndIndex","iconCollisionFeature","SymbolBucket","center","textBoxStartIndex","iconBoxEndIndex","verticalIconBoxEndIndex","numVerticalGlyphVertices","textBoxScale","textOffset1","addSymbol","index","y2","clippedLines","l","lines","p0","p1","Point","x2","_round","clippedLine","clipLine","EXTENT","shapedText","geometry","poi","findPoleOfInaccessibility","polygon","Anchor","points","addSymbolAtAnchor","addFeature","showCollisionBoxes","then","cache","limit","stringify","obj","JSON","Array","isArray","Object","getKey","refProperties","StyleLayerIndex","layerConfigs","keyCache","replace","_layerConfigs","_layers","removedIds","layerConfig","createStyleLayer","_featureFilter","featureFilter","familiesBySource","cachedKeys","groups","k","group","groupByLayout","values","visibility","sourceId","source","sourceGroup","sourceLayerId","sourceLayer","sourceLayerFamilies","GlyphAtlas","stacks","stack","glyphs","stackPositions","bitmap","metrics","AlphaImage","rect","WorkerTile","params","tileID","OverscaledTileID","overscaledZ","canonical","uid","tileSize","overscaleFactor","collectResourceTiming","returnDependencies","recalculateLayers","parse","layerIndex","actor","callback","CollisionBoxArray","sourceLayerCoder","DictionaryCoder","FeatureIndex","bucketLayerIDs","error","iconMap","patternMap","buckets","layerFamilies","encode","features","family","minzoom","floor","maxzoom","createBucket","sourceID","populate","mapObject","glyphDependencies","Number","send","err","maybePrepare","call","iconDependencies","patternDependencies","glyphAtlas","imageAtlas","hasPattern","LineBucket","FillBucket","FillExtrusionBucket","addFeatures","b","isEmpty","glyphAtlasImage","performanceExists","performance","wrapper","url","getEntriesByName","mark","startMark","endMark","measure","clearMarks","clearMeasures","Performance","request","_marks","start","end","toString","loadVectorTile","getArrayBuffer","cacheControl","expires","vectorTile","vt","VectorTile","Protobuf","rawData","cancel","finish","resourceTimingData","VectorTileWorkerSource","loadVectorData","loading","loaded","loadTile","perf","workerTile","abort","response","rawTileData","resourceTiming","slice","reloadTile","vtSource","done","reloadCallback","abortTile","removeTile","RasterDEMTileWorkerSource","encoding","rawImageData","dem","DEMData","module","polygonArea","coords","area","abs","ringArea","p2","lowerIndex","middleIndex","upperIndex","coordsLength","rad","sin","wgs84","RADIUS","_","coordinates","geometries","rewind","gj","outer","curryOuter","correctRings","correct","a","wind","dir","geojsonArea","ring","cw","reverse","toGeoJSON","mvt","VectorTileFeature","prototype","FeatureWrapper","_feature","extent","tags","isNaN","parseInt","loadGeometry","point","newRing","GeoJSONWrapper","_geojsonTileLayer","_features","require","rawGeometry","rings","j","bbox","coord","fromVectorTileJs","tile","out","Pbf","pbf","writeMessage","writeLayer","writeTile","writeVarintField","writeStringField","keycache","valuecache","writeFeature","writeValue","writeProperties","writeGeometry","keyIndex","writeVarint","valueKey","valueIndex","command","cmd","zigzag","num","r","count","lineCount","dx","writeBooleanField","writeDoubleField","writeSVarintField","sortKD","ids","nodeSize","left","right","depth","select","inc","n","log","exp","sd","sqrt","newLeft","newRight","swapItem","swap","arr","tmp","sqDist","ax","ay","bx","by","defaultGetX","p","defaultGetY","KDBush","getX","getY","ArrayType","Float64Array","IndexArrayType","Uint16Array","Uint32Array","range","minX","minY","maxX","maxY","axis","pop","nextAxis","within","qx","qy","r2","defaultOptions","minZoom","maxZoom","radius","reduce","props","Supercluster","trees","createCluster","numPoints","parentId","createPointCluster","lngX","latY","getClusterJSON","cluster","getClusterProperties","atan","abbrev","round","cluster_id","point_count","point_count_abbreviated","lng","lat","dest","getSqSegDist","px","py","createFeature","geom","calcLineBBox","calcBBox","convertFeature","geojson","tolerance","promoteId","generateId","convertPoint","convertLine","lineMetrics","convertLines","Error","projectX","projectY","isPolygon","x0","y0","simplify","first","sqTolerance","maxSqDist","mid","minPosToMid","posToMid","clip","scale","k1","k2","minAll","maxAll","clipped","newGeometry","clipPoints","clipLines","newGeom","trackMetrics","segLen","newSlice","intersect","intersectX","intersectY","len","az","exited","addPoint","shiftFeatureCoords","newFeatures","shiftCoords","newPolygon","newPoints","transformTile","transformed","z2","tx","ty","transformPoint","createTile","numSimplified","numFeatures","simplified","addLine","tileFeature","isOuter","clockwise","GeoJSONVT","debug","console","time","convert","tiles","tileCoords","timeEnd","indexMaxZoom","indexMaxPoints","stats","total","merged","concat","splitTile","toID","loadGeoJSONTile","_geoJSONIndex","geoJSONTile","getTile","geojsonWrapper","vtpbf","byteOffset","byteLength","Uint8Array","load","timerId","clusters","Float32Array","Date","_cluster","getClusters","minLng","minLat","maxLng","maxLat","easternHem","westernHem","tree","_limitZoom","c","getChildren","clusterId","originId","originZoom","errorMsg","origin","children","getLeaves","leaves","_appendLeaves","top","_addTileFeatures","getClusterExpansionZoom","clusterZoom","skipped","child","f","neighborIds","wx","wy","clusterProperties","_map","neighborId","numPoints2","clone","original","cz","cx","cy","bl","tr","k3","k4","transform","parent","z0","GeoJSONWorkerSource","loadGeoJSON","loadData","_pendingCallback","abandoned","_pendingLoadDataParams","_state","_loadData","ref","superclusterOptions","mapExpressions","reduceExpressions","globals","accumulated","propertyNames","operator","mapExpression","mapExpressionParsed","createExpression","reduceExpressionParsed","pointProperties","getSuperclusterOptions","geojsonvt","geojsonVtOptions","coalesce","getJSON","deref","setPaintProperty","setFilter","setLayerProperty","setBearing","setSprite","addSource","commands","operations","removeSource","sourcesRemoved","after","prop","hasOwnProperty","before","klass","pluckId","diffStyles","args","isEqual","setZoom","bearing","pitch","setPitch","sprite","setTransition","setLight","light","canUpdateGeoJSON","updateSource","diffSources","sources","removeLayer","insertBeforeLayerId","beforeOrder","indexById","tracker","layerId","afterOrder","lastIndexOf","beforeLayer","clean","afterLayer","diffLayerPropertyChanges","indexOf","addLayer","diffLayers","beforeLayers","setStyle","cellSize","boxCells","circleCells","yCellCount","xCellCount","circleKeys","bboxes","circles","posMatrix","pitchWithMap","rotateWithMap","mat4","pixelsToTileUnits","angle","glCoordMatrix","project","pos","symbolSize","clear","lineVertexArray","isText","placedSymbolArray","aspectRatio","useVertical","placedSymbols","hidden","writingMode","hideGlyphs","anchorY","vec4","isVisible","clippingBuffer","anchorPos","partiallyEvaluatedSize","perspectiveRatio","tileAnchorPoint","labelPlaneMatrix","keepUpright","anchorPoint","pitchScaledFontSize","numGlyphs","dynamicLayoutVertexArray","dynamicLayoutVertexBuffer","updateData","placeFirstAndLastGlyph","glyphOffsetArray","lineOffsetX","projectionCache","glyphEndIndex","lineStartIndex","lineEndIndex","glyphStartIndex","lastGlyphOffset","getoffsetX","placeGlyphAlongLine","firstGlyphOffset","returnTileDistance","firstPlacedGlyph","lastPlacedGlyph","segment","requiresOrientationChange","firstPoint","lastPoint","fontSize","flip","placedGlyphs","lineLength","lineOffsetY","firstAndLastGlyph","orientationChange","glyphIndex","signedDistanceFromCamera","tileSegmentEnd","singleGlyph","notEnoughRoom","glyph","previousTilePoint","currentTilePoint","previousProjectedPoint","minimumLength","projectionMatrix","add","sub","_unit","projectedUnitSegment","projectedUnitVertex","_mult","mag","anchorSegment","combinedOffsetX","offsetX","setLocationAtPoint","renderWorldCopies","newCenter","eventData","delayEndEvents","_easeEndTimeoutID","setTimeout","_afterEase","_prepareEase","noMoveStart","_moving","fire","_zooming","Event","_pitching","_fireMoveEvents","_rotating","wasZooming","wasRotating","prefersReducedMotion","coercedOptions","pick","stop","speed","curve","startZoom","getZoom","startBearing","getBearing","startPitch","getPitch","zoomScale","pointAtOffset","LngLat","locationAtOffset","_normalizeCenter","delta","w0","clamp","wMax","rho","rho2","w1","sinh","r0","cosh","u1","S","u","duration","screenSpeed","maxDuration","_ease","scaleZoom","interpolate","unproject","from","mult","_easeFrameId","_cancelRenderFrame","_onEaseEnd","frame","_easeStart","_easeOptions","_onEaseFrame","easing","_renderFrameCallback","diff","lngRange","bindAll","AttributionControl","compact","_container","_innerContainer","DOM","_updateData","on","_updateEditLink","remove","off","_updateCompact","_editLink","editLink","querySelector","styleId","_requestManager","config","acc","next","href","paramString","_hash","rel","sourceDataType","_updateAttributions","style","customAttribution","attribution","styleOwner","stylesheet","sourceCache","sourceCaches","used","getSource","attribHTML","attrib","attributions","classList","offsetWidth","target","display","_updateLogo","_logoRequired","_id","_queue","cancelled","TaskQueue","task","_cleared","_currentlyRunning","dragRotate","keyboard","doubleClickZoom","touchZoomRotate","bearingSnap","clickTolerance","hash","refreshExpiredTiles","accessToken","crossSourceCollisions","Map","_interactive","_antialias","_bearingSnap","_crossSourceCollisions","_collectResourceTiming","_mapId","uniqueId","transformRequest","container","HTMLElement","maxBounds","_update","window","_onWindowResize","getCanvasContainer","contextMenuEvent","handlers","addEventListener","mouseDown","startPos","mapEvent","interactive","boxZoom","onMouseDown","rotating","bits","total_out","_out","state","strm","adler","flags","output","put","hold","zswap32","check","mode","have","input","DONE","BAD","SYNC","Z_STREAM_ERROR","next_out","next_in","avail_in","wsize","avail_out","Z_FINISH","updatewindow","_in","crc32","flush","Z_OK","ret","head","dictionary","DICT","adler32","dictLength","STR_APPLY_UIA_OK","__","fromCharCode","utils","q","_utf8len","buf2binstring","buf","subarray","STR_APPLY_OK","c2","buf_len","m_pos","charCodeAt","str_len","Buf8","utf16buf","c_len","Z_TREES","Z_NEED_DICT","Z_BEST_SPEED","Z_FIXED","Z_DEFAULT_STRATEGY","Z_DEFLATED","2","0","-5","total_in","msg","extra","Inflate","windowBits","to","opt","raw","ended","inflator","next_out_utf8","tail","chunkSize","allowBufError","_mode","Z_NO_FLUSH","strings","zlib_inflate","dict","Z_BUF_ERROR","Z_STREAM_END","onEnd","Z_SYNC_FLUSH","utf8str","arraySet","onData","shrinkBuf","chunks","lens","placeHoldersLen","b64","getLens","_byteLength","revLookup","curByte","uint8","extraBytes","parts","len2","encodeChunk","lookup","code","validLen","db","openDatabase","Database","dbLocation","copyDatabaseFile","executeSql","base64Data","res","item","base64_tile_data","inflate","toByteArray","getActor","bind","aborted","Promise","reject","XMLHttpRequest","open","setRequestHeader","onerror","xhr","onload","responseURL","originalFetch","resource","match","resolve","origSetStyle","path","location","split","hasProtocol","mapboxgl","OfflineMap","readJSON","dereferenceStyle","absoluteSpriteUrl","emptyMapStyle","mbTilesSourceLoaded","addSourceType","rasterOfflineSourceLoaded","RasterDEMTileSourceOffline","rasterDEMOfflineSourceLoaded","newOptions","sourceName","setStyleMutex","arguments","language","noAlt","styleUndecorated","isNonlatin","langCfg","layer-filter","decorators","layout.text-field","filter-all-part","layer-name-postfix"],"mappings":"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"}