{"version":3,"file":"mapbox-gl-cordova-offline.js","sources":["../node_modules/pbf/index.js","../node_modules/mapbox-gl/src/style/parse_glyph_pbf.js","../node_modules/mapbox-gl/src/util/actor.js","../node_modules/@mapbox/whoots-js/index.mjs","../node_modules/mapbox-gl/src/geo/lng_lat_bounds.js","../node_modules/mapbox-gl/src/geo/lng_lat.js","../node_modules/mapbox-gl/src/geo/mercator_coordinate.js","../node_modules/mapbox-gl/src/source/tile_id.js","../node_modules/mapbox-gl/src/source/tile_bounds.js","../node_modules/mapbox-gl/src/source/raster_tile_source.js","../node_modules/mapbox-gl/src/data/dem_data.js","../node_modules/mapbox-gl/src/source/raster_dem_tile_source.js","../node_modules/mapbox-gl/src/style-spec/group_by_layout.js","../node_modules/mapbox-gl/src/style/style_layer_index.js","../node_modules/mapbox-gl/src/symbol/check_max_angle.js","../node_modules/mapbox-gl/src/symbol/get_anchors.js","../node_modules/mapbox-gl/src/symbol/collision_feature.js","../node_modules/tinyqueue/index.js","../node_modules/mapbox-gl/src/util/find_pole_of_inaccessibility.js","../node_modules/murmurhash-js/murmurhash3_gc.js","../node_modules/murmurhash-js/murmurhash2_gc.js","../node_modules/murmurhash-js/index.js","../node_modules/mapbox-gl/src/symbol/symbol_layout.js","../node_modules/mapbox-gl/src/symbol/quads.js","../node_modules/mapbox-gl/src/symbol/clip_line.js","../node_modules/mapbox-gl/src/render/glyph_atlas.js","../node_modules/mapbox-gl/src/source/worker_tile.js","../node_modules/mapbox-gl/src/util/performance.js","../node_modules/mapbox-gl/src/source/vector_tile_worker_source.js","../node_modules/mapbox-gl/src/source/raster_dem_tile_worker_source.js","../node_modules/wgs84/index.js","../node_modules/@mapbox/geojson-area/index.js","../node_modules/@mapbox/geojson-rewind/index.js","../node_modules/mapbox-gl/src/source/geojson_wrapper.js","../node_modules/vt-pbf/lib/geojson_wrapper.js","../node_modules/vt-pbf/index.js","../node_modules/mapbox-gl/src/render/draw_heatmap.js","../node_modules/mapbox-gl/src/render/draw_line.js","../node_modules/base64-js/index.js","../src/mbtiles_source.js","../src/offline_map.js","../src/index.js","../src/openmaptiles-language.js","../rollup/mapboxgl.js"],"sourcesContent":["'use strict';\n\nmodule.exports = Pbf;\n\nvar ieee754 = require('ieee754');\n\nfunction Pbf(buf) {\n    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);\n    this.pos = 0;\n    this.type = 0;\n    this.length = this.buf.length;\n}\n\nPbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum\nPbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64\nPbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields\nPbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32\n\nvar SHIFT_LEFT_32 = (1 << 16) * (1 << 16),\n    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\n\n// Threshold chosen based on both benchmarking and knowledge about browser string\n// data structures (which currently switch structure types at 12 bytes or more)\nvar TEXT_DECODER_MIN_LENGTH = 12;\nvar utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf8');\n\nPbf.prototype = {\n\n    destroy: function() {\n        this.buf = null;\n    },\n\n    // === READING =================================================================\n\n    readFields: function(readField, result, end) {\n        end = end || this.length;\n\n        while (this.pos < end) {\n            var val = this.readVarint(),\n                tag = val >> 3,\n                startPos = this.pos;\n\n            this.type = val & 0x7;\n            readField(tag, result, this);\n\n            if (this.pos === startPos) this.skip(val);\n        }\n        return result;\n    },\n\n    readMessage: function(readField, result) {\n        return this.readFields(readField, result, this.readVarint() + this.pos);\n    },\n\n    readFixed32: function() {\n        var val = readUInt32(this.buf, this.pos);\n        this.pos += 4;\n        return val;\n    },\n\n    readSFixed32: function() {\n        var val = readInt32(this.buf, this.pos);\n        this.pos += 4;\n        return val;\n    },\n\n    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)\n\n    readFixed64: function() {\n        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    },\n\n    readSFixed64: function() {\n        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    },\n\n    readFloat: function() {\n        var val = ieee754.read(this.buf, this.pos, true, 23, 4);\n        this.pos += 4;\n        return val;\n    },\n\n    readDouble: function() {\n        var val = ieee754.read(this.buf, this.pos, true, 52, 8);\n        this.pos += 8;\n        return val;\n    },\n\n    readVarint: function(isSigned) {\n        var buf = this.buf,\n            val, b;\n\n        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;\n        b = buf[this.pos];   val |= (b & 0x0f) << 28;\n\n        return readVarintRemainder(val, isSigned, this);\n    },\n\n    readVarint64: function() { // for compatibility with v2.0.1\n        return this.readVarint(true);\n    },\n\n    readSVarint: function() {\n        var num = this.readVarint();\n        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding\n    },\n\n    readBoolean: function() {\n        return Boolean(this.readVarint());\n    },\n\n    readString: function() {\n        var end = this.readVarint() + this.pos;\n        var pos = this.pos;\n        this.pos = end;\n\n        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {\n            // longer strings are fast with the built-in browser TextDecoder API\n            return readUtf8TextDecoder(this.buf, pos, end);\n        }\n        // short strings are fast with our custom implementation\n        return readUtf8(this.buf, pos, end);\n    },\n\n    readBytes: function() {\n        var end = this.readVarint() + this.pos,\n            buffer = this.buf.subarray(this.pos, end);\n        this.pos = end;\n        return buffer;\n    },\n\n    // verbose for performance reasons; doesn't affect gzipped size\n\n    readPackedVarint: function(arr, isSigned) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readVarint(isSigned));\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readVarint(isSigned));\n        return arr;\n    },\n    readPackedSVarint: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readSVarint());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSVarint());\n        return arr;\n    },\n    readPackedBoolean: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readBoolean());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readBoolean());\n        return arr;\n    },\n    readPackedFloat: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readFloat());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFloat());\n        return arr;\n    },\n    readPackedDouble: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readDouble());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readDouble());\n        return arr;\n    },\n    readPackedFixed32: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed32());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFixed32());\n        return arr;\n    },\n    readPackedSFixed32: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed32());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSFixed32());\n        return arr;\n    },\n    readPackedFixed64: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed64());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFixed64());\n        return arr;\n    },\n    readPackedSFixed64: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed64());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSFixed64());\n        return arr;\n    },\n\n    skip: function(val) {\n        var type = val & 0x7;\n        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}\n        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;\n        else if (type === Pbf.Fixed32) this.pos += 4;\n        else if (type === Pbf.Fixed64) this.pos += 8;\n        else throw new Error('Unimplemented type: ' + type);\n    },\n\n    // === WRITING =================================================================\n\n    writeTag: function(tag, type) {\n        this.writeVarint((tag << 3) | type);\n    },\n\n    realloc: function(min) {\n        var length = this.length || 16;\n\n        while (length < this.pos + min) length *= 2;\n\n        if (length !== this.length) {\n            var buf = new Uint8Array(length);\n            buf.set(this.buf);\n            this.buf = buf;\n            this.length = length;\n        }\n    },\n\n    finish: function() {\n        this.length = this.pos;\n        this.pos = 0;\n        return this.buf.subarray(0, this.length);\n    },\n\n    writeFixed32: function(val) {\n        this.realloc(4);\n        writeInt32(this.buf, val, this.pos);\n        this.pos += 4;\n    },\n\n    writeSFixed32: function(val) {\n        this.realloc(4);\n        writeInt32(this.buf, val, this.pos);\n        this.pos += 4;\n    },\n\n    writeFixed64: function(val) {\n        this.realloc(8);\n        writeInt32(this.buf, val & -1, this.pos);\n        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n        this.pos += 8;\n    },\n\n    writeSFixed64: function(val) {\n        this.realloc(8);\n        writeInt32(this.buf, val & -1, this.pos);\n        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n        this.pos += 8;\n    },\n\n    writeVarint: function(val) {\n        val = +val || 0;\n\n        if (val > 0xfffffff || val < 0) {\n            writeBigVarint(val, this);\n            return;\n        }\n\n        this.realloc(4);\n\n        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] =   (val >>> 7) & 0x7f;\n    },\n\n    writeSVarint: function(val) {\n        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);\n    },\n\n    writeBoolean: function(val) {\n        this.writeVarint(Boolean(val));\n    },\n\n    writeString: function(str) {\n        str = String(str);\n        this.realloc(str.length * 4);\n\n        this.pos++; // reserve 1 byte for short string length\n\n        var startPos = this.pos;\n        // write the string directly to the buffer and see how much was written\n        this.pos = writeUtf8(this.buf, str, this.pos);\n        var len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    },\n\n    writeFloat: function(val) {\n        this.realloc(4);\n        ieee754.write(this.buf, val, this.pos, true, 23, 4);\n        this.pos += 4;\n    },\n\n    writeDouble: function(val) {\n        this.realloc(8);\n        ieee754.write(this.buf, val, this.pos, true, 52, 8);\n        this.pos += 8;\n    },\n\n    writeBytes: function(buffer) {\n        var len = buffer.length;\n        this.writeVarint(len);\n        this.realloc(len);\n        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];\n    },\n\n    writeRawMessage: function(fn, obj) {\n        this.pos++; // reserve 1 byte for short message length\n\n        // write the message directly to the buffer and see how much was written\n        var startPos = this.pos;\n        fn(obj, this);\n        var len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    },\n\n    writeMessage: function(tag, fn, obj) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeRawMessage(fn, obj);\n    },\n\n    writePackedVarint:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedVarint, arr);   },\n    writePackedSVarint:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);  },\n    writePackedBoolean:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);  },\n    writePackedFloat:    function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFloat, arr);    },\n    writePackedDouble:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedDouble, arr);   },\n    writePackedFixed32:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);  },\n    writePackedSFixed32: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr); },\n    writePackedFixed64:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);  },\n    writePackedSFixed64: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr); },\n\n    writeBytesField: function(tag, buffer) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeBytes(buffer);\n    },\n    writeFixed32Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeFixed32(val);\n    },\n    writeSFixed32Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeSFixed32(val);\n    },\n    writeFixed64Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeFixed64(val);\n    },\n    writeSFixed64Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeSFixed64(val);\n    },\n    writeVarintField: function(tag, val) {\n        this.writeTag(tag, Pbf.Varint);\n        this.writeVarint(val);\n    },\n    writeSVarintField: function(tag, val) {\n        this.writeTag(tag, Pbf.Varint);\n        this.writeSVarint(val);\n    },\n    writeStringField: function(tag, str) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeString(str);\n    },\n    writeFloatField: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeFloat(val);\n    },\n    writeDoubleField: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeDouble(val);\n    },\n    writeBooleanField: function(tag, val) {\n        this.writeVarintField(tag, Boolean(val));\n    }\n};\n\nfunction readVarintRemainder(l, s, p) {\n    var buf = p.buf,\n        h, b;\n\n    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);\n\n    throw new Error('Expected varint not more than 10 bytes');\n}\n\nfunction readPackedEnd(pbf) {\n    return pbf.type === Pbf.Bytes ?\n        pbf.readVarint() + pbf.pos : pbf.pos + 1;\n}\n\nfunction toNum(low, high, isSigned) {\n    if (isSigned) {\n        return high * 0x100000000 + (low >>> 0);\n    }\n\n    return ((high >>> 0) * 0x100000000) + (low >>> 0);\n}\n\nfunction writeBigVarint(val, pbf) {\n    var low, high;\n\n    if (val >= 0) {\n        low  = (val % 0x100000000) | 0;\n        high = (val / 0x100000000) | 0;\n    } else {\n        low  = ~(-val % 0x100000000);\n        high = ~(-val / 0x100000000);\n\n        if (low ^ 0xffffffff) {\n            low = (low + 1) | 0;\n        } else {\n            low = 0;\n            high = (high + 1) | 0;\n        }\n    }\n\n    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {\n        throw new Error('Given varint doesn\\'t fit into 10 bytes');\n    }\n\n    pbf.realloc(10);\n\n    writeBigVarintLow(low, high, pbf);\n    writeBigVarintHigh(high, pbf);\n}\n\nfunction writeBigVarintLow(low, high, pbf) {\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos]   = low & 0x7f;\n}\n\nfunction writeBigVarintHigh(high, pbf) {\n    var lsb = (high & 0x07) << 4;\n\n    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f;\n}\n\nfunction makeRoomForExtraLength(startPos, len, pbf) {\n    var extraLen =\n        len <= 0x3fff ? 1 :\n        len <= 0x1fffff ? 2 :\n        len <= 0xfffffff ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));\n\n    // if 1 byte isn't enough for encoding message length, shift the data to the right\n    pbf.realloc(extraLen);\n    for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];\n}\n\nfunction writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }\nfunction writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }\nfunction writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }\nfunction writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }\nfunction writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }\nfunction writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }\nfunction writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }\nfunction writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }\nfunction writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }\n\n// Buffer code below from https://github.com/feross/buffer, MIT-licensed\n\nfunction readUInt32(buf, pos) {\n    return ((buf[pos]) |\n        (buf[pos + 1] << 8) |\n        (buf[pos + 2] << 16)) +\n        (buf[pos + 3] * 0x1000000);\n}\n\nfunction writeInt32(buf, val, pos) {\n    buf[pos] = val;\n    buf[pos + 1] = (val >>> 8);\n    buf[pos + 2] = (val >>> 16);\n    buf[pos + 3] = (val >>> 24);\n}\n\nfunction readInt32(buf, pos) {\n    return ((buf[pos]) |\n        (buf[pos + 1] << 8) |\n        (buf[pos + 2] << 16)) +\n        (buf[pos + 3] << 24);\n}\n\nfunction readUtf8(buf, pos, end) {\n    var str = '';\n    var i = pos;\n\n    while (i < end) {\n        var b0 = buf[i];\n        var c = null; // codepoint\n        var bytesPerSequence =\n            b0 > 0xEF ? 4 :\n            b0 > 0xDF ? 3 :\n            b0 > 0xBF ? 2 : 1;\n\n        if (i + bytesPerSequence > end) break;\n\n        var b1, b2, b3;\n\n        if (bytesPerSequence === 1) {\n            if (b0 < 0x80) {\n                c = b0;\n            }\n        } else if (bytesPerSequence === 2) {\n            b1 = buf[i + 1];\n            if ((b1 & 0xC0) === 0x80) {\n                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);\n                if (c <= 0x7F) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 3) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);\n                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 4) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            b3 = buf[i + 3];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);\n                if (c <= 0xFFFF || c >= 0x110000) {\n                    c = null;\n                }\n            }\n        }\n\n        if (c === null) {\n            c = 0xFFFD;\n            bytesPerSequence = 1;\n\n        } else if (c > 0xFFFF) {\n            c -= 0x10000;\n            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);\n            c = 0xDC00 | c & 0x3FF;\n        }\n\n        str += String.fromCharCode(c);\n        i += bytesPerSequence;\n    }\n\n    return str;\n}\n\nfunction readUtf8TextDecoder(buf, pos, end) {\n    return utf8TextDecoder.decode(buf.subarray(pos, end));\n}\n\nfunction writeUtf8(buf, str, pos) {\n    for (var i = 0, c, lead; i < str.length; i++) {\n        c = str.charCodeAt(i); // code point\n\n        if (c > 0xD7FF && c < 0xE000) {\n            if (lead) {\n                if (c < 0xDC00) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                    lead = c;\n                    continue;\n                } else {\n                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;\n                    lead = null;\n                }\n            } else {\n                if (c > 0xDBFF || (i + 1 === str.length)) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                } else {\n                    lead = c;\n                }\n                continue;\n            }\n        } else if (lead) {\n            buf[pos++] = 0xEF;\n            buf[pos++] = 0xBF;\n            buf[pos++] = 0xBD;\n            lead = null;\n        }\n\n        if (c < 0x80) {\n            buf[pos++] = c;\n        } else {\n            if (c < 0x800) {\n                buf[pos++] = c >> 0x6 | 0xC0;\n            } else {\n                if (c < 0x10000) {\n                    buf[pos++] = c >> 0xC | 0xE0;\n                } else {\n                    buf[pos++] = c >> 0x12 | 0xF0;\n                    buf[pos++] = c >> 0xC & 0x3F | 0x80;\n                }\n                buf[pos++] = c >> 0x6 & 0x3F | 0x80;\n            }\n            buf[pos++] = c & 0x3F | 0x80;\n        }\n    }\n    return pos;\n}\n","// @flow\n\nimport { AlphaImage } from '../util/image';\n\nimport Protobuf from 'pbf';\nconst border = 3;\n\nimport type {StyleGlyph} from './style_glyph';\n\nfunction readFontstacks(tag: number, glyphs: Array<StyleGlyph>, pbf: Protobuf) {\n    if (tag === 1) {\n        pbf.readMessage(readFontstack, glyphs);\n    }\n}\n\nfunction readFontstack(tag: number, glyphs: Array<StyleGlyph>, pbf: Protobuf) {\n    if (tag === 3) {\n        const {id, bitmap, width, height, left, top, advance} = pbf.readMessage(readGlyph, {});\n        glyphs.push({\n            id,\n            bitmap: new AlphaImage({\n                width: width + 2 * border,\n                height: height + 2 * border\n            }, bitmap),\n            metrics: {width, height, left, top, advance}\n        });\n    }\n}\n\nfunction readGlyph(tag: number, glyph: Object, pbf: Protobuf) {\n    if (tag === 1) glyph.id = pbf.readVarint();\n    else if (tag === 2) glyph.bitmap = pbf.readBytes();\n    else if (tag === 3) glyph.width = pbf.readVarint();\n    else if (tag === 4) glyph.height = pbf.readVarint();\n    else if (tag === 5) glyph.left = pbf.readSVarint();\n    else if (tag === 6) glyph.top = pbf.readSVarint();\n    else if (tag === 7) glyph.advance = pbf.readVarint();\n}\n\nexport default function (data: ArrayBuffer | Uint8Array): Array<StyleGlyph> {\n    return new Protobuf(data).readFields(readFontstacks, []);\n}\n\nexport const GLYPH_PBF_BORDER = border;\n","// @flow\n\nimport { bindAll } from './util';\nimport { serialize, deserialize } from './web_worker_transfer';\n\nimport type {Transferable} from '../types/transferable';\nimport type {Cancelable} from '../types/cancelable';\n\n/**\n * An implementation of the [Actor design pattern](http://en.wikipedia.org/wiki/Actor_model)\n * that maintains the relationship between asynchronous tasks and the objects\n * that spin them off - in this case, tasks like parsing parts of styles,\n * owned by the styles\n *\n * @param {WebWorker} target\n * @param {WebWorker} parent\n * @param {string|number} mapId A unique identifier for the Map instance using this Actor.\n * @private\n */\nclass Actor {\n    target: any;\n    parent: any;\n    mapId: string;\n    callbacks: any;\n    callbackID: number;\n    name: string;\n\n    constructor(target: any, parent: any, mapId: any) {\n        this.target = target;\n        this.parent = parent;\n        this.mapId = mapId;\n        this.callbacks = {};\n        this.callbackID = 0;\n        bindAll(['receive'], this);\n        this.target.addEventListener('message', this.receive, false);\n    }\n\n    /**\n     * Sends a message from a main-thread map to a Worker or from a Worker back to\n     * a main-thread map instance.\n     *\n     * @param type The name of the target method to invoke or '[source-type].[source-name].name' for a method on a WorkerSource.\n     * @param targetMapId A particular mapId to which to send this message.\n     * @private\n     */\n    send(type: string, data: mixed, callback: ?Function, targetMapId: ?string): ?Cancelable {\n        const id = callback ? `${this.mapId}:${this.callbackID++}` : null;\n        if (callback) this.callbacks[id] = callback;\n        const buffers: Array<Transferable> = [];\n        this.target.postMessage({\n            targetMapId,\n            sourceMapId: this.mapId,\n            type,\n            id: String(id),\n            data: serialize(data, buffers)\n        }, buffers);\n        if (callback) {\n            return {\n                cancel: () => this.target.postMessage({\n                    targetMapId,\n                    sourceMapId: this.mapId,\n                    type: '<cancel>',\n                    id: String(id)\n                })\n            };\n        }\n    }\n\n    receive(message: Object) {\n        const data = message.data,\n            id = data.id;\n        let callback;\n\n        if (data.targetMapId && this.mapId !== data.targetMapId)\n            return;\n\n        const done = (err, data) => {\n            delete this.callbacks[id];\n            const buffers: Array<Transferable> = [];\n            this.target.postMessage({\n                sourceMapId: this.mapId,\n                type: '<response>',\n                id: String(id),\n                error: err ? serialize(err) : null,\n                data: serialize(data, buffers)\n            }, buffers);\n        };\n\n        if (data.type === '<response>' || data.type === '<cancel>') {\n            callback = this.callbacks[data.id];\n            delete this.callbacks[data.id];\n            if (callback && data.error) {\n                callback(deserialize(data.error));\n            } else if (callback) {\n                callback(null, deserialize(data.data));\n            }\n        } else if (typeof data.id !== 'undefined' && this.parent[data.type]) {\n            // data.type == 'loadTile', 'removeTile', etc.\n            // Add a placeholder so that we can discover when the done callback was called already.\n            this.callbacks[data.id] = null;\n            const cancelable = this.parent[data.type](data.sourceMapId, deserialize(data.data), done);\n            if (cancelable && this.callbacks[data.id] === null) {\n                // Only add the cancelable callback if the done callback wasn't already called.\n                // Otherwise we will never be able to delete it.\n                this.callbacks[data.id]  = cancelable;\n            }\n        } else if (typeof data.id !== 'undefined' && this.parent.getWorkerSource) {\n            // data.type == sourcetype.method\n            const keys = data.type.split('.');\n            const params = (deserialize(data.data): any);\n            const workerSource = (this.parent: any).getWorkerSource(data.sourceMapId, keys[0], params.source);\n            workerSource[keys[1]](params, done);\n        } else {\n            this.parent[data.type](deserialize(data.data));\n        }\n    }\n\n    remove() {\n        this.target.removeEventListener('message', this.receive, false);\n    }\n}\n\nexport default Actor;\n","export { getURL, getTileBBox, getMercCoords };\n\n\n/**\n * getURL\n *\n * @param    {String}  baseUrl  Base url of the WMS server\n * @param    {String}  layer    Layer name\n * @param    {Number}  x        Tile coordinate x\n * @param    {Number}  y        Tile coordinate y\n * @param    {Number}  z        Tile zoom\n * @param    {Object}  [options]\n * @param    {String}  [options.format='image/png']\n * @param    {String}  [options.service='WMS']\n * @param    {String}  [options.version='1.1.1']\n * @param    {String}  [options.request='GetMap']\n * @param    {String}  [options.srs='EPSG:3857']\n * @param    {Number}  [options.width='256']\n * @param    {Number}  [options.height='256']\n * @returns  {String}  url\n * @example\n * var baseUrl = 'http://geodata.state.nj.us/imagerywms/Natural2015';\n * var layer = 'Natural2015';\n * var url = whoots.getURL(baseUrl, layer, 154308, 197167, 19);\n */\nfunction getURL(baseUrl, layer, x, y, z, options) {\n    options = options || {};\n\n    var url = baseUrl + '?' + [\n        'bbox='    + getTileBBox(x, y, z),\n        'format='  + (options.format || 'image/png'),\n        'service=' + (options.service || 'WMS'),\n        'version=' + (options.version || '1.1.1'),\n        'request=' + (options.request || 'GetMap'),\n        'srs='     + (options.srs || 'EPSG:3857'),\n        'width='   + (options.width || 256),\n        'height='  + (options.height || 256),\n        'layers='  + layer\n    ].join('&');\n\n    return url;\n}\n\n\n/**\n * getTileBBox\n *\n * @param    {Number}  x  Tile coordinate x\n * @param    {Number}  y  Tile coordinate y\n * @param    {Number}  z  Tile zoom\n * @returns  {String}  String of the bounding box\n */\nfunction getTileBBox(x, y, z) {\n    // for Google/OSM tile scheme we need to alter the y\n    y = (Math.pow(2, z) - y - 1);\n\n    var min = getMercCoords(x * 256, y * 256, z),\n        max = getMercCoords((x + 1) * 256, (y + 1) * 256, z);\n\n    return min[0] + ',' + min[1] + ',' + max[0] + ',' + max[1];\n}\n\n\n/**\n * getMercCoords\n *\n * @param    {Number}  x  Pixel coordinate x\n * @param    {Number}  y  Pixel coordinate y\n * @param    {Number}  z  Tile zoom\n * @returns  {Array}   [x, y]\n */\nfunction getMercCoords(x, y, z) {\n    var resolution = (2 * Math.PI * 6378137 / 256) / Math.pow(2, z),\n        merc_x = (x * resolution - 2 * Math.PI  * 6378137 / 2.0),\n        merc_y = (y * resolution - 2 * Math.PI  * 6378137 / 2.0);\n\n    return [merc_x, merc_y];\n}\n","// @flow\n\nimport LngLat from './lng_lat';\n\nimport type {LngLatLike} from './lng_lat';\n\n/**\n * A `LngLatBounds` object represents a geographical bounding box,\n * defined by its southwest and northeast points in longitude and latitude.\n *\n * If no arguments are provided to the constructor, a `null` bounding box is created.\n *\n * Note that any Mapbox GL method that accepts a `LngLatBounds` object as an argument or option\n * can also accept an `Array` of two {@link LngLatLike} constructs and will perform an implicit conversion.\n * This flexible type is documented as {@link LngLatBoundsLike}.\n *\n * @param {LngLatLike} [sw] The southwest corner of the bounding box.\n * @param {LngLatLike} [ne] The northeast corner of the bounding box.\n * @example\n * var sw = new mapboxgl.LngLat(-73.9876, 40.7661);\n * var ne = new mapboxgl.LngLat(-73.9397, 40.8002);\n * var llb = new mapboxgl.LngLatBounds(sw, ne);\n */\nclass LngLatBounds {\n    _ne: LngLat;\n    _sw: LngLat;\n\n    // This constructor is too flexible to type. It should not be so flexible.\n    constructor(sw: any, ne: any) {\n        if (!sw) {\n            // noop\n        } else if (ne) {\n            this.setSouthWest(sw).setNorthEast(ne);\n        } else if (sw.length === 4) {\n            this.setSouthWest([sw[0], sw[1]]).setNorthEast([sw[2], sw[3]]);\n        } else {\n            this.setSouthWest(sw[0]).setNorthEast(sw[1]);\n        }\n    }\n\n    /**\n     * Set the northeast corner of the bounding box\n     *\n     * @param {LngLatLike} ne\n     * @returns {LngLatBounds} `this`\n     */\n    setNorthEast(ne: LngLatLike) {\n        this._ne = ne instanceof LngLat ? new LngLat(ne.lng, ne.lat) : LngLat.convert(ne);\n        return this;\n    }\n\n    /**\n     * Set the southwest corner of the bounding box\n     *\n     * @param {LngLatLike} sw\n     * @returns {LngLatBounds} `this`\n     */\n    setSouthWest(sw: LngLatLike) {\n        this._sw = sw instanceof LngLat ? new LngLat(sw.lng, sw.lat) : LngLat.convert(sw);\n        return this;\n    }\n\n    /**\n     * Extend the bounds to include a given LngLat or LngLatBounds.\n     *\n     * @param {LngLat|LngLatBounds} obj object to extend to\n     * @returns {LngLatBounds} `this`\n     */\n    extend(obj: LngLat | LngLatBounds) {\n        const sw = this._sw,\n            ne = this._ne;\n        let sw2, ne2;\n\n        if (obj instanceof LngLat) {\n            sw2 = obj;\n            ne2 = obj;\n\n        } else if (obj instanceof LngLatBounds) {\n            sw2 = obj._sw;\n            ne2 = obj._ne;\n\n            if (!sw2 || !ne2) return this;\n\n        } else {\n            if (Array.isArray(obj)) {\n                if (obj.every(Array.isArray)) {\n                    return this.extend(LngLatBounds.convert(obj));\n                } else {\n                    return this.extend(LngLat.convert(obj));\n                }\n            }\n            return this;\n        }\n\n        if (!sw && !ne) {\n            this._sw = new LngLat(sw2.lng, sw2.lat);\n            this._ne = new LngLat(ne2.lng, ne2.lat);\n\n        } else {\n            sw.lng = Math.min(sw2.lng, sw.lng);\n            sw.lat = Math.min(sw2.lat, sw.lat);\n            ne.lng = Math.max(ne2.lng, ne.lng);\n            ne.lat = Math.max(ne2.lat, ne.lat);\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns the geographical coordinate equidistant from the bounding box's corners.\n     *\n     * @returns {LngLat} The bounding box's center.\n     * @example\n     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n     * llb.getCenter(); // = LngLat {lng: -73.96365, lat: 40.78315}\n     */\n    getCenter(): LngLat {\n        return new LngLat((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);\n    }\n\n    /**\n     * Returns the southwest corner of the bounding box.\n     *\n     * @returns {LngLat} The southwest corner of the bounding box.\n     */\n    getSouthWest(): LngLat { return this._sw; }\n\n    /**\n    * Returns the northeast corner of the bounding box.\n    *\n    * @returns {LngLat} The northeast corner of the bounding box.\n     */\n    getNorthEast(): LngLat { return this._ne; }\n\n    /**\n    * Returns the northwest corner of the bounding box.\n    *\n    * @returns {LngLat} The northwest corner of the bounding box.\n     */\n    getNorthWest(): LngLat { return new LngLat(this.getWest(), this.getNorth()); }\n\n    /**\n    * Returns the southeast corner of the bounding box.\n    *\n    * @returns {LngLat} The southeast corner of the bounding box.\n     */\n    getSouthEast(): LngLat { return new LngLat(this.getEast(), this.getSouth()); }\n\n    /**\n    * Returns the west edge of the bounding box.\n    *\n    * @returns {number} The west edge of the bounding box.\n     */\n    getWest(): number { return this._sw.lng; }\n\n    /**\n    * Returns the south edge of the bounding box.\n    *\n    * @returns {number} The south edge of the bounding box.\n     */\n    getSouth(): number { return this._sw.lat; }\n\n    /**\n    * Returns the east edge of the bounding box.\n    *\n    * @returns {number} The east edge of the bounding box.\n     */\n    getEast(): number { return this._ne.lng; }\n\n    /**\n    * Returns the north edge of the bounding box.\n    *\n    * @returns {number} The north edge of the bounding box.\n     */\n    getNorth(): number { return this._ne.lat; }\n\n    /**\n     * Returns the bounding box represented as an array.\n     *\n     * @returns {Array<Array<number>>} The bounding box represented as an array, consisting of the\n     *   southwest and northeast coordinates of the bounding represented as arrays of numbers.\n     * @example\n     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n     * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]\n     */\n    toArray() {\n        return [this._sw.toArray(), this._ne.toArray()];\n    }\n\n    /**\n     * Return the bounding box represented as a string.\n     *\n     * @returns {string} The bounding box represents as a string of the format\n     *   `'LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))'`.\n     * @example\n     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n     * llb.toString(); // = \"LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))\"\n     */\n    toString() {\n        return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;\n    }\n\n    /**\n     * Check if the bounding box is an empty/`null`-type box.\n     *\n     * @returns {boolean} True if bounds have been defined, otherwise false.\n     */\n    isEmpty() {\n        return !(this._sw && this._ne);\n    }\n\n    /**\n     * Converts an array to a `LngLatBounds` object.\n     *\n     * If a `LngLatBounds` object is passed in, the function returns it unchanged.\n     *\n     * Internally, the function calls `LngLat#convert` to convert arrays to `LngLat` values.\n     *\n     * @param {LngLatBoundsLike} input An array of two coordinates to convert, or a `LngLatBounds` object to return.\n     * @returns {LngLatBounds} A new `LngLatBounds` object, if a conversion occurred, or the original `LngLatBounds` object.\n     * @example\n     * var arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];\n     * var llb = mapboxgl.LngLatBounds.convert(arr);\n     * llb;   // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}\n     */\n    static convert(input: LngLatBoundsLike): LngLatBounds {\n        if (!input || input instanceof LngLatBounds) return input;\n        return new LngLatBounds(input);\n    }\n}\n\n/**\n * A {@link LngLatBounds} object, an array of {@link LngLatLike} objects in [sw, ne] order,\n * or an array of numbers in [west, south, east, north] order.\n *\n * @typedef {LngLatBounds | [LngLatLike, LngLatLike] | [number, number, number, number]} LngLatBoundsLike\n * @example\n * var v1 = new mapboxgl.LngLatBounds(\n *   new mapboxgl.LngLat(-73.9876, 40.7661),\n *   new mapboxgl.LngLat(-73.9397, 40.8002)\n * );\n * var v2 = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002])\n * var v3 = [[-73.9876, 40.7661], [-73.9397, 40.8002]];\n */\nexport type LngLatBoundsLike = LngLatBounds | [LngLatLike, LngLatLike] | [number, number, number, number];\n\nexport default LngLatBounds;\n","// @flow\n\nimport { wrap } from '../util/util';\nimport LngLatBounds from './lng_lat_bounds';\n\n/**\n * A `LngLat` object represents a given longitude and latitude coordinate, measured in degrees.\n *\n * Mapbox GL uses longitude, latitude coordinate order (as opposed to latitude, longitude) to match GeoJSON.\n *\n * Note that any Mapbox GL method that accepts a `LngLat` object as an argument or option\n * can also accept an `Array` of two numbers and will perform an implicit conversion.\n * This flexible type is documented as {@link LngLatLike}.\n *\n * @param {number} lng Longitude, measured in degrees.\n * @param {number} lat Latitude, measured in degrees.\n * @example\n * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);\n * @see [Get coordinates of the mouse pointer](https://www.mapbox.com/mapbox-gl-js/example/mouse-position/)\n * @see [Display a popup](https://www.mapbox.com/mapbox-gl-js/example/popup/)\n * @see [Highlight features within a bounding box](https://www.mapbox.com/mapbox-gl-js/example/using-box-queryrenderedfeatures/)\n * @see [Create a timeline animation](https://www.mapbox.com/mapbox-gl-js/example/timeline-animation/)\n */\nclass LngLat {\n    lng: number;\n    lat: number;\n\n    constructor(lng: number, lat: number) {\n        if (isNaN(lng) || isNaN(lat)) {\n            throw new Error(`Invalid LngLat object: (${lng}, ${lat})`);\n        }\n        this.lng = +lng;\n        this.lat = +lat;\n        if (this.lat > 90 || this.lat < -90) {\n            throw new Error('Invalid LngLat latitude value: must be between -90 and 90');\n        }\n    }\n\n    /**\n     * Returns a new `LngLat` object whose longitude is wrapped to the range (-180, 180).\n     *\n     * @returns {LngLat} The wrapped `LngLat` object.\n     * @example\n     * var ll = new mapboxgl.LngLat(286.0251, 40.7736);\n     * var wrapped = ll.wrap();\n     * wrapped.lng; // = -73.9749\n     */\n    wrap() {\n        return new LngLat(wrap(this.lng, -180, 180), this.lat);\n    }\n\n    /**\n     * Returns the coordinates represented as an array of two numbers.\n     *\n     * @returns {Array<number>} The coordinates represeted as an array of longitude and latitude.\n     * @example\n     * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);\n     * ll.toArray(); // = [-73.9749, 40.7736]\n     */\n    toArray() {\n        return [this.lng, this.lat];\n    }\n\n    /**\n     * Returns the coordinates represent as a string.\n     *\n     * @returns {string} The coordinates represented as a string of the format `'LngLat(lng, lat)'`.\n     * @example\n     * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);\n     * ll.toString(); // = \"LngLat(-73.9749, 40.7736)\"\n     */\n    toString() {\n        return `LngLat(${this.lng}, ${this.lat})`;\n    }\n\n    /**\n     * Returns a `LngLatBounds` from the coordinates extended by a given `radius`.\n     *\n     * @param {number} [radius=0] Distance in meters from the coordinates to extend the bounds.\n     * @returns {LngLatBounds} A new `LngLatBounds` object representing the coordinates extended by the `radius`.\n     * @example\n     * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);\n     * ll.toBounds(100).toArray(); // = [[-73.97501862141328, 40.77351016847229], [-73.97478137858673, 40.77368983152771]]\n     */\n    toBounds(radius?: number = 0) {\n        const earthCircumferenceInMetersAtEquator = 40075017;\n        const latAccuracy = 360 * radius / earthCircumferenceInMetersAtEquator,\n            lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);\n\n        return new LngLatBounds(new LngLat(this.lng - lngAccuracy, this.lat - latAccuracy),\n            new LngLat(this.lng + lngAccuracy, this.lat + latAccuracy));\n    }\n\n    /**\n     * Converts an array of two numbers or an object with `lng` and `lat` or `lon` and `lat` properties\n     * to a `LngLat` object.\n     *\n     * If a `LngLat` object is passed in, the function returns it unchanged.\n     *\n     * @param {LngLatLike} input An array of two numbers or object to convert, or a `LngLat` object to return.\n     * @returns {LngLat} A new `LngLat` object, if a conversion occurred, or the original `LngLat` object.\n     * @example\n     * var arr = [-73.9749, 40.7736];\n     * var ll = mapboxgl.LngLat.convert(arr);\n     * ll;   // = LngLat {lng: -73.9749, lat: 40.7736}\n     */\n    static convert(input: LngLatLike): LngLat {\n        if (input instanceof LngLat) {\n            return input;\n        }\n        if (Array.isArray(input) && (input.length === 2 || input.length === 3)) {\n            return new LngLat(Number(input[0]), Number(input[1]));\n        }\n        if (!Array.isArray(input) && typeof input === 'object' && input !== null) {\n            return new LngLat(\n                // flow can't refine this to have one of lng or lat, so we have to cast to any\n                Number('lng' in input ? (input: any).lng : (input: any).lon),\n                Number(input.lat)\n            );\n        }\n        throw new Error(\"`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]\");\n    }\n}\n\n/**\n * A {@link LngLat} object, an array of two numbers representing longitude and latitude,\n * or an object with `lng` and `lat` or `lon` and `lat` properties.\n *\n * @typedef {LngLat | {lng: number, lat: number} | {lon: number, lat: number} | [number, number]} LngLatLike\n * @example\n * var v1 = new mapboxgl.LngLat(-122.420679, 37.772537);\n * var v2 = [-122.420679, 37.772537];\n * var v3 = {lon: -122.420679, lat: 37.772537};\n */\nexport type LngLatLike = LngLat | {lng: number, lat: number} | {lon: number, lat: number} | [number, number];\n\nexport default LngLat;\n","// @flow\n\nimport LngLat from '../geo/lng_lat';\nimport type {LngLatLike} from '../geo/lng_lat';\n\n/*\n * The circumference of the world in meters at the given latitude.\n */\nfunction circumferenceAtLatitude(latitude: number) {\n    const circumference = 2 * Math.PI * 6378137;\n    return circumference * Math.cos(latitude * Math.PI / 180);\n}\n\nexport function mercatorXfromLng(lng: number) {\n    return (180 + lng) / 360;\n}\n\nexport function mercatorYfromLat(lat: number) {\n    return (180 - (180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360)))) / 360;\n}\n\nexport function mercatorZfromAltitude(altitude: number, lat: number) {\n    return altitude / circumferenceAtLatitude(lat);\n}\n\nexport function lngFromMercatorX(x: number) {\n    return x * 360 - 180;\n}\n\nexport function latFromMercatorY(y: number) {\n    const y2 = 180 - y * 360;\n    return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n}\n\nexport function altitudeFromMercatorZ(z: number, y: number) {\n    return z * circumferenceAtLatitude(latFromMercatorY(y));\n}\n\n/**\n * A `MercatorCoordinate` object represents a projected three dimensional position.\n *\n * `MercatorCoordinate` uses the web mercator projection ([EPSG:3857](https://epsg.io/3857)) with slightly different units:\n * - the size of 1 unit is the width of the projected world instead of the \"mercator meter\"\n * - the origin of the coordinate space is at the north-west corner instead of the middle\n *\n * For example, `MercatorCoordinate(0, 0, 0)` is the north-west corner of the mercator world and\n * `MercatorCoordinate(1, 1, 0)` is the south-east corner. If you are familiar with\n * [vector tiles](https://github.com/mapbox/vector-tile-spec) it may be helpful to think\n * of the coordinate space as the `0/0/0` tile with an extent of `1`.\n *\n * The `z` dimension of `MercatorCoordinate` is conformal. A cube in the mercator coordinate space would be rendered as a cube.\n *\n * @param {number} x The x component of the position.\n * @param {number} y The y component of the position.\n * @param {number} z The z component of the position.\n * @example\n * var nullIsland = new mapboxgl.MercatorCoordinate(0.5, 0.5, 0);\n *\n * @see [Add a custom style layer](https://www.mapbox.com/mapbox-gl-js/example/custom-style-layer/)\n */\nclass MercatorCoordinate {\n    x: number;\n    y: number;\n    z: number;\n\n    constructor(x: number, y: number, z: number = 0) {\n        this.x = +x;\n        this.y = +y;\n        this.z = +z;\n    }\n\n    /**\n     * Project a `LngLat` to a `MercatorCoordinate`.\n     *\n     * @param {LngLatLike} lngLatLike The location to project.\n     * @param {number} altitude The altitude in meters of the position.\n     * @returns {MercatorCoordinate} The projected mercator coordinate.\n     * @example\n     * var coord = mapboxgl.MercatorCoordinate.fromLngLat({ lng: 0, lat: 0}, 0);\n     * coord; // MercatorCoordinate(0.5, 0.5, 0)\n     */\n    static fromLngLat(lngLatLike: LngLatLike, altitude: number = 0) {\n        const lngLat = LngLat.convert(lngLatLike);\n\n        return new MercatorCoordinate(\n                mercatorXfromLng(lngLat.lng),\n                mercatorYfromLat(lngLat.lat),\n                mercatorZfromAltitude(altitude, lngLat.lat));\n    }\n\n    /**\n     * Returns the `LngLat` for the coordinate.\n     *\n     * @returns {LngLat} The `LngLat` object.\n     * @example\n     * var coord = new mapboxgl.MercatorCoordinate(0.5, 0.5, 0);\n     * var latLng = coord.toLngLat(); // LngLat(0, 0)\n     */\n    toLngLat() {\n        return new LngLat(\n                lngFromMercatorX(this.x),\n                latFromMercatorY(this.y));\n    }\n\n    /**\n     * Returns the altitude in meters of the coordinate.\n     *\n     * @returns {number} The altitude in meters.\n     * @example\n     * var coord = new mapboxgl.MercatorCoordinate(0, 0, 0.02);\n     * coord.toAltitude(); // 6914.281956295339\n     */\n    toAltitude() {\n        return altitudeFromMercatorZ(this.z, this.y);\n    }\n}\n\nexport default MercatorCoordinate;\n","// @flow\n\nimport {getTileBBox} from '@mapbox/whoots-js';\nimport EXTENT from '../data/extent';\nimport Point from '@mapbox/point-geometry';\nimport MercatorCoordinate from '../geo/mercator_coordinate';\n\nimport assert from 'assert';\nimport { register } from '../util/web_worker_transfer';\n\nexport class CanonicalTileID {\n    z: number;\n    x: number;\n    y: number;\n    key: number;\n\n    constructor(z: number, x: number, y: number) {\n        assert(z >= 0 && z <= 25);\n        assert(x >= 0 && x < Math.pow(2, z));\n        assert(y >= 0 && y < Math.pow(2, z));\n        this.z = z;\n        this.x = x;\n        this.y = y;\n        this.key = calculateKey(0, z, x, y);\n    }\n\n    equals(id: CanonicalTileID) {\n        return this.z === id.z && this.x === id.x && this.y === id.y;\n    }\n\n    // given a list of urls, choose a url template and return a tile URL\n    url(urls: Array<string>, scheme: ?string) {\n        const bbox = getTileBBox(this.x, this.y, this.z);\n        const quadkey = getQuadkey(this.z, this.x, this.y);\n\n        return urls[(this.x + this.y) % urls.length]\n            .replace('{prefix}', (this.x % 16).toString(16) + (this.y % 16).toString(16))\n            .replace('{z}', String(this.z))\n            .replace('{x}', String(this.x))\n            .replace('{y}', String(scheme === 'tms' ? (Math.pow(2, this.z) - this.y - 1) : this.y))\n            .replace('{quadkey}', quadkey)\n            .replace('{bbox-epsg-3857}', bbox);\n    }\n\n    getTilePoint(coord: MercatorCoordinate) {\n        const tilesAtZoom = Math.pow(2, this.z);\n        return new Point(\n            (coord.x * tilesAtZoom - this.x) * EXTENT,\n            (coord.y * tilesAtZoom - this.y) * EXTENT);\n    }\n}\n\nexport class UnwrappedTileID {\n    wrap: number;\n    canonical: CanonicalTileID;\n    key: number;\n\n    constructor(wrap: number, canonical: CanonicalTileID) {\n        this.wrap = wrap;\n        this.canonical = canonical;\n        this.key = calculateKey(wrap, canonical.z, canonical.x, canonical.y);\n    }\n}\n\nexport class OverscaledTileID {\n    overscaledZ: number;\n    wrap: number;\n    canonical: CanonicalTileID;\n    key: number;\n    posMatrix: Float32Array;\n\n    constructor(overscaledZ: number, wrap: number, z: number, x: number, y: number) {\n        assert(overscaledZ >= z);\n        this.overscaledZ = overscaledZ;\n        this.wrap = wrap;\n        this.canonical = new CanonicalTileID(z, +x, +y);\n        this.key = calculateKey(wrap, overscaledZ, x, y);\n    }\n\n    equals(id: OverscaledTileID) {\n        return this.overscaledZ === id.overscaledZ && this.wrap === id.wrap && this.canonical.equals(id.canonical);\n    }\n\n    scaledTo(targetZ: number) {\n        assert(targetZ <= this.overscaledZ);\n        const zDifference = this.canonical.z - targetZ;\n        if (targetZ > this.canonical.z) {\n            return new OverscaledTileID(targetZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);\n        } else {\n            return new OverscaledTileID(targetZ, this.wrap, targetZ, this.canonical.x >> zDifference, this.canonical.y >> zDifference);\n        }\n    }\n\n    isChildOf(parent: OverscaledTileID) {\n        if (parent.wrap !== this.wrap) {\n            // We can't be a child if we're in a different world copy\n            return false;\n        }\n        const zDifference = this.canonical.z - parent.canonical.z;\n        // We're first testing for z == 0, to avoid a 32 bit shift, which is undefined.\n        return parent.overscaledZ === 0 || (\n            parent.overscaledZ < this.overscaledZ &&\n                parent.canonical.x === (this.canonical.x >> zDifference) &&\n                parent.canonical.y === (this.canonical.y >> zDifference));\n    }\n\n    children(sourceMaxZoom: number) {\n        if (this.overscaledZ >= sourceMaxZoom) {\n            // return a single tile coord representing a an overscaled tile\n            return [new OverscaledTileID(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];\n        }\n\n        const z = this.canonical.z + 1;\n        const x = this.canonical.x * 2;\n        const y = this.canonical.y * 2;\n        return [\n            new OverscaledTileID(z, this.wrap, z, x, y),\n            new OverscaledTileID(z, this.wrap, z, x + 1, y),\n            new OverscaledTileID(z, this.wrap, z, x, y + 1),\n            new OverscaledTileID(z, this.wrap, z, x + 1, y + 1)\n        ];\n    }\n\n    isLessThan(rhs: OverscaledTileID) {\n        if (this.wrap < rhs.wrap) return true;\n        if (this.wrap > rhs.wrap) return false;\n\n        if (this.overscaledZ < rhs.overscaledZ) return true;\n        if (this.overscaledZ > rhs.overscaledZ) return false;\n\n        if (this.canonical.x < rhs.canonical.x) return true;\n        if (this.canonical.x > rhs.canonical.x) return false;\n\n        if (this.canonical.y < rhs.canonical.y) return true;\n        return false;\n    }\n\n    wrapped() {\n        return new OverscaledTileID(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);\n    }\n\n    unwrapTo(wrap: number) {\n        return new OverscaledTileID(this.overscaledZ, wrap, this.canonical.z, this.canonical.x, this.canonical.y);\n    }\n\n    overscaleFactor() {\n        return Math.pow(2, this.overscaledZ - this.canonical.z);\n    }\n\n    toUnwrapped() {\n        return new UnwrappedTileID(this.wrap, this.canonical);\n    }\n\n    toString() {\n        return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;\n    }\n\n    getTilePoint(coord: MercatorCoordinate) {\n        return this.canonical.getTilePoint(new MercatorCoordinate(coord.x - this.wrap, coord.y));\n    }\n}\n\nfunction calculateKey(wrap: number, z: number, x: number, y: number) {\n    wrap *= 2;\n    if (wrap < 0) wrap = wrap * -1 - 1;\n    const dim = 1 << z;\n    return ((dim * dim * wrap + dim * y + x) * 32) + z;\n}\n\n\nfunction getQuadkey(z, x, y) {\n    let quadkey = '', mask;\n    for (let i = z; i > 0; i--) {\n        mask = 1 << (i - 1);\n        quadkey += ((x & mask ? 1 : 0) + (y & mask ? 2 : 0));\n    }\n    return quadkey;\n}\n\nregister('CanonicalTileID', CanonicalTileID);\nregister('OverscaledTileID', OverscaledTileID, {omit: ['posMatrix']});\n","// @flow\n\nimport LngLatBounds from '../geo/lng_lat_bounds';\nimport {mercatorXfromLng, mercatorYfromLat} from '../geo/mercator_coordinate';\n\nimport type {CanonicalTileID} from './tile_id';\n\nclass TileBounds {\n    bounds: LngLatBounds;\n    minzoom: number;\n    maxzoom: number;\n\n    constructor(bounds: [number, number, number, number], minzoom: ?number, maxzoom: ?number) {\n        this.bounds = LngLatBounds.convert(this.validateBounds(bounds));\n        this.minzoom = minzoom || 0;\n        this.maxzoom = maxzoom || 24;\n    }\n\n    validateBounds(bounds: [number, number, number, number]) {\n        // make sure the bounds property contains valid longitude and latitudes\n        if (!Array.isArray(bounds) || bounds.length !== 4) return [-180, -90, 180, 90];\n        return [Math.max(-180, bounds[0]), Math.max(-90, bounds[1]), Math.min(180, bounds[2]), Math.min(90, bounds[3])];\n    }\n\n    contains(tileID: CanonicalTileID) {\n        const worldSize = Math.pow(2, tileID.z);\n        const level = {\n            minX: Math.floor(mercatorXfromLng(this.bounds.getWest()) * worldSize),\n            minY: Math.floor(mercatorYfromLat(this.bounds.getNorth()) * worldSize),\n            maxX: Math.ceil(mercatorXfromLng(this.bounds.getEast()) * worldSize),\n            maxY: Math.ceil(mercatorYfromLat(this.bounds.getSouth()) * worldSize)\n        };\n        const hit = tileID.x >= level.minX && tileID.x < level.maxX && tileID.y >= level.minY && tileID.y < level.maxY;\n        return hit;\n    }\n}\n\nexport default TileBounds;\n","// @flow\n\nimport { extend, pick } from '../util/util';\n\nimport { getImage, ResourceType } from '../util/ajax';\nimport { Event, ErrorEvent, Evented } from '../util/evented';\nimport loadTileJSON from './load_tilejson';\nimport { normalizeTileURL as normalizeURL, postTurnstileEvent, postMapLoadEvent } from '../util/mapbox';\nimport TileBounds from './tile_bounds';\nimport Texture from '../render/texture';\n\nimport type {Source} from './source';\nimport type {OverscaledTileID} from './tile_id';\nimport type Map from '../ui/map';\nimport type Dispatcher from '../util/dispatcher';\nimport type Tile from './tile';\nimport type {Callback} from '../types/callback';\nimport type {Cancelable} from '../types/cancelable';\nimport type {\n    RasterSourceSpecification,\n    RasterDEMSourceSpecification\n} from '../style-spec/types';\n\nclass RasterTileSource extends Evented implements Source {\n    type: 'raster' | 'raster-dem';\n    id: string;\n    minzoom: number;\n    maxzoom: number;\n    url: string;\n    scheme: string;\n    tileSize: number;\n\n    bounds: ?[number, number, number, number];\n    tileBounds: TileBounds;\n    roundZoom: boolean;\n    dispatcher: Dispatcher;\n    map: Map;\n    tiles: Array<string>;\n\n    _loaded: boolean;\n    _options: RasterSourceSpecification | RasterDEMSourceSpecification;\n    _tileJSONRequest: ?Cancelable;\n\n    constructor(id: string, options: RasterSourceSpecification | RasterDEMSourceSpecification, dispatcher: Dispatcher, eventedParent: Evented) {\n        super();\n        this.id = id;\n        this.dispatcher = dispatcher;\n        this.setEventedParent(eventedParent);\n\n        this.type = 'raster';\n        this.minzoom = 0;\n        this.maxzoom = 22;\n        this.roundZoom = true;\n        this.scheme = 'xyz';\n        this.tileSize = 512;\n        this._loaded = false;\n\n        this._options = extend({}, options);\n        extend(this, pick(options, ['url', 'scheme', 'tileSize']));\n    }\n\n    load() {\n        this.fire(new Event('dataloading', {dataType: 'source'}));\n        this._tileJSONRequest = loadTileJSON(this._options, this.map._transformRequest, (err, tileJSON) => {\n            this._tileJSONRequest = null;\n            if (err) {\n                this.fire(new ErrorEvent(err));\n            } else if (tileJSON) {\n                extend(this, tileJSON);\n                if (tileJSON.bounds) this.tileBounds = new TileBounds(tileJSON.bounds, this.minzoom, this.maxzoom);\n\n                postTurnstileEvent(tileJSON.tiles);\n                postMapLoadEvent(tileJSON.tiles, this.map._getMapId());\n\n                // `content` is included here to prevent a race condition where `Style#_updateSources` is called\n                // before the TileJSON arrives. this makes sure the tiles needed are loaded once TileJSON arrives\n                // ref: https://github.com/mapbox/mapbox-gl-js/pull/4347#discussion_r104418088\n                this.fire(new Event('data', {dataType: 'source', sourceDataType: 'metadata'}));\n                this.fire(new Event('data', {dataType: 'source', sourceDataType: 'content'}));\n            }\n        });\n    }\n\n    onAdd(map: Map) {\n        this.map = map;\n        this.load();\n    }\n\n    onRemove() {\n        if (this._tileJSONRequest) {\n            this._tileJSONRequest.cancel();\n            this._tileJSONRequest = null;\n        }\n    }\n\n    serialize() {\n        return extend({}, this._options);\n    }\n\n    hasTile(tileID: OverscaledTileID) {\n        return !this.tileBounds || this.tileBounds.contains(tileID.canonical);\n    }\n\n    loadTile(tile: Tile, callback: Callback<void>) {\n        const url = normalizeURL(tile.tileID.canonical.url(this.tiles, this.scheme), this.url, this.tileSize);\n        tile.request = getImage(this.map._transformRequest(url, ResourceType.Tile), (err, img) => {\n            delete tile.request;\n\n            if (tile.aborted) {\n                tile.state = 'unloaded';\n                callback(null);\n            } else if (err) {\n                tile.state = 'errored';\n                callback(err);\n            } else if (img) {\n                if (this.map._refreshExpiredTiles) tile.setExpiryData(img);\n                delete (img: any).cacheControl;\n                delete (img: any).expires;\n\n                const context = this.map.painter.context;\n                const gl = context.gl;\n                tile.texture = this.map.painter.getTileTexture(img.width);\n                if (tile.texture) {\n                    tile.texture.update(img, { useMipmap: true });\n                } else {\n                    tile.texture = new Texture(context, img, gl.RGBA, { useMipmap: true });\n                    tile.texture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE, gl.LINEAR_MIPMAP_NEAREST);\n\n                    if (context.extTextureFilterAnisotropic) {\n                        gl.texParameterf(gl.TEXTURE_2D, context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, context.extTextureFilterAnisotropicMax);\n                    }\n                }\n\n                tile.state = 'loaded';\n\n                callback(null);\n            }\n        });\n    }\n\n    abortTile(tile: Tile, callback: Callback<void>) {\n        if (tile.request) {\n            tile.request.cancel();\n            delete tile.request;\n        }\n        callback();\n    }\n\n    unloadTile(tile: Tile, callback: Callback<void>) {\n        if (tile.texture) this.map.painter.saveTileTexture(tile.texture);\n        callback();\n    }\n\n    hasTransition() {\n        return false;\n    }\n}\n\nexport default RasterTileSource;\n","// @flow\nimport { RGBAImage } from '../util/image';\n\nimport { warnOnce } from '../util/util';\nimport { register } from '../util/web_worker_transfer';\n\n// DEMData is a data structure for decoding, backfilling, and storing elevation data for processing in the hillshade shaders\n// data can be populated either from a pngraw image tile or from serliazed data sent back from a worker. When data is initially\n// loaded from a image tile, we decode the pixel values using the appropriate decoding formula, but we store the\n// elevation data as an Int32 value. we add 65536 (2^16) to eliminate negative values and enable the use of\n// integer overflow when creating the texture used in the hillshadePrepare step.\n\n// DEMData also handles the backfilling of data from a tile's neighboring tiles. This is necessary because we use a pixel's 8\n// surrounding pixel values to compute the slope at that pixel, and we cannot accurately calculate the slope at pixels on a\n// tile's edge without backfilling from neighboring tiles.\n\nexport default class DEMData {\n    uid: string;\n    data: Int32Array;\n    stride: number;\n    dim: number;\n\n    constructor(uid: string, data: RGBAImage, encoding: \"mapbox\" | \"terrarium\") {\n        this.uid = uid;\n        if (data.height !== data.width) throw new RangeError('DEM tiles must be square');\n        if (encoding && encoding !== \"mapbox\" && encoding !== \"terrarium\") return warnOnce(\n            `\"${encoding}\" is not a valid encoding type. Valid types include \"mapbox\" and \"terrarium\".`\n        );\n        const dim = this.dim = data.height;\n        this.stride = this.dim + 2;\n        this.data = new Int32Array(this.stride * this.stride);\n\n        const pixels = data.data;\n        const unpack = encoding === \"terrarium\" ? this._unpackTerrarium : this._unpackMapbox;\n        for (let y = 0; y < dim; y++) {\n            for (let x = 0; x < dim; x++) {\n                const i = y * dim + x;\n                const j = i * 4;\n                this.set(x, y, unpack(pixels[j], pixels[j + 1], pixels[j + 2]));\n            }\n        }\n\n        // in order to avoid flashing seams between tiles, here we are initially populating a 1px border of pixels around the image\n        // with the data of the nearest pixel from the image. this data is eventually replaced when the tile's neighboring\n        // tiles are loaded and the accurate data can be backfilled using DEMData#backfillBorder\n        for (let x = 0; x < dim; x++) {\n            // left vertical border\n            this.set(-1, x, this.get(0, x));\n            // right vertical border\n            this.set(dim, x, this.get(dim - 1, x));\n            // left horizontal border\n            this.set(x, -1, this.get(x, 0));\n            // right horizontal border\n            this.set(x, dim, this.get(x, dim - 1));\n        }\n        // corners\n        this.set(-1, -1, this.get(0, 0));\n        this.set(dim, -1, this.get(dim - 1, 0));\n        this.set(-1, dim, this.get(0, dim - 1));\n        this.set(dim, dim, this.get(dim - 1, dim - 1));\n    }\n\n    set(x: number, y: number, value: number) {\n        this.data[this._idx(x, y)] = value + 65536;\n    }\n\n    get(x: number, y: number) {\n        return this.data[this._idx(x, y)] - 65536;\n    }\n\n    _idx(x: number, y: number) {\n        if (x < -1 || x >= this.dim + 1 ||  y < -1 || y >= this.dim + 1) throw new RangeError('out of range source coordinates for DEM data');\n        return (y + 1) * this.stride + (x + 1);\n    }\n\n    _unpackMapbox(r: number, g: number, b: number) {\n        // unpacking formula for mapbox.terrain-rgb:\n        // https://www.mapbox.com/help/access-elevation-data/#mapbox-terrain-rgb\n        return ((r * 256 * 256 + g * 256.0 + b) / 10.0 - 10000.0);\n    }\n\n    _unpackTerrarium(r: number, g: number, b: number) {\n        // unpacking formula for mapzen terrarium:\n        // https://aws.amazon.com/public-datasets/terrain/\n        return ((r * 256 + g + b / 256) - 32768.0);\n    }\n\n    getPixels() {\n        return new RGBAImage({width: this.stride, height: this.stride}, new Uint8Array(this.data.buffer));\n    }\n\n    backfillBorder(borderTile: DEMData, dx: number, dy: number) {\n        if (this.dim !== borderTile.dim) throw new Error('dem dimension mismatch');\n\n        let xMin = dx * this.dim,\n            xMax = dx * this.dim + this.dim,\n            yMin = dy * this.dim,\n            yMax = dy * this.dim + this.dim;\n\n        switch (dx) {\n        case -1:\n            xMin = xMax - 1;\n            break;\n        case 1:\n            xMax = xMin + 1;\n            break;\n        }\n\n        switch (dy) {\n        case -1:\n            yMin = yMax - 1;\n            break;\n        case 1:\n            yMax = yMin + 1;\n            break;\n        }\n\n        const ox = -dx * this.dim;\n        const oy = -dy * this.dim;\n        for (let y = yMin; y < yMax; y++) {\n            for (let x = xMin; x < xMax; x++) {\n                this.set(x, y, borderTile.get(x + ox, y + oy));\n            }\n        }\n    }\n}\n\nregister('DEMData', DEMData);\n","// @flow\n\nimport { getImage, ResourceType } from '../util/ajax';\nimport { extend } from '../util/util';\nimport { Evented } from '../util/evented';\nimport { normalizeTileURL as normalizeURL } from '../util/mapbox';\nimport browser from '../util/browser';\nimport { OverscaledTileID } from './tile_id';\nimport RasterTileSource from './raster_tile_source';\n// ensure DEMData is registered for worker transfer on main thread:\nimport '../data/dem_data';\n\nimport type {Source} from './source';\nimport type Dispatcher from '../util/dispatcher';\nimport type Tile from './tile';\nimport type {Callback} from '../types/callback';\nimport type {RasterDEMSourceSpecification} from '../style-spec/types';\n\n\nclass RasterDEMTileSource extends RasterTileSource implements Source {\n    encoding: \"mapbox\" | \"terrarium\";\n\n    constructor(id: string, options: RasterDEMSourceSpecification, dispatcher: Dispatcher, eventedParent: Evented) {\n        super(id, options, dispatcher, eventedParent);\n        this.type = 'raster-dem';\n        this.maxzoom = 22;\n        this._options = extend({}, options);\n        this.encoding = options.encoding || \"mapbox\";\n    }\n\n    serialize() {\n        return {\n            type: 'raster-dem',\n            url: this.url,\n            tileSize: this.tileSize,\n            tiles: this.tiles,\n            bounds: this.bounds,\n            encoding: this.encoding\n        };\n    }\n\n    loadTile(tile: Tile, callback: Callback<void>) {\n        const url = normalizeURL(tile.tileID.canonical.url(this.tiles, this.scheme), this.url, this.tileSize);\n        tile.request = getImage(this.map._transformRequest(url, ResourceType.Tile), imageLoaded.bind(this));\n\n        tile.neighboringTiles = this._getNeighboringTiles(tile.tileID);\n        function imageLoaded(err, img) {\n            delete tile.request;\n            if (tile.aborted) {\n                tile.state = 'unloaded';\n                callback(null);\n            } else if (err) {\n                tile.state = 'errored';\n                callback(err);\n            } else if (img) {\n                if (this.map._refreshExpiredTiles) tile.setExpiryData(img);\n                delete (img: any).cacheControl;\n                delete (img: any).expires;\n\n                const rawImageData = browser.getImageData(img);\n                const params = {\n                    uid: tile.uid,\n                    coord: tile.tileID,\n                    source: this.id,\n                    rawImageData,\n                    encoding: this.encoding\n                };\n\n                if (!tile.workerID || tile.state === 'expired') {\n                    tile.workerID = this.dispatcher.send('loadDEMTile', params, done.bind(this));\n                }\n            }\n        }\n\n        function done(err, dem) {\n            if (err) {\n                tile.state = 'errored';\n                callback(err);\n            }\n\n            if (dem) {\n                tile.dem = dem;\n                tile.needsHillshadePrepare = true;\n                tile.state = 'loaded';\n                callback(null);\n            }\n        }\n    }\n\n\n    _getNeighboringTiles(tileID: OverscaledTileID) {\n        const canonical = tileID.canonical;\n        const dim = Math.pow(2, canonical.z);\n\n        const px = (canonical.x - 1 + dim) % dim;\n        const pxw = canonical.x === 0 ? tileID.wrap - 1 : tileID.wrap;\n        const nx = (canonical.x + 1 + dim) % dim;\n        const nxw = canonical.x + 1 === dim ? tileID.wrap + 1 : tileID.wrap;\n\n        const neighboringTiles = {};\n        // add adjacent tiles\n        neighboringTiles[new OverscaledTileID(tileID.overscaledZ, pxw, canonical.z, px, canonical.y).key] = {backfilled: false};\n        neighboringTiles[new OverscaledTileID(tileID.overscaledZ, nxw, canonical.z, nx, canonical.y).key] = {backfilled: false};\n\n        // Add upper neighboringTiles\n        if (canonical.y > 0) {\n            neighboringTiles[new OverscaledTileID(tileID.overscaledZ, pxw, canonical.z, px, canonical.y - 1).key] = {backfilled: false};\n            neighboringTiles[new OverscaledTileID(tileID.overscaledZ, tileID.wrap, canonical.z, canonical.x, canonical.y - 1).key] = {backfilled: false};\n            neighboringTiles[new OverscaledTileID(tileID.overscaledZ, nxw, canonical.z, nx, canonical.y - 1).key] = {backfilled: false};\n        }\n        // Add lower neighboringTiles\n        if (canonical.y + 1 < dim) {\n            neighboringTiles[new OverscaledTileID(tileID.overscaledZ, pxw, canonical.z, px, canonical.y + 1).key] = {backfilled: false};\n            neighboringTiles[new OverscaledTileID(tileID.overscaledZ, tileID.wrap, canonical.z, canonical.x, canonical.y + 1).key] = {backfilled: false};\n            neighboringTiles[new OverscaledTileID(tileID.overscaledZ, nxw, canonical.z, nx, canonical.y + 1).key] = {backfilled: false};\n        }\n\n        return neighboringTiles;\n    }\n\n\n    unloadTile(tile: Tile) {\n        if (tile.demTexture) this.map.painter.saveTileTexture(tile.demTexture);\n        if (tile.fbo) {\n            tile.fbo.destroy();\n            delete tile.fbo;\n        }\n        if (tile.dem) delete tile.dem;\n        delete tile.neighboringTiles;\n\n        tile.state = 'unloaded';\n        this.dispatcher.send('removeDEMTile', { uid: tile.uid, source: this.id }, undefined, tile.workerID);\n    }\n\n}\n\nexport default RasterDEMTileSource;\n","\nimport refProperties from './util/ref_properties';\n\nfunction stringify(obj) {\n    const type = typeof obj;\n    if (type === 'number' || type === 'boolean' || type === 'string' || obj === undefined || obj === null)\n        return JSON.stringify(obj);\n\n    if (Array.isArray(obj)) {\n        let str = '[';\n        for (const val of obj) {\n            str += `${stringify(val)},`;\n        }\n        return `${str}]`;\n    }\n\n    const keys = Object.keys(obj).sort();\n\n    let str = '{';\n    for (let i = 0; i < keys.length; i++) {\n        str += `${JSON.stringify(keys[i])}:${stringify(obj[keys[i]])},`;\n    }\n    return `${str}}`;\n}\n\nfunction getKey(layer) {\n    let key = '';\n    for (const k of refProperties) {\n        key += `/${stringify(layer[k])}`;\n    }\n    return key;\n}\n\nexport default groupByLayout;\n\n/**\n * Given an array of layers, return an array of arrays of layers where all\n * layers in each group have identical layout-affecting properties. These\n * are the properties that were formerly used by explicit `ref` mechanism\n * for layers: 'type', 'source', 'source-layer', 'minzoom', 'maxzoom',\n * 'filter', and 'layout'.\n *\n * The input is not modified. The output layers are references to the\n * input layers.\n *\n * @private\n * @param {Array<Layer>} layers\n * @returns {Array<Array<Layer>>}\n */\nfunction groupByLayout(layers) {\n    const groups = {};\n\n    for (let i = 0; i < layers.length; i++) {\n        const k = getKey(layers[i]);\n        let group = groups[k];\n        if (!group) {\n            group = groups[k] = [];\n        }\n        group.push(layers[i]);\n    }\n\n    const result = [];\n\n    for (const k in groups) {\n        result.push(groups[k]);\n    }\n\n    return result;\n}\n","// @flow\n\nimport StyleLayer from './style_layer';\nimport createStyleLayer from './create_style_layer';\n\nimport { values } from '../util/util';\nimport featureFilter from '../style-spec/feature_filter';\nimport groupByLayout from '../style-spec/group_by_layout';\n\nimport type {TypedStyleLayer} from './style_layer/typed_style_layer';\nimport type {LayerSpecification} from '../style-spec/types';\n\nexport type LayerConfigs = { [string]: LayerSpecification };\nexport type Family<Layer: TypedStyleLayer> = Array<Layer>;\n\nclass StyleLayerIndex {\n    familiesBySource: { [source: string]: { [sourceLayer: string]: Array<Family<*>> } };\n\n    _layerConfigs: LayerConfigs;\n    _layers: { [string]: StyleLayer };\n\n    constructor(layerConfigs: ?Array<LayerSpecification>) {\n        if (layerConfigs) {\n            this.replace(layerConfigs);\n        }\n    }\n\n    replace(layerConfigs: Array<LayerSpecification>) {\n        this._layerConfigs = {};\n        this._layers = {};\n        this.update(layerConfigs, []);\n    }\n\n    update(layerConfigs: Array<LayerSpecification>, removedIds: Array<string>) {\n        for (const layerConfig of layerConfigs) {\n            this._layerConfigs[layerConfig.id] = layerConfig;\n\n            const layer = this._layers[layerConfig.id] = createStyleLayer(layerConfig);\n            layer._featureFilter = featureFilter(layer.filter);\n        }\n        for (const id of removedIds) {\n            delete this._layerConfigs[id];\n            delete this._layers[id];\n        }\n\n        this.familiesBySource = {};\n\n        const groups = groupByLayout(values(this._layerConfigs));\n\n        for (const layerConfigs of groups) {\n            const layers = layerConfigs.map((layerConfig) => this._layers[layerConfig.id]);\n\n            const layer = layers[0];\n            if (layer.visibility === 'none') {\n                continue;\n            }\n\n            const sourceId = layer.source || '';\n            let sourceGroup = this.familiesBySource[sourceId];\n            if (!sourceGroup) {\n                sourceGroup = this.familiesBySource[sourceId] = {};\n            }\n\n            const sourceLayerId = layer.sourceLayer || '_geojsonTileLayer';\n            let sourceLayerFamilies = sourceGroup[sourceLayerId];\n            if (!sourceLayerFamilies) {\n                sourceLayerFamilies = sourceGroup[sourceLayerId] = [];\n            }\n\n            sourceLayerFamilies.push(layers);\n        }\n    }\n}\n\nexport default StyleLayerIndex;\n","// @flow\n\nexport default checkMaxAngle;\n\nimport type Point from '@mapbox/point-geometry';\nimport type Anchor from './anchor';\n\n/**\n * Labels placed around really sharp angles aren't readable. Check if any\n * part of the potential label has a combined angle that is too big.\n *\n * @param line\n * @param anchor The point on the line around which the label is anchored.\n * @param labelLength The length of the label in geometry units.\n * @param windowSize The check fails if the combined angles within a part of the line that is `windowSize` long is too big.\n * @param maxAngle The maximum combined angle that any window along the label is allowed to have.\n *\n * @returns {boolean} whether the label should be placed\n * @private\n */\nfunction checkMaxAngle(line: Array<Point>, anchor: Anchor, labelLength: number, windowSize: number, maxAngle: number) {\n\n    // horizontal labels always pass\n    if (anchor.segment === undefined) return true;\n\n    let p = anchor;\n    let index = anchor.segment + 1;\n    let anchorDistance = 0;\n\n    // move backwards along the line to the first segment the label appears on\n    while (anchorDistance > -labelLength / 2) {\n        index--;\n\n        // there isn't enough room for the label after the beginning of the line\n        if (index < 0) return false;\n\n        anchorDistance -= line[index].dist(p);\n        p = line[index];\n    }\n\n    anchorDistance += line[index].dist(line[index + 1]);\n    index++;\n\n    // store recent corners and their total angle difference\n    const recentCorners = [];\n    let recentAngleDelta = 0;\n\n    // move forwards by the length of the label and check angles along the way\n    while (anchorDistance < labelLength / 2) {\n        const prev = line[index - 1];\n        const current = line[index];\n        const next = line[index + 1];\n\n        // there isn't enough room for the label before the end of the line\n        if (!next) return false;\n\n        let angleDelta = prev.angleTo(current) - current.angleTo(next);\n        // restrict angle to -pi..pi range\n        angleDelta = Math.abs(((angleDelta + 3 * Math.PI) % (Math.PI * 2)) - Math.PI);\n\n        recentCorners.push({\n            distance: anchorDistance,\n            angleDelta\n        });\n        recentAngleDelta += angleDelta;\n\n        // remove corners that are far enough away from the list of recent anchors\n        while (anchorDistance - recentCorners[0].distance > windowSize) {\n            recentAngleDelta -= recentCorners.shift().angleDelta;\n        }\n\n        // the sum of angles within the window area exceeds the maximum allowed value. check fails.\n        if (recentAngleDelta > maxAngle) return false;\n\n        index++;\n        anchorDistance += current.dist(next);\n    }\n\n    // no part of the line had an angle greater than the maximum allowed. check passes.\n    return true;\n}\n","// @flow\n\nimport { number as interpolate } from '../style-spec/util/interpolate';\n\nimport Anchor from '../symbol/anchor';\nimport checkMaxAngle from './check_max_angle';\n\nimport type Point from '@mapbox/point-geometry';\nimport type {Shaping, PositionedIcon} from './shaping';\n\nexport { getAnchors, getCenterAnchor };\n\nfunction getLineLength(line: Array<Point>): number {\n    let lineLength = 0;\n    for (let k = 0; k < line.length - 1; k++) {\n        lineLength += line[k].dist(line[k + 1]);\n    }\n    return lineLength;\n}\n\nfunction getAngleWindowSize(shapedText: ?Shaping,\n                            glyphSize: number,\n                            boxScale: number): number {\n    return shapedText ?\n        3 / 5 * glyphSize * boxScale :\n        0;\n}\n\nfunction getShapedLabelLength(shapedText: ?Shaping, shapedIcon: ?PositionedIcon): number {\n    return Math.max(\n        shapedText ? shapedText.right - shapedText.left : 0,\n        shapedIcon ? shapedIcon.right - shapedIcon.left : 0);\n}\n\nfunction getCenterAnchor(line: Array<Point>,\n                         maxAngle: number,\n                         shapedText: ?Shaping,\n                         shapedIcon: ?PositionedIcon,\n                         glyphSize: number,\n                         boxScale: number) {\n    const angleWindowSize = getAngleWindowSize(shapedText, glyphSize, boxScale);\n    const labelLength = getShapedLabelLength(shapedText, shapedIcon) * boxScale;\n\n    let prevDistance = 0;\n    const centerDistance = getLineLength(line) / 2;\n\n    for (let i = 0; i < line.length - 1; i++) {\n\n        const a = line[i],\n            b = line[i + 1];\n\n        const segmentDistance = a.dist(b);\n\n        if (prevDistance + segmentDistance > centerDistance) {\n            // The center is on this segment\n            const t = (centerDistance - prevDistance) / segmentDistance,\n                x = interpolate(a.x, b.x, t),\n                y = interpolate(a.y, b.y, t);\n\n            const anchor = new Anchor(x, y, b.angleTo(a), i);\n            anchor._round();\n            if (!angleWindowSize || checkMaxAngle(line, anchor, labelLength, angleWindowSize, maxAngle)) {\n                return anchor;\n            } else {\n                return;\n            }\n        }\n\n        prevDistance += segmentDistance;\n    }\n}\n\nfunction getAnchors(line: Array<Point>,\n                    spacing: number,\n                    maxAngle: number,\n                    shapedText: ?Shaping,\n                    shapedIcon: ?PositionedIcon,\n                    glyphSize: number,\n                    boxScale: number,\n                    overscaling: number,\n                    tileExtent: number) {\n\n    // Resample a line to get anchor points for labels and check that each\n    // potential label passes text-max-angle check and has enough froom to fit\n    // on the line.\n\n    const angleWindowSize = getAngleWindowSize(shapedText, glyphSize, boxScale);\n    const shapedLabelLength = getShapedLabelLength(shapedText, shapedIcon);\n    const labelLength = shapedLabelLength * boxScale;\n\n    // Is the line continued from outside the tile boundary?\n    const isLineContinued = line[0].x === 0 || line[0].x === tileExtent || line[0].y === 0 || line[0].y === tileExtent;\n\n    // Is the label long, relative to the spacing?\n    // If so, adjust the spacing so there is always a minimum space of `spacing / 4` between label edges.\n    if (spacing - labelLength < spacing / 4) {\n        spacing = labelLength + spacing / 4;\n    }\n\n    // Offset the first anchor by:\n    // Either half the label length plus a fixed extra offset if the line is not continued\n    // Or half the spacing if the line is continued.\n\n    // For non-continued lines, add a bit of fixed extra offset to avoid collisions at T intersections.\n    const fixedExtraOffset = glyphSize * 2;\n\n    const offset = !isLineContinued ?\n        ((shapedLabelLength / 2 + fixedExtraOffset) * boxScale * overscaling) % spacing :\n        (spacing / 2 * overscaling) % spacing;\n\n    return resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, false, tileExtent);\n}\n\n\nfunction resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, placeAtMiddle, tileExtent) {\n\n    const halfLabelLength = labelLength / 2;\n    const lineLength = getLineLength(line);\n\n    let distance = 0,\n        markedDistance = offset - spacing;\n\n    let anchors = [];\n\n    for (let i = 0; i < line.length - 1; i++) {\n\n        const a = line[i],\n            b = line[i + 1];\n\n        const segmentDist = a.dist(b),\n            angle = b.angleTo(a);\n\n        while (markedDistance + spacing < distance + segmentDist) {\n            markedDistance += spacing;\n\n            const t = (markedDistance - distance) / segmentDist,\n                x = interpolate(a.x, b.x, t),\n                y = interpolate(a.y, b.y, t);\n\n            // Check that the point is within the tile boundaries and that\n            // the label would fit before the beginning and end of the line\n            // if placed at this point.\n            if (x >= 0 && x < tileExtent && y >= 0 && y < tileExtent &&\n                    markedDistance - halfLabelLength >= 0 &&\n                    markedDistance + halfLabelLength <= lineLength) {\n                const anchor = new Anchor(x, y, angle, i);\n                anchor._round();\n\n                if (!angleWindowSize || checkMaxAngle(line, anchor, labelLength, angleWindowSize, maxAngle)) {\n                    anchors.push(anchor);\n                }\n            }\n        }\n\n        distance += segmentDist;\n    }\n\n    if (!placeAtMiddle && !anchors.length && !isLineContinued) {\n        // The first attempt at finding anchors at which labels can be placed failed.\n        // Try again, but this time just try placing one anchor at the middle of the line.\n        // This has the most effect for short lines in overscaled tiles, since the\n        // initial offset used in overscaled tiles is calculated to align labels with positions in\n        // parent tiles instead of placing the label as close to the beginning as possible.\n        anchors = resample(line, distance / 2, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, true, tileExtent);\n    }\n\n    return anchors;\n}\n","// @flow\n\nimport type {CollisionBoxArray} from '../data/array_types';\nimport Point from '@mapbox/point-geometry';\nimport type Anchor from './anchor';\n\n/**\n * A CollisionFeature represents the area of the tile covered by a single label.\n * It is used with CollisionIndex to check if the label overlaps with any\n * previous labels. A CollisionFeature is mostly just a set of CollisionBox\n * objects.\n *\n * @private\n */\nclass CollisionFeature {\n    boxStartIndex: number;\n    boxEndIndex: number;\n\n    /**\n     * Create a CollisionFeature, adding its collision box data to the given collisionBoxArray in the process.\n     *\n     * @param line The geometry the label is placed on.\n     * @param anchor The point along the line around which the label is anchored.\n     * @param shaped The text or icon shaping results.\n     * @param boxScale A magic number used to convert from glyph metrics units to geometry units.\n     * @param padding The amount of padding to add around the label edges.\n     * @param alignLine Whether the label is aligned with the line or the viewport.\n     */\n    constructor(collisionBoxArray: CollisionBoxArray,\n                line: Array<Point>,\n                anchor: Anchor,\n                featureIndex: number,\n                sourceLayerIndex: number,\n                bucketIndex: number,\n                shaped: Object,\n                boxScale: number,\n                padding: number,\n                alignLine: boolean,\n                overscaling: number,\n                rotate: number) {\n        let y1 = shaped.top * boxScale - padding;\n        let y2 = shaped.bottom * boxScale + padding;\n        let x1 = shaped.left * boxScale - padding;\n        let x2 = shaped.right * boxScale + padding;\n\n        this.boxStartIndex = collisionBoxArray.length;\n\n        if (alignLine) {\n\n            let height = y2 - y1;\n            const length = x2 - x1;\n\n            if (height > 0) {\n                // set minimum box height to avoid very many small labels\n                height = Math.max(10 * boxScale, height);\n\n                this._addLineCollisionCircles(collisionBoxArray, line, anchor, (anchor.segment: any), length, height, featureIndex, sourceLayerIndex, bucketIndex, overscaling);\n            }\n\n        } else {\n            if (rotate) {\n                // Account for *-rotate in point collision boxes\n                // See https://github.com/mapbox/mapbox-gl-js/issues/6075\n                // Doesn't account for icon-text-fit\n\n                const tl = new Point(x1, y1);\n                const tr = new Point(x2, y1);\n                const bl = new Point(x1, y2);\n                const br = new Point(x2, y2);\n\n                const rotateRadians = rotate * Math.PI / 180;\n\n                tl._rotate(rotateRadians);\n                tr._rotate(rotateRadians);\n                bl._rotate(rotateRadians);\n                br._rotate(rotateRadians);\n\n                // Collision features require an \"on-axis\" geometry,\n                // so take the envelope of the rotated geometry\n                // (may be quite large for wide labels rotated 45 degrees)\n                x1 = Math.min(tl.x, tr.x, bl.x, br.x);\n                x2 = Math.max(tl.x, tr.x, bl.x, br.x);\n                y1 = Math.min(tl.y, tr.y, bl.y, br.y);\n                y2 = Math.max(tl.y, tr.y, bl.y, br.y);\n            }\n            collisionBoxArray.emplaceBack(anchor.x, anchor.y, x1, y1, x2, y2, featureIndex, sourceLayerIndex, bucketIndex,\n                0, 0);\n        }\n\n        this.boxEndIndex = collisionBoxArray.length;\n    }\n\n    /**\n     * Create a set of CollisionBox objects for a line.\n     *\n     * @param labelLength The length of the label in geometry units.\n     * @param anchor The point along the line around which the label is anchored.\n     * @param boxSize The size of the collision boxes that will be created.\n     * @private\n     */\n    _addLineCollisionCircles(collisionBoxArray: CollisionBoxArray,\n                           line: Array<Point>,\n                           anchor: Anchor,\n                           segment: number,\n                           labelLength: number,\n                           boxSize: number,\n                           featureIndex: number,\n                           sourceLayerIndex: number,\n                           bucketIndex: number,\n                           overscaling: number) {\n        const step = boxSize / 2;\n        const nBoxes = Math.floor(labelLength / step) || 1;\n        // We calculate line collision circles out to 300% of what would normally be our\n        // max size, to allow collision detection to work on labels that expand as\n        // they move into the distance\n        // Vertically oriented labels in the distant field can extend past this padding\n        // This is a noticeable problem in overscaled tiles where the pitch 0-based\n        // symbol spacing will put labels very close together in a pitched map.\n        // To reduce the cost of adding extra collision circles, we slowly increase\n        // them for overscaled tiles.\n        const overscalingPaddingFactor = 1 + .4 * Math.log(overscaling) / Math.LN2;\n        const nPitchPaddingBoxes = Math.floor(nBoxes * overscalingPaddingFactor / 2);\n\n        // offset the center of the first box by half a box so that the edge of the\n        // box is at the edge of the label.\n        const firstBoxOffset = -boxSize / 2;\n\n        let p = anchor;\n        let index = segment + 1;\n        let anchorDistance = firstBoxOffset;\n        const labelStartDistance = -labelLength / 2;\n        const paddingStartDistance = labelStartDistance - labelLength / 4;\n        // move backwards along the line to the first segment the label appears on\n        do {\n            index--;\n\n            if (index < 0) {\n                if (anchorDistance > labelStartDistance) {\n                    // there isn't enough room for the label after the beginning of the line\n                    // checkMaxAngle should have already caught this\n                    return;\n                } else {\n                    // The line doesn't extend far enough back for all of our padding,\n                    // but we got far enough to show the label under most conditions.\n                    index = 0;\n                    break;\n                }\n            } else {\n                anchorDistance -= line[index].dist(p);\n                p = line[index];\n            }\n        } while (anchorDistance > paddingStartDistance);\n\n        let segmentLength = line[index].dist(line[index + 1]);\n\n        for (let i = -nPitchPaddingBoxes; i < nBoxes + nPitchPaddingBoxes; i++) {\n\n            // the distance the box will be from the anchor\n            const boxOffset = i * step;\n            let boxDistanceToAnchor = labelStartDistance + boxOffset;\n\n            // make the distance between pitch padding boxes bigger\n            if (boxOffset < 0) boxDistanceToAnchor += boxOffset;\n            if (boxOffset > labelLength) boxDistanceToAnchor += boxOffset - labelLength;\n\n            if (boxDistanceToAnchor < anchorDistance) {\n                // The line doesn't extend far enough back for this box, skip it\n                // (This could allow for line collisions on distant tiles)\n                continue;\n            }\n\n            // the box is not on the current segment. Move to the next segment.\n            while (anchorDistance + segmentLength < boxDistanceToAnchor) {\n                anchorDistance += segmentLength;\n                index++;\n\n                // There isn't enough room before the end of the line.\n                if (index + 1 >= line.length) {\n                    return;\n                }\n\n                segmentLength = line[index].dist(line[index + 1]);\n            }\n\n            // the distance the box will be from the beginning of the segment\n            const segmentBoxDistance = boxDistanceToAnchor - anchorDistance;\n\n            const p0 = line[index];\n            const p1 = line[index + 1];\n            const boxAnchorPoint = p1.sub(p0)._unit()._mult(segmentBoxDistance)._add(p0)._round();\n\n            // If the box is within boxSize of the anchor, force the box to be used\n            // (so even 0-width labels use at least one box)\n            // Otherwise, the .8 multiplication gives us a little bit of conservative\n            // padding in choosing which boxes to use (see CollisionIndex#placedCollisionCircles)\n            const paddedAnchorDistance = Math.abs(boxDistanceToAnchor - firstBoxOffset) < step ?\n                0 :\n                (boxDistanceToAnchor - firstBoxOffset) * 0.8;\n\n            collisionBoxArray.emplaceBack(boxAnchorPoint.x, boxAnchorPoint.y,\n                -boxSize / 2, -boxSize / 2, boxSize / 2, boxSize / 2,\n                featureIndex, sourceLayerIndex, bucketIndex,\n                boxSize / 2, paddedAnchorDistance);\n        }\n    }\n}\n\nexport default CollisionFeature;\n","\nexport default class TinyQueue {\n    constructor(data = [], compare = defaultCompare) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        const bottom = this.data.pop();\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let left = (pos << 1) + 1;\n            let best = data[left];\n            const right = left + 1;\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","// @flow\n\nimport Queue from 'tinyqueue';\n\nimport Point from '@mapbox/point-geometry';\nimport { distToSegmentSquared } from './intersection_tests';\n\n/**\n * Finds an approximation of a polygon's Pole Of Inaccessibiliy https://en.wikipedia.org/wiki/Pole_of_inaccessibility\n * This is a copy of http://github.com/mapbox/polylabel adapted to use Points\n *\n * @param polygonRings first item in array is the outer ring followed optionally by the list of holes, should be an element of the result of util/classify_rings\n * @param precision Specified in input coordinate units. If 0 returns after first run, if > 0 repeatedly narrows the search space until the radius of the area searched for the best pole is less than precision\n * @param debug Print some statistics to the console during execution\n * @returns Pole of Inaccessibiliy.\n * @private\n */\nexport default function (polygonRings: Array<Array<Point>>, precision?: number = 1, debug?: boolean = false): Point {\n    // find the bounding box of the outer ring\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    const outerRing = polygonRings[0];\n    for (let i = 0; i < outerRing.length; i++) {\n        const p = outerRing[i];\n        if (!i || p.x < minX) minX = p.x;\n        if (!i || p.y < minY) minY = p.y;\n        if (!i || p.x > maxX) maxX = p.x;\n        if (!i || p.y > maxY) maxY = p.y;\n    }\n\n    const width = maxX - minX;\n    const height = maxY - minY;\n    const cellSize = Math.min(width, height);\n    let h = cellSize / 2;\n\n    // a priority queue of cells in order of their \"potential\" (max distance to polygon)\n    const cellQueue = new Queue([], compareMax);\n\n    if (cellSize === 0) return new Point(minX, minY);\n\n    // cover polygon with initial cells\n    for (let x = minX; x < maxX; x += cellSize) {\n        for (let y = minY; y < maxY; y += cellSize) {\n            cellQueue.push(new Cell(x + h, y + h, h, polygonRings));\n        }\n    }\n\n    // take centroid as the first best guess\n    let bestCell = getCentroidCell(polygonRings);\n    let numProbes = cellQueue.length;\n\n    while (cellQueue.length) {\n        // pick the most promising cell from the queue\n        const cell = cellQueue.pop();\n\n        // update the best cell if we found a better one\n        if (cell.d > bestCell.d || !bestCell.d) {\n            bestCell = cell;\n            if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);\n        }\n\n        // do not drill down further if there's no chance of a better solution\n        if (cell.max - bestCell.d <= precision) continue;\n\n        // split the cell into four cells\n        h = cell.h / 2;\n        cellQueue.push(new Cell(cell.p.x - h, cell.p.y - h, h, polygonRings));\n        cellQueue.push(new Cell(cell.p.x + h, cell.p.y - h, h, polygonRings));\n        cellQueue.push(new Cell(cell.p.x - h, cell.p.y + h, h, polygonRings));\n        cellQueue.push(new Cell(cell.p.x + h, cell.p.y + h, h, polygonRings));\n        numProbes += 4;\n    }\n\n    if (debug) {\n        console.log(`num probes: ${numProbes}`);\n        console.log(`best distance: ${bestCell.d}`);\n    }\n\n    return bestCell.p;\n}\n\nfunction compareMax(a, b) {\n    return b.max - a.max;\n}\n\nfunction Cell(x, y, h, polygon) {\n    this.p = new Point(x, y);\n    this.h = h; // half the cell size\n    this.d = pointToPolygonDist(this.p, polygon); // distance from cell center to polygon\n    this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell\n}\n\n// signed distance from point to polygon outline (negative if point is outside)\nfunction pointToPolygonDist(p, polygon) {\n    let inside = false;\n    let minDistSq = Infinity;\n\n    for (let k = 0; k < polygon.length; k++) {\n        const ring = polygon[k];\n\n        for (let i = 0, len = ring.length, j = len - 1; i < len; j = i++) {\n            const a = ring[i];\n            const b = ring[j];\n\n            if ((a.y > p.y !== b.y > p.y) &&\n                (p.x < (b.x - a.x) * (p.y - a.y) / (b.y - a.y) + a.x)) inside = !inside;\n\n            minDistSq = Math.min(minDistSq, distToSegmentSquared(p, a, b));\n        }\n    }\n\n    return (inside ? 1 : -1) * Math.sqrt(minDistSq);\n}\n\n// get polygon centroid\nfunction getCentroidCell(polygon) {\n    let area = 0;\n    let x = 0;\n    let y = 0;\n    const points = polygon[0];\n    for (let i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        const a = points[i];\n        const b = points[j];\n        const f = a.x * b.y - b.x * a.y;\n        x += (a.x + b.x) * f;\n        y += (a.y + b.y) * f;\n        area += f * 3;\n    }\n    return new Cell(x / area, y / area, 0, polygon);\n}\n","/**\n * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)\n * \n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/murmurhash-js\n * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\n * @see http://sites.google.com/site/murmurhash/\n * \n * @param {string} key ASCII only\n * @param {number} seed Positive integer only\n * @return {number} 32-bit positive integer hash \n */\n\nfunction murmurhash3_32_gc(key, seed) {\n\tvar remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i;\n\t\n\tremainder = key.length & 3; // key.length % 4\n\tbytes = key.length - remainder;\n\th1 = seed;\n\tc1 = 0xcc9e2d51;\n\tc2 = 0x1b873593;\n\ti = 0;\n\t\n\twhile (i < bytes) {\n\t  \tk1 = \n\t  \t  ((key.charCodeAt(i) & 0xff)) |\n\t  \t  ((key.charCodeAt(++i) & 0xff) << 8) |\n\t  \t  ((key.charCodeAt(++i) & 0xff) << 16) |\n\t  \t  ((key.charCodeAt(++i) & 0xff) << 24);\n\t\t++i;\n\t\t\n\t\tk1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;\n\t\tk1 = (k1 << 15) | (k1 >>> 17);\n\t\tk1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;\n\n\t\th1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n\t\th1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;\n\t\th1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));\n\t}\n\t\n\tk1 = 0;\n\t\n\tswitch (remainder) {\n\t\tcase 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;\n\t\tcase 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;\n\t\tcase 1: k1 ^= (key.charCodeAt(i) & 0xff);\n\t\t\n\t\tk1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;\n\t\tk1 = (k1 << 15) | (k1 >>> 17);\n\t\tk1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;\n\t\th1 ^= k1;\n\t}\n\t\n\th1 ^= key.length;\n\n\th1 ^= h1 >>> 16;\n\th1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;\n\th1 ^= h1 >>> 13;\n\th1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;\n\th1 ^= h1 >>> 16;\n\n\treturn h1 >>> 0;\n}\n\nif(typeof module !== \"undefined\") {\n  module.exports = murmurhash3_32_gc\n}","/**\n * JS Implementation of MurmurHash2\n * \n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/murmurhash-js\n * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\n * @see http://sites.google.com/site/murmurhash/\n * \n * @param {string} str ASCII only\n * @param {number} seed Positive integer only\n * @return {number} 32-bit positive integer hash\n */\n\nfunction murmurhash2_32_gc(str, seed) {\n  var\n    l = str.length,\n    h = seed ^ l,\n    i = 0,\n    k;\n  \n  while (l >= 4) {\n  \tk = \n  \t  ((str.charCodeAt(i) & 0xff)) |\n  \t  ((str.charCodeAt(++i) & 0xff) << 8) |\n  \t  ((str.charCodeAt(++i) & 0xff) << 16) |\n  \t  ((str.charCodeAt(++i) & 0xff) << 24);\n    \n    k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));\n    k ^= k >>> 24;\n    k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));\n\n\th = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)) ^ k;\n\n    l -= 4;\n    ++i;\n  }\n  \n  switch (l) {\n  case 3: h ^= (str.charCodeAt(i + 2) & 0xff) << 16;\n  case 2: h ^= (str.charCodeAt(i + 1) & 0xff) << 8;\n  case 1: h ^= (str.charCodeAt(i) & 0xff);\n          h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));\n  }\n\n  h ^= h >>> 13;\n  h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));\n  h ^= h >>> 15;\n\n  return h >>> 0;\n}\n\nif(typeof module !== undefined) {\n  module.exports = murmurhash2_32_gc\n}\n","var murmur3 = require(\"./murmurhash3_gc.js\")\nvar murmur2 = require(\"./murmurhash2_gc.js\")\n\nmodule.exports = murmur3\nmodule.exports.murmur3 = murmur3\nmodule.exports.murmur2 = murmur2\n","// @flow\n\nimport Anchor from './anchor';\n\nimport { getAnchors, getCenterAnchor } from './get_anchors';\nimport clipLine from './clip_line';\nimport { shapeText, shapeIcon, WritingMode } from './shaping';\nimport { getGlyphQuads, getIconQuads } from './quads';\nimport CollisionFeature from './collision_feature';\nimport { warnOnce } from '../util/util';\nimport {\n    allowsVerticalWritingMode,\n    allowsLetterSpacing\n} from '../util/script_detection';\nimport findPoleOfInaccessibility from '../util/find_pole_of_inaccessibility';\nimport classifyRings from '../util/classify_rings';\nimport EXTENT from '../data/extent';\nimport SymbolBucket from '../data/bucket/symbol_bucket';\nimport EvaluationParameters from '../style/evaluation_parameters';\nimport {SIZE_PACK_FACTOR} from './symbol_size';\n\nimport type {Shaping, PositionedIcon} from './shaping';\nimport type {CollisionBoxArray} from '../data/array_types';\nimport type {SymbolFeature} from '../data/bucket/symbol_bucket';\nimport type {StyleImage} from '../style/style_image';\nimport type {StyleGlyph} from '../style/style_glyph';\nimport type SymbolStyleLayer from '../style/style_layer/symbol_style_layer';\nimport type {ImagePosition} from '../render/image_atlas';\nimport type {GlyphPosition} from '../render/glyph_atlas';\nimport type {PossiblyEvaluatedPropertyValue} from '../style/properties';\n\nimport Point from '@mapbox/point-geometry';\nimport murmur3 from 'murmurhash-js';\n\n// The symbol layout process needs `text-size` evaluated at up to five different zoom levels, and\n// `icon-size` at up to three:\n//\n//   1. `text-size` at the zoom level of the bucket. Used to calculate a per-feature size for source `text-size`\n//       expressions, and to calculate the box dimensions for icon-text-fit.\n//   2. `icon-size` at the zoom level of the bucket. Used to calculate a per-feature size for source `icon-size`\n//       expressions.\n//   3. `text-size` and `icon-size` at the zoom level of the bucket, plus one. Used to calculate collision boxes.\n//   4. `text-size` at zoom level 18. Used for something line-symbol-placement-related.\n//   5.  For composite `*-size` expressions: two zoom levels of curve stops that \"cover\" the zoom level of the\n//       bucket. These go into a vertex buffer and are used by the shader to interpolate the size at render time.\n//\n// (1) and (2) are stored in `bucket.layers[0].layout`. The remainder are below.\n//\ntype Sizes = {\n    layoutTextSize: PossiblyEvaluatedPropertyValue<number>, // (3)\n    layoutIconSize: PossiblyEvaluatedPropertyValue<number>, // (3)\n    textMaxSize: PossiblyEvaluatedPropertyValue<number>,    // (4)\n    compositeTextSizes: [PossiblyEvaluatedPropertyValue<number>, PossiblyEvaluatedPropertyValue<number>], // (5)\n    compositeIconSizes: [PossiblyEvaluatedPropertyValue<number>, PossiblyEvaluatedPropertyValue<number>], // (5)\n};\n\nexport function performSymbolLayout(bucket: SymbolBucket,\n                             glyphMap: {[string]: {[number]: ?StyleGlyph}},\n                             glyphPositions: {[string]: {[number]: GlyphPosition}},\n                             imageMap: {[string]: StyleImage},\n                             imagePositions: {[string]: ImagePosition},\n                             showCollisionBoxes: boolean) {\n    bucket.createArrays();\n\n    const tileSize = 512 * bucket.overscaling;\n    bucket.tilePixelRatio = EXTENT / tileSize;\n    bucket.compareText = {};\n    bucket.iconsNeedLinear = false;\n\n    const layout = bucket.layers[0].layout;\n    const unevaluatedLayoutValues = bucket.layers[0]._unevaluatedLayout._values;\n\n    const sizes = {};\n\n    if (bucket.textSizeData.functionType === 'composite') {\n        const {min, max} = bucket.textSizeData.zoomRange;\n        sizes.compositeTextSizes = [\n            unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(min)),\n            unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(max))\n        ];\n    }\n\n    if (bucket.iconSizeData.functionType === 'composite') {\n        const {min, max} = bucket.iconSizeData.zoomRange;\n        sizes.compositeIconSizes = [\n            unevaluatedLayoutValues['icon-size'].possiblyEvaluate(new EvaluationParameters(min)),\n            unevaluatedLayoutValues['icon-size'].possiblyEvaluate(new EvaluationParameters(max))\n        ];\n    }\n\n    sizes.layoutTextSize = unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(bucket.zoom + 1));\n    sizes.layoutIconSize = unevaluatedLayoutValues['icon-size'].possiblyEvaluate(new EvaluationParameters(bucket.zoom + 1));\n    sizes.textMaxSize = unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(18));\n\n    const oneEm = 24;\n    const lineHeight = layout.get('text-line-height') * oneEm;\n    const textAlongLine = layout.get('text-rotation-alignment') === 'map' && layout.get('symbol-placement') !== 'point';\n    const keepUpright = layout.get('text-keep-upright');\n\n\n    for (const feature of bucket.features) {\n        const fontstack = layout.get('text-font').evaluate(feature, {}).join(',');\n        const glyphPositionMap = glyphPositions;\n\n        const shapedTextOrientations = {};\n        const text = feature.text;\n        if (text) {\n            const unformattedText = text.toString();\n            const textOffset: [number, number] = (layout.get('text-offset').evaluate(feature, {}).map((t) => t * oneEm): any);\n            const spacing = layout.get('text-letter-spacing').evaluate(feature, {}) * oneEm;\n            const spacingIfAllowed = allowsLetterSpacing(unformattedText) ? spacing : 0;\n            const textAnchor = layout.get('text-anchor').evaluate(feature, {});\n            const textJustify = layout.get('text-justify').evaluate(feature, {});\n            const maxWidth = layout.get('symbol-placement') === 'point' ?\n                layout.get('text-max-width').evaluate(feature, {}) * oneEm :\n                0;\n\n            shapedTextOrientations.horizontal = shapeText(text, glyphMap, fontstack, maxWidth, lineHeight, textAnchor, textJustify, spacingIfAllowed, textOffset, oneEm, WritingMode.horizontal);\n            if (allowsVerticalWritingMode(unformattedText) && textAlongLine && keepUpright) {\n                shapedTextOrientations.vertical = shapeText(text, glyphMap, fontstack, maxWidth, lineHeight, textAnchor, textJustify, spacingIfAllowed, textOffset, oneEm, WritingMode.vertical);\n            }\n        }\n\n        let shapedIcon;\n        if (feature.icon) {\n            const image = imageMap[feature.icon];\n            if (image) {\n                shapedIcon = shapeIcon(\n                    imagePositions[feature.icon],\n                    layout.get('icon-offset').evaluate(feature, {}),\n                    layout.get('icon-anchor').evaluate(feature, {}));\n                if (bucket.sdfIcons === undefined) {\n                    bucket.sdfIcons = image.sdf;\n                } else if (bucket.sdfIcons !== image.sdf) {\n                    warnOnce('Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer');\n                }\n                if (image.pixelRatio !== bucket.pixelRatio) {\n                    bucket.iconsNeedLinear = true;\n                } else if (layout.get('icon-rotate').constantOr(1) !== 0) {\n                    bucket.iconsNeedLinear = true;\n                }\n            }\n        }\n\n        if (shapedTextOrientations.horizontal || shapedIcon) {\n            addFeature(bucket, feature, shapedTextOrientations, shapedIcon, glyphPositionMap, sizes);\n        }\n    }\n\n    if (showCollisionBoxes) {\n        bucket.generateCollisionDebugBuffers();\n    }\n}\n\n\n/**\n * Given a feature and its shaped text and icon data, add a 'symbol\n * instance' for each _possible_ placement of the symbol feature.\n * (At render timePlaceSymbols#place() selects which of these instances to\n * show or hide based on collisions with symbols in other layers.)\n * @private\n */\nfunction addFeature(bucket: SymbolBucket,\n                    feature: SymbolFeature,\n                    shapedTextOrientations: any,\n                    shapedIcon: PositionedIcon | void,\n                    glyphPositionMap: {[string]: {[number]: GlyphPosition}},\n                    sizes: Sizes) {\n    const layoutTextSize = sizes.layoutTextSize.evaluate(feature, {});\n    const layoutIconSize = sizes.layoutIconSize.evaluate(feature, {});\n\n    // To reduce the number of labels that jump around when zooming we need\n    // to use a text-size value that is the same for all zoom levels.\n    // bucket calculates text-size at a high zoom level so that all tiles can\n    // use the same value when calculating anchor positions.\n    let textMaxSize = sizes.textMaxSize.evaluate(feature, {});\n    if (textMaxSize === undefined) {\n        textMaxSize = layoutTextSize;\n    }\n\n    const layout = bucket.layers[0].layout;\n    const textOffset = layout.get('text-offset').evaluate(feature, {});\n    const iconOffset = layout.get('icon-offset').evaluate(feature, {});\n\n    const glyphSize = 24,\n        fontScale = layoutTextSize / glyphSize,\n        textBoxScale = bucket.tilePixelRatio * fontScale,\n        textMaxBoxScale = bucket.tilePixelRatio * textMaxSize / glyphSize,\n        iconBoxScale = bucket.tilePixelRatio * layoutIconSize,\n        symbolMinDistance = bucket.tilePixelRatio * layout.get('symbol-spacing'),\n        textPadding = layout.get('text-padding') * bucket.tilePixelRatio,\n        iconPadding = layout.get('icon-padding') * bucket.tilePixelRatio,\n        textMaxAngle = layout.get('text-max-angle') / 180 * Math.PI,\n        textAlongLine = layout.get('text-rotation-alignment') === 'map' && layout.get('symbol-placement') !== 'point',\n        iconAlongLine = layout.get('icon-rotation-alignment') === 'map' && layout.get('symbol-placement') !== 'point',\n        symbolPlacement = layout.get('symbol-placement'),\n        textRepeatDistance = symbolMinDistance / 2;\n\n    const addSymbolAtAnchor = (line, anchor) => {\n        if (anchor.x < 0 || anchor.x >= EXTENT || anchor.y < 0 || anchor.y >= EXTENT) {\n            // Symbol layers are drawn across tile boundaries, We filter out symbols\n            // outside our tile boundaries (which may be included in vector tile buffers)\n            // to prevent double-drawing symbols.\n            return;\n        }\n\n        addSymbol(bucket, anchor, line, shapedTextOrientations, shapedIcon, bucket.layers[0],\n            bucket.collisionBoxArray, feature.index, feature.sourceLayerIndex, bucket.index,\n            textBoxScale, textPadding, textAlongLine, textOffset,\n            iconBoxScale, iconPadding, iconAlongLine, iconOffset,\n            feature, glyphPositionMap, sizes);\n    };\n\n    if (symbolPlacement === 'line') {\n        for (const line of clipLine(feature.geometry, 0, 0, EXTENT, EXTENT)) {\n            const anchors = getAnchors(\n                line,\n                symbolMinDistance,\n                textMaxAngle,\n                shapedTextOrientations.vertical || shapedTextOrientations.horizontal,\n                shapedIcon,\n                glyphSize,\n                textMaxBoxScale,\n                bucket.overscaling,\n                EXTENT\n            );\n            for (const anchor of anchors) {\n                const shapedText = shapedTextOrientations.horizontal;\n                if (!shapedText || !anchorIsTooClose(bucket, shapedText.text, textRepeatDistance, anchor)) {\n                    addSymbolAtAnchor(line, anchor);\n                }\n            }\n        }\n    } else if (symbolPlacement === 'line-center') {\n        // No clipping, multiple lines per feature are allowed\n        // \"lines\" with only one point are ignored as in clipLines\n        for (const line of feature.geometry) {\n            if (line.length > 1) {\n                const anchor = getCenterAnchor(\n                    line,\n                    textMaxAngle,\n                    shapedTextOrientations.vertical || shapedTextOrientations.horizontal,\n                    shapedIcon,\n                    glyphSize,\n                    textMaxBoxScale);\n                if (anchor) {\n                    addSymbolAtAnchor(line, anchor);\n                }\n            }\n        }\n    } else if (feature.type === 'Polygon') {\n        for (const polygon of classifyRings(feature.geometry, 0)) {\n            // 16 here represents 2 pixels\n            const poi = findPoleOfInaccessibility(polygon, 16);\n            addSymbolAtAnchor(polygon[0], new Anchor(poi.x, poi.y, 0));\n        }\n    } else if (feature.type === 'LineString') {\n        // https://github.com/mapbox/mapbox-gl-js/issues/3808\n        for (const line of feature.geometry) {\n            addSymbolAtAnchor(line, new Anchor(line[0].x, line[0].y, 0));\n        }\n    } else if (feature.type === 'Point') {\n        for (const points of feature.geometry) {\n            for (const point of points) {\n                addSymbolAtAnchor([point], new Anchor(point.x, point.y, 0));\n            }\n        }\n    }\n}\n\nconst MAX_PACKED_SIZE = 65535;\n\nfunction addTextVertices(bucket: SymbolBucket,\n                         anchor: Point,\n                         shapedText: Shaping,\n                         layer: SymbolStyleLayer,\n                         textAlongLine: boolean,\n                         feature: SymbolFeature,\n                         textOffset: [number, number],\n                         lineArray: {lineStartIndex: number, lineLength: number},\n                         writingMode: number,\n                         placedTextSymbolIndices: Array<number>,\n                         glyphPositionMap: {[string]: {[number]: GlyphPosition}},\n                         sizes: Sizes) {\n    const glyphQuads = getGlyphQuads(anchor, shapedText,\n                            layer, textAlongLine, feature, glyphPositionMap);\n\n    const sizeData = bucket.textSizeData;\n    let textSizeData = null;\n\n    if (sizeData.functionType === 'source') {\n        textSizeData = [\n            SIZE_PACK_FACTOR * layer.layout.get('text-size').evaluate(feature, {})\n        ];\n        if (textSizeData[0] > MAX_PACKED_SIZE) {\n            warnOnce(`${bucket.layerIds[0]}: Value for \"text-size\" is >= 256. Reduce your \"text-size\".`);\n        }\n    } else if (sizeData.functionType === 'composite') {\n        textSizeData = [\n            SIZE_PACK_FACTOR * sizes.compositeTextSizes[0].evaluate(feature, {}),\n            SIZE_PACK_FACTOR * sizes.compositeTextSizes[1].evaluate(feature, {})\n        ];\n        if (textSizeData[0] > MAX_PACKED_SIZE || textSizeData[1] > MAX_PACKED_SIZE) {\n            warnOnce(`${bucket.layerIds[0]}: Value for \"text-size\" is >= 256. Reduce your \"text-size\".`);\n        }\n    }\n\n    bucket.addSymbols(\n        bucket.text,\n        glyphQuads,\n        textSizeData,\n        textOffset,\n        textAlongLine,\n        feature,\n        writingMode,\n        anchor,\n        lineArray.lineStartIndex,\n        lineArray.lineLength);\n\n    // The placedSymbolArray is used at render time in drawTileSymbols\n    // These indices allow access to the array at collision detection time\n    placedTextSymbolIndices.push(bucket.text.placedSymbolArray.length - 1);\n\n    return glyphQuads.length * 4;\n}\n\n\n/**\n * Add a single label & icon placement.\n *\n * @private\n */\nfunction addSymbol(bucket: SymbolBucket,\n                   anchor: Anchor,\n                   line: Array<Point>,\n                   shapedTextOrientations: any,\n                   shapedIcon: PositionedIcon | void,\n                   layer: SymbolStyleLayer,\n                   collisionBoxArray: CollisionBoxArray,\n                   featureIndex: number,\n                   sourceLayerIndex: number,\n                   bucketIndex: number,\n                   textBoxScale: number,\n                   textPadding: number,\n                   textAlongLine: boolean,\n                   textOffset: [number, number],\n                   iconBoxScale: number,\n                   iconPadding: number,\n                   iconAlongLine: boolean,\n                   iconOffset: [number, number],\n                   feature: SymbolFeature,\n                   glyphPositionMap: {[string]: {[number]: GlyphPosition}},\n                   sizes: Sizes) {\n    const lineArray = bucket.addToLineVertexArray(anchor, line);\n\n    let textCollisionFeature, iconCollisionFeature;\n\n    let numIconVertices = 0;\n    let numGlyphVertices = 0;\n    let numVerticalGlyphVertices = 0;\n    const key = murmur3(shapedTextOrientations.horizontal ? shapedTextOrientations.horizontal.text : '');\n    const placedTextSymbolIndices = [];\n    if (shapedTextOrientations.horizontal) {\n        // As a collision approximation, we can use either the vertical or the horizontal version of the feature\n        // We're counting on the two versions having similar dimensions\n        const textRotate = layer.layout.get('text-rotate').evaluate(feature, {});\n        textCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, shapedTextOrientations.horizontal, textBoxScale, textPadding, textAlongLine, bucket.overscaling, textRotate);\n        numGlyphVertices += addTextVertices(bucket, anchor, shapedTextOrientations.horizontal, layer, textAlongLine, feature, textOffset, lineArray, shapedTextOrientations.vertical ? WritingMode.horizontal : WritingMode.horizontalOnly, placedTextSymbolIndices, glyphPositionMap, sizes);\n\n        if (shapedTextOrientations.vertical) {\n            numVerticalGlyphVertices += addTextVertices(bucket, anchor, shapedTextOrientations.vertical, layer, textAlongLine, feature, textOffset, lineArray, WritingMode.vertical, placedTextSymbolIndices, glyphPositionMap, sizes);\n        }\n    }\n\n    const textBoxStartIndex = textCollisionFeature ? textCollisionFeature.boxStartIndex : bucket.collisionBoxArray.length;\n    const textBoxEndIndex = textCollisionFeature ? textCollisionFeature.boxEndIndex : bucket.collisionBoxArray.length;\n\n    if (shapedIcon) {\n        const iconQuads = getIconQuads(anchor, shapedIcon, layer,\n                            iconAlongLine, shapedTextOrientations.horizontal,\n                            feature);\n        const iconRotate = layer.layout.get('icon-rotate').evaluate(feature, {});\n        iconCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, shapedIcon, iconBoxScale, iconPadding, /*align boxes to line*/false, bucket.overscaling, iconRotate);\n\n        numIconVertices = iconQuads.length * 4;\n\n        const sizeData = bucket.iconSizeData;\n        let iconSizeData = null;\n\n        if (sizeData.functionType === 'source') {\n            iconSizeData = [\n                SIZE_PACK_FACTOR * layer.layout.get('icon-size').evaluate(feature, {})\n            ];\n            if (iconSizeData[0] > MAX_PACKED_SIZE) {\n                warnOnce(`${bucket.layerIds[0]}: Value for \"icon-size\" is >= 256. Reduce your \"icon-size\".`);\n            }\n        } else if (sizeData.functionType === 'composite') {\n            iconSizeData = [\n                SIZE_PACK_FACTOR * sizes.compositeIconSizes[0].evaluate(feature, {}),\n                SIZE_PACK_FACTOR * sizes.compositeIconSizes[1].evaluate(feature, {})\n            ];\n            if (iconSizeData[0] > MAX_PACKED_SIZE || iconSizeData[1] > MAX_PACKED_SIZE) {\n                warnOnce(`${bucket.layerIds[0]}: Value for \"icon-size\" is >= 256. Reduce your \"icon-size\".`);\n            }\n        }\n\n        bucket.addSymbols(\n            bucket.icon,\n            iconQuads,\n            iconSizeData,\n            iconOffset,\n            iconAlongLine,\n            feature,\n            false,\n            anchor,\n            lineArray.lineStartIndex,\n            lineArray.lineLength);\n    }\n\n    const iconBoxStartIndex = iconCollisionFeature ? iconCollisionFeature.boxStartIndex : bucket.collisionBoxArray.length;\n    const iconBoxEndIndex = iconCollisionFeature ? iconCollisionFeature.boxEndIndex : bucket.collisionBoxArray.length;\n\n    if (bucket.glyphOffsetArray.length >= SymbolBucket.MAX_GLYPHS) warnOnce(\n        \"Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907\"\n    );\n\n    bucket.symbolInstances.emplaceBack(\n        anchor.x,\n        anchor.y,\n        placedTextSymbolIndices.length > 0 ? placedTextSymbolIndices[0] : -1,\n        placedTextSymbolIndices.length > 1 ? placedTextSymbolIndices[1] : -1,\n        key,\n        textBoxStartIndex,\n        textBoxEndIndex,\n        iconBoxStartIndex,\n        iconBoxEndIndex,\n        featureIndex,\n        numGlyphVertices,\n        numVerticalGlyphVertices,\n        numIconVertices,\n        0);\n}\n\nfunction anchorIsTooClose(bucket: any, text: string, repeatDistance: number, anchor: Point) {\n    const compareText = bucket.compareText;\n    if (!(text in compareText)) {\n        compareText[text] = [];\n    } else {\n        const otherAnchors = compareText[text];\n        for (let k = otherAnchors.length - 1; k >= 0; k--) {\n            if (anchor.dist(otherAnchors[k]) < repeatDistance) {\n                // If it's within repeatDistance of one anchor, stop looking\n                return true;\n            }\n        }\n    }\n    // If anchor is not within repeatDistance of any other anchor, add to array\n    compareText[text].push(anchor);\n    return false;\n}\n","// @flow\n\nimport Point from '@mapbox/point-geometry';\n\nimport { GLYPH_PBF_BORDER } from '../style/parse_glyph_pbf';\n\nimport type Anchor from './anchor';\nimport type {PositionedIcon, Shaping} from './shaping';\nimport type SymbolStyleLayer from '../style/style_layer/symbol_style_layer';\nimport type {Feature} from '../style-spec/expression';\nimport type {GlyphPosition} from '../render/glyph_atlas';\n\n/**\n * A textured quad for rendering a single icon or glyph.\n *\n * The zoom range the glyph can be shown is defined by minScale and maxScale.\n *\n * @param tl The offset of the top left corner from the anchor.\n * @param tr The offset of the top right corner from the anchor.\n * @param bl The offset of the bottom left corner from the anchor.\n * @param br The offset of the bottom right corner from the anchor.\n * @param tex The texture coordinates.\n *\n * @private\n */\nexport type SymbolQuad = {\n    tl: Point,\n    tr: Point,\n    bl: Point,\n    br: Point,\n    tex: {\n        x: number,\n        y: number,\n        w: number,\n        h: number\n    },\n    writingMode: any | void,\n    glyphOffset: [number, number]\n};\n\n/**\n * Create the quads used for rendering an icon.\n * @private\n */\nexport function getIconQuads(anchor: Anchor,\n                      shapedIcon: PositionedIcon,\n                      layer: SymbolStyleLayer,\n                      alongLine: boolean,\n                      shapedText: Shaping,\n                      feature: Feature): Array<SymbolQuad> {\n    const image = shapedIcon.image;\n    const layout = layer.layout;\n\n    // If you have a 10px icon that isn't perfectly aligned to the pixel grid it will cover 11 actual\n    // pixels. The quad needs to be padded to account for this, otherwise they'll look slightly clipped\n    // on one edge in some cases.\n    const border = 1;\n\n    const top = shapedIcon.top - border / image.pixelRatio;\n    const left = shapedIcon.left - border / image.pixelRatio;\n    const bottom = shapedIcon.bottom + border / image.pixelRatio;\n    const right = shapedIcon.right + border / image.pixelRatio;\n    let tl, tr, br, bl;\n\n    // text-fit mode\n    if (layout.get('icon-text-fit') !== 'none' && shapedText) {\n        const iconWidth = (right - left),\n            iconHeight = (bottom - top),\n            size = layout.get('text-size').evaluate(feature, {}) / 24,\n            textLeft = shapedText.left * size,\n            textRight = shapedText.right * size,\n            textTop = shapedText.top * size,\n            textBottom = shapedText.bottom * size,\n            textWidth = textRight - textLeft,\n            textHeight = textBottom - textTop,\n            padT = layout.get('icon-text-fit-padding')[0],\n            padR = layout.get('icon-text-fit-padding')[1],\n            padB = layout.get('icon-text-fit-padding')[2],\n            padL = layout.get('icon-text-fit-padding')[3],\n            offsetY = layout.get('icon-text-fit') === 'width' ? (textHeight - iconHeight) * 0.5 : 0,\n            offsetX = layout.get('icon-text-fit') === 'height' ? (textWidth - iconWidth) * 0.5 : 0,\n            width = layout.get('icon-text-fit') === 'width' || layout.get('icon-text-fit') === 'both' ? textWidth : iconWidth,\n            height = layout.get('icon-text-fit') === 'height' || layout.get('icon-text-fit') === 'both' ? textHeight : iconHeight;\n        tl = new Point(textLeft + offsetX - padL,         textTop + offsetY - padT);\n        tr = new Point(textLeft + offsetX + padR + width, textTop + offsetY - padT);\n        br = new Point(textLeft + offsetX + padR + width, textTop + offsetY + padB + height);\n        bl = new Point(textLeft + offsetX - padL,         textTop + offsetY + padB + height);\n    // Normal icon size mode\n    } else {\n        tl = new Point(left, top);\n        tr = new Point(right, top);\n        br = new Point(right, bottom);\n        bl = new Point(left, bottom);\n    }\n\n    const angle = layer.layout.get('icon-rotate').evaluate(feature, {}) * Math.PI / 180;\n\n    if (angle) {\n        const sin = Math.sin(angle),\n            cos = Math.cos(angle),\n            matrix = [cos, -sin, sin, cos];\n\n        tl._matMult(matrix);\n        tr._matMult(matrix);\n        bl._matMult(matrix);\n        br._matMult(matrix);\n    }\n\n    // Icon quad is padded, so texture coordinates also need to be padded.\n    return [{tl, tr, bl, br, tex: image.paddedRect, writingMode: undefined, glyphOffset: [0, 0]}];\n}\n\n/**\n * Create the quads used for rendering a text label.\n * @private\n */\nexport function getGlyphQuads(anchor: Anchor,\n                       shaping: Shaping,\n                       layer: SymbolStyleLayer,\n                       alongLine: boolean,\n                       feature: Feature,\n                       positions: {[string]: {[number]: GlyphPosition}}): Array<SymbolQuad> {\n\n    const oneEm = 24;\n    const textRotate = layer.layout.get('text-rotate').evaluate(feature, {}) * Math.PI / 180;\n    const textOffset = layer.layout.get('text-offset').evaluate(feature, {}).map((t) => t * oneEm);\n\n    const positionedGlyphs = shaping.positionedGlyphs;\n    const quads = [];\n\n\n    for (let k = 0; k < positionedGlyphs.length; k++) {\n        const positionedGlyph = positionedGlyphs[k];\n        const glyphPositions = positions[positionedGlyph.fontStack];\n        const glyph = glyphPositions && glyphPositions[positionedGlyph.glyph];\n        if (!glyph) continue;\n\n        const rect = glyph.rect;\n        if (!rect) continue;\n\n        // The rects have an addditional buffer that is not included in their size.\n        const glyphPadding = 1.0;\n        const rectBuffer = GLYPH_PBF_BORDER + glyphPadding;\n\n        const halfAdvance = glyph.metrics.advance * positionedGlyph.scale / 2;\n\n        const glyphOffset = alongLine ?\n            [positionedGlyph.x + halfAdvance, positionedGlyph.y] :\n            [0, 0];\n\n        const builtInOffset = alongLine ?\n            [0, 0] :\n            [positionedGlyph.x + halfAdvance + textOffset[0], positionedGlyph.y + textOffset[1]];\n\n        const x1 = (glyph.metrics.left - rectBuffer) * positionedGlyph.scale - halfAdvance + builtInOffset[0];\n        const y1 = (-glyph.metrics.top - rectBuffer) * positionedGlyph.scale + builtInOffset[1];\n        const x2 = x1 + rect.w * positionedGlyph.scale;\n        const y2 = y1 + rect.h * positionedGlyph.scale;\n\n        const tl = new Point(x1, y1);\n        const tr = new Point(x2, y1);\n        const bl  = new Point(x1, y2);\n        const br = new Point(x2, y2);\n\n        if (alongLine && positionedGlyph.vertical) {\n            // Vertical-supporting glyphs are laid out in 24x24 point boxes (1 square em)\n            // In horizontal orientation, the y values for glyphs are below the midline\n            // and we use a \"yOffset\" of -17 to pull them up to the middle.\n            // By rotating counter-clockwise around the point at the center of the left\n            // edge of a 24x24 layout box centered below the midline, we align the center\n            // of the glyphs with the horizontal midline, so the yOffset is no longer\n            // necessary, but we also pull the glyph to the left along the x axis\n            const center = new Point(-halfAdvance, halfAdvance);\n            const verticalRotation = -Math.PI / 2;\n            const xOffsetCorrection = new Point(5, 0);\n            tl._rotateAround(verticalRotation, center)._add(xOffsetCorrection);\n            tr._rotateAround(verticalRotation, center)._add(xOffsetCorrection);\n            bl._rotateAround(verticalRotation, center)._add(xOffsetCorrection);\n            br._rotateAround(verticalRotation, center)._add(xOffsetCorrection);\n        }\n\n        if (textRotate) {\n            const sin = Math.sin(textRotate),\n                cos = Math.cos(textRotate),\n                matrix = [cos, -sin, sin, cos];\n\n            tl._matMult(matrix);\n            tr._matMult(matrix);\n            bl._matMult(matrix);\n            br._matMult(matrix);\n        }\n\n        quads.push({tl, tr, bl, br, tex: rect, writingMode: shaping.writingMode, glyphOffset});\n    }\n\n    return quads;\n}\n","// @flow\n\nimport Point from '@mapbox/point-geometry';\n\nexport default clipLine;\n\n/**\n * Returns the part of a multiline that intersects with the provided rectangular box.\n *\n * @param lines\n * @param x1 the left edge of the box\n * @param y1 the top edge of the box\n * @param x2 the right edge of the box\n * @param y2 the bottom edge of the box\n * @returns lines\n * @private\n */\nfunction clipLine(lines: Array<Array<Point>>, x1: number, y1: number, x2: number, y2: number): Array<Array<Point>> {\n    const clippedLines = [];\n\n    for (let l = 0; l < lines.length; l++) {\n        const line = lines[l];\n        let clippedLine;\n\n        for (let i = 0; i < line.length - 1; i++) {\n            let p0 = line[i];\n            let p1 = line[i + 1];\n\n\n            if (p0.x < x1 && p1.x < x1) {\n                continue;\n            } else if (p0.x < x1) {\n                p0 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();\n            } else if (p1.x < x1) {\n                p1 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();\n            }\n\n            if (p0.y < y1 && p1.y < y1) {\n                continue;\n            } else if (p0.y < y1) {\n                p0 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();\n            } else if (p1.y < y1) {\n                p1 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();\n            }\n\n            if (p0.x >= x2 && p1.x >= x2) {\n                continue;\n            } else if (p0.x >= x2) {\n                p0 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();\n            } else if (p1.x >= x2) {\n                p1 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();\n            }\n\n            if (p0.y >= y2 && p1.y >= y2) {\n                continue;\n            } else if (p0.y >= y2) {\n                p0 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();\n            } else if (p1.y >= y2) {\n                p1 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();\n            }\n\n            if (!clippedLine || !p0.equals(clippedLine[clippedLine.length - 1])) {\n                clippedLine = [p0];\n                clippedLines.push(clippedLine);\n            }\n\n            clippedLine.push(p1);\n        }\n    }\n\n    return clippedLines;\n}\n","// @flow\n\nimport { AlphaImage } from '../util/image';\nimport { register } from '../util/web_worker_transfer';\nimport potpack from 'potpack';\n\nimport type {GlyphMetrics, StyleGlyph} from '../style/style_glyph';\n\nconst padding = 1;\n\ntype Rect = {\n    x: number,\n    y: number,\n    w: number,\n    h: number\n};\n\nexport type GlyphPosition = {\n    rect: Rect,\n    metrics: GlyphMetrics\n};\n\nexport type GlyphPositions = { [string]: { [number]: GlyphPosition } }\n\nexport default class GlyphAtlas {\n    image: AlphaImage;\n    positions: GlyphPositions;\n\n    constructor(stacks: { [string]: { [number]: ?StyleGlyph } }) {\n        const positions = {};\n        const bins = [];\n\n        for (const stack in stacks) {\n            const glyphs = stacks[stack];\n            const stackPositions = positions[stack] = {};\n\n            for (const id in glyphs) {\n                const src = glyphs[+id];\n                if (!src || src.bitmap.width === 0 || src.bitmap.height === 0) continue;\n\n                const bin = {\n                    x: 0,\n                    y: 0,\n                    w: src.bitmap.width + 2 * padding,\n                    h: src.bitmap.height + 2 * padding\n                };\n                bins.push(bin);\n                stackPositions[id] = {rect: bin, metrics: src.metrics};\n            }\n        }\n\n        const {w, h} = potpack(bins);\n        const image = new AlphaImage({width: w || 1, height: h || 1});\n\n        for (const stack in stacks) {\n            const glyphs = stacks[stack];\n\n            for (const id in glyphs) {\n                const src = glyphs[+id];\n                if (!src || src.bitmap.width === 0 || src.bitmap.height === 0) continue;\n                const bin = positions[stack][id].rect;\n                AlphaImage.copy(src.bitmap, image, {x: 0, y: 0}, {x: bin.x + padding, y: bin.y + padding}, src.bitmap);\n            }\n        }\n\n        this.image = image;\n        this.positions = positions;\n    }\n}\n\nregister('GlyphAtlas', GlyphAtlas);\n","// @flow\n\nimport FeatureIndex from '../data/feature_index';\n\nimport { performSymbolLayout } from '../symbol/symbol_layout';\nimport { CollisionBoxArray } from '../data/array_types';\nimport DictionaryCoder from '../util/dictionary_coder';\nimport SymbolBucket from '../data/bucket/symbol_bucket';\nimport LineBucket from '../data/bucket/line_bucket';\nimport FillBucket from '../data/bucket/fill_bucket';\nimport FillExtrusionBucket from '../data/bucket/fill_extrusion_bucket';\nimport { warnOnce, mapObject, values } from '../util/util';\nimport assert from 'assert';\nimport ImageAtlas from '../render/image_atlas';\nimport GlyphAtlas from '../render/glyph_atlas';\nimport EvaluationParameters from '../style/evaluation_parameters';\nimport { OverscaledTileID } from './tile_id';\n\nimport type {Bucket} from '../data/bucket';\nimport type Actor from '../util/actor';\nimport type StyleLayer from '../style/style_layer';\nimport type StyleLayerIndex from '../style/style_layer_index';\nimport type {StyleImage} from '../style/style_image';\nimport type {StyleGlyph} from '../style/style_glyph';\nimport type {\n    WorkerTileParameters,\n    WorkerTileCallback,\n} from '../source/worker_source';\n\nclass WorkerTile {\n    tileID: OverscaledTileID;\n    uid: string;\n    zoom: number;\n    pixelRatio: number;\n    tileSize: number;\n    source: string;\n    overscaling: number;\n    showCollisionBoxes: boolean;\n    collectResourceTiming: boolean;\n    returnDependencies: boolean;\n\n    status: 'parsing' | 'done';\n    data: VectorTile;\n    collisionBoxArray: CollisionBoxArray;\n\n    abort: ?() => void;\n    reloadCallback: WorkerTileCallback;\n    vectorTile: VectorTile;\n\n    constructor(params: WorkerTileParameters) {\n        this.tileID = new OverscaledTileID(params.tileID.overscaledZ, params.tileID.wrap, params.tileID.canonical.z, params.tileID.canonical.x, params.tileID.canonical.y);\n        this.uid = params.uid;\n        this.zoom = params.zoom;\n        this.pixelRatio = params.pixelRatio;\n        this.tileSize = params.tileSize;\n        this.source = params.source;\n        this.overscaling = this.tileID.overscaleFactor();\n        this.showCollisionBoxes = params.showCollisionBoxes;\n        this.collectResourceTiming = !!params.collectResourceTiming;\n        this.returnDependencies = !!params.returnDependencies;\n    }\n\n    parse(data: VectorTile, layerIndex: StyleLayerIndex, actor: Actor, callback: WorkerTileCallback) {\n        this.status = 'parsing';\n        this.data = data;\n\n        this.collisionBoxArray = new CollisionBoxArray();\n        const sourceLayerCoder = new DictionaryCoder(Object.keys(data.layers).sort());\n\n        const featureIndex = new FeatureIndex(this.tileID);\n        featureIndex.bucketLayerIDs = [];\n\n        const buckets: {[string]: Bucket} = {};\n\n        const options = {\n            featureIndex,\n            iconDependencies: {},\n            patternDependencies: {},\n            glyphDependencies: {}\n        };\n\n        const layerFamilies = layerIndex.familiesBySource[this.source];\n        for (const sourceLayerId in layerFamilies) {\n            const sourceLayer = data.layers[sourceLayerId];\n            if (!sourceLayer) {\n                continue;\n            }\n\n            if (sourceLayer.version === 1) {\n                warnOnce(`Vector tile source \"${this.source}\" layer \"${sourceLayerId}\" ` +\n                    `does not use vector tile spec v2 and therefore may have some rendering errors.`);\n            }\n\n            const sourceLayerIndex = sourceLayerCoder.encode(sourceLayerId);\n            const features = [];\n            for (let index = 0; index < sourceLayer.length; index++) {\n                const feature = sourceLayer.feature(index);\n                features.push({ feature, index, sourceLayerIndex });\n            }\n\n            for (const family of layerFamilies[sourceLayerId]) {\n                const layer = family[0];\n\n                assert(layer.source === this.source);\n                if (layer.minzoom && this.zoom < Math.floor(layer.minzoom)) continue;\n                if (layer.maxzoom && this.zoom >= layer.maxzoom) continue;\n                if (layer.visibility === 'none') continue;\n\n                recalculateLayers(family, this.zoom);\n\n                const bucket = buckets[layer.id] = layer.createBucket({\n                    index: featureIndex.bucketLayerIDs.length,\n                    layers: family,\n                    zoom: this.zoom,\n                    pixelRatio: this.pixelRatio,\n                    overscaling: this.overscaling,\n                    collisionBoxArray: this.collisionBoxArray,\n                    sourceLayerIndex,\n                    sourceID: this.source\n                });\n\n                bucket.populate(features, options);\n                featureIndex.bucketLayerIDs.push(family.map((l) => l.id));\n            }\n        }\n\n        let error: ?Error;\n        let glyphMap: ?{[string]: {[number]: ?StyleGlyph}};\n        let iconMap: ?{[string]: StyleImage};\n        let patternMap: ?{[string]: StyleImage};\n\n        const stacks = mapObject(options.glyphDependencies, (glyphs) => Object.keys(glyphs).map(Number));\n        if (Object.keys(stacks).length) {\n            actor.send('getGlyphs', {uid: this.uid, stacks}, (err, result) => {\n                if (!error) {\n                    error = err;\n                    glyphMap = result;\n                    maybePrepare.call(this);\n                }\n            });\n        } else {\n            glyphMap = {};\n        }\n\n        const icons = Object.keys(options.iconDependencies);\n        if (icons.length) {\n            actor.send('getImages', {icons}, (err, result) => {\n                if (!error) {\n                    error = err;\n                    iconMap = result;\n                    maybePrepare.call(this);\n                }\n            });\n        } else {\n            iconMap = {};\n        }\n\n        const patterns = Object.keys(options.patternDependencies);\n        if (patterns.length) {\n            actor.send('getImages', {icons: patterns}, (err, result) => {\n                if (!error) {\n                    error = err;\n                    patternMap = result;\n                    maybePrepare.call(this);\n                }\n            });\n        } else {\n            patternMap = {};\n        }\n\n\n        maybePrepare.call(this);\n\n        function maybePrepare() {\n            if (error) {\n                return callback(error);\n            } else if (glyphMap && iconMap && patternMap) {\n                const glyphAtlas = new GlyphAtlas(glyphMap);\n                const imageAtlas = new ImageAtlas(iconMap, patternMap);\n\n                for (const key in buckets) {\n                    const bucket = buckets[key];\n\n                    // The original code was:\n                    //\n                    //    bucket instance of SymbolBucket\n                    //\n                    // However, this wrongly returned false in some cases.\n                    // The following check turns out to be reliable.\n                    if (bucket.hasOwnProperty('collisionBoxArray')) {\n                        recalculateLayers(bucket.layers, this.zoom);\n                        performSymbolLayout(bucket, glyphMap, glyphAtlas.positions, iconMap, imageAtlas.iconPositions, this.showCollisionBoxes);\n                    } else if (bucket.hasPattern &&\n                        (bucket instanceof LineBucket ||\n                         bucket instanceof FillBucket ||\n                         bucket instanceof FillExtrusionBucket)) {\n                        recalculateLayers(bucket.layers, this.zoom);\n                        bucket.addFeatures(options, imageAtlas.patternPositions);\n                    }\n                }\n\n                this.status = 'done';\n                callback(null, {\n                    buckets: values(buckets).filter(b => !b.isEmpty()),\n                    featureIndex,\n                    collisionBoxArray: this.collisionBoxArray,\n                    glyphAtlasImage: glyphAtlas.image,\n                    imageAtlas,\n                    // Only used for benchmarking:\n                    glyphMap: this.returnDependencies ? glyphMap : null,\n                    iconMap: this.returnDependencies ? iconMap : null,\n                    glyphPositions: this.returnDependencies ? glyphAtlas.positions : null\n                });\n            }\n        }\n    }\n}\n\nfunction recalculateLayers(layers: $ReadOnlyArray<StyleLayer>, zoom: number) {\n    // Layers are shared and may have been used by a WorkerTile with a different zoom.\n    const parameters = new EvaluationParameters(zoom);\n    for (const layer of layers) {\n        layer.recalculate(parameters);\n    }\n}\n\nexport default WorkerTile;\n","// @flow\n\nimport type {RequestParameters} from '../util/ajax';\n\n// Wraps performance to facilitate testing\n// Not incorporated into browser.js because the latter is poisonous when used outside the main thread\nconst performanceExists = typeof performance !== 'undefined';\nconst wrapper = {};\n\nwrapper.getEntriesByName = (url: string) => {\n    if (performanceExists && performance && performance.getEntriesByName)\n        return performance.getEntriesByName(url);\n    else\n        return false;\n};\n\nwrapper.mark = (name: string) => {\n    if (performanceExists && performance && performance.mark)\n        return performance.mark(name);\n    else\n        return false;\n};\n\nwrapper.measure = (name: string, startMark: string, endMark: string) => {\n    if (performanceExists && performance && performance.measure)\n        return performance.measure(name, startMark, endMark);\n    else\n        return false;\n};\n\nwrapper.clearMarks = (name: string) => {\n    if (performanceExists && performance && performance.clearMarks)\n        return performance.clearMarks(name);\n    else\n        return false;\n};\n\nwrapper.clearMeasures = (name: string) => {\n    if (performanceExists && performance && performance.clearMeasures)\n        return performance.clearMeasures(name);\n    else\n        return false;\n};\n\n/**\n * Safe wrapper for the performance resource timing API in web workers with graceful degradation\n *\n * @param {RequestParameters} request\n * @private\n */\nclass Performance {\n    _marks: {start: string, end: string, measure: string};\n\n    constructor (request: RequestParameters) {\n        this._marks = {\n            start: [request.url, 'start'].join('#'),\n            end: [request.url, 'end'].join('#'),\n            measure: request.url.toString()\n        };\n\n        wrapper.mark(this._marks.start);\n    }\n\n    finish() {\n        wrapper.mark(this._marks.end);\n        let resourceTimingData = wrapper.getEntriesByName(this._marks.measure);\n\n        // fallback if web worker implementation of perf.getEntriesByName returns empty\n        if (resourceTimingData.length === 0) {\n            wrapper.measure(this._marks.measure, this._marks.start, this._marks.end);\n            resourceTimingData = wrapper.getEntriesByName(this._marks.measure);\n\n            // cleanup\n            wrapper.clearMarks(this._marks.start);\n            wrapper.clearMarks(this._marks.end);\n            wrapper.clearMeasures(this._marks.measure);\n        }\n\n        return resourceTimingData;\n    }\n}\n\nwrapper.Performance = Performance;\n\nexport default wrapper;\n","// @flow\n\nimport { getArrayBuffer } from '../util/ajax';\n\nimport vt from '@mapbox/vector-tile';\nimport Protobuf from 'pbf';\nimport WorkerTile from './worker_tile';\nimport { extend } from '../util/util';\nimport performance from '../util/performance';\n\nimport type {\n    WorkerSource,\n    WorkerTileParameters,\n    WorkerTileCallback,\n    TileParameters\n} from '../source/worker_source';\n\nimport type {PerformanceResourceTiming} from '../types/performance_resource_timing';\nimport type Actor from '../util/actor';\nimport type StyleLayerIndex from '../style/style_layer_index';\nimport type {Callback} from '../types/callback';\n\nexport type LoadVectorTileResult = {\n    vectorTile: VectorTile;\n    rawData: ArrayBuffer;\n    expires?: any;\n    cacheControl?: any;\n    resourceTiming?: Array<PerformanceResourceTiming>;\n};\n\n/**\n * @callback LoadVectorDataCallback\n * @param error\n * @param vectorTile\n * @private\n */\nexport type LoadVectorDataCallback = Callback<?LoadVectorTileResult>;\n\nexport type AbortVectorData = () => void;\nexport type LoadVectorData = (params: WorkerTileParameters, callback: LoadVectorDataCallback) => ?AbortVectorData;\n\n/**\n * @private\n */\nfunction loadVectorTile(params: WorkerTileParameters, callback: LoadVectorDataCallback) {\n    const request = getArrayBuffer(params.request, (err: ?Error, data: ?ArrayBuffer, cacheControl: ?string, expires: ?string) => {\n        if (err) {\n            callback(err);\n        } else if (data) {\n            callback(null, {\n                vectorTile: new vt.VectorTile(new Protobuf(data)),\n                rawData: data,\n                cacheControl,\n                expires\n            });\n        }\n    });\n    return () => {\n        request.cancel();\n        callback();\n    };\n}\n\n/**\n * The {@link WorkerSource} implementation that supports {@link VectorTileSource}.\n * This class is designed to be easily reused to support custom source types\n * for data formats that can be parsed/converted into an in-memory VectorTile\n * representation.  To do so, create it with\n * `new VectorTileWorkerSource(actor, styleLayers, customLoadVectorDataFunction)`.\n *\n * @private\n */\nclass VectorTileWorkerSource implements WorkerSource {\n    actor: Actor;\n    layerIndex: StyleLayerIndex;\n    loadVectorData: LoadVectorData;\n    loading: { [string]: WorkerTile };\n    loaded: { [string]: WorkerTile };\n\n    /**\n     * @param [loadVectorData] Optional method for custom loading of a VectorTile\n     * object based on parameters passed from the main-thread Source. See\n     * {@link VectorTileWorkerSource#loadTile}. The default implementation simply\n     * loads the pbf at `params.url`.\n     */\n    constructor(actor: Actor, layerIndex: StyleLayerIndex, loadVectorData: ?LoadVectorData) {\n        this.actor = actor;\n        this.layerIndex = layerIndex;\n        this.loadVectorData = loadVectorData || loadVectorTile;\n        this.loading = {};\n        this.loaded = {};\n    }\n\n    /**\n     * Implements {@link WorkerSource#loadTile}. Delegates to\n     * {@link VectorTileWorkerSource#loadVectorData} (which by default expects\n     * a `params.url` property) for fetching and producing a VectorTile object.\n     */\n    loadTile(params: WorkerTileParameters, callback: WorkerTileCallback) {\n        const uid = params.uid;\n\n        if (!this.loading)\n            this.loading = {};\n\n        const perf = (params && params.request && params.request.collectResourceTiming) ?\n            new performance.Performance(params.request) : false;\n\n        const workerTile = this.loading[uid] = new WorkerTile(params);\n        workerTile.abort = this.loadVectorData(params, (err, response) => {\n            delete this.loading[uid];\n\n            if (err || !response) {\n                workerTile.status = 'done';\n                this.loaded[uid] = workerTile;\n                return callback(err);\n            }\n\n            const rawTileData = response.rawData;\n            const cacheControl = {};\n            if (response.expires) cacheControl.expires = response.expires;\n            if (response.cacheControl) cacheControl.cacheControl = response.cacheControl;\n\n            const resourceTiming = {};\n            if (perf) {\n                const resourceTimingData = perf.finish();\n                // it's necessary to eval the result of getEntriesByName() here via parse/stringify\n                // late evaluation in the main thread causes TypeError: illegal invocation\n                if (resourceTimingData)\n                    resourceTiming.resourceTiming = JSON.parse(JSON.stringify(resourceTimingData));\n            }\n\n            workerTile.vectorTile = response.vectorTile;\n            workerTile.parse(response.vectorTile, this.layerIndex, this.actor, (err, result) => {\n                if (err || !result) return callback(err);\n\n                // Transferring a copy of rawTileData because the worker needs to retain its copy.\n                callback(null, extend({rawTileData: rawTileData.slice(0)}, result, cacheControl, resourceTiming));\n            });\n\n            this.loaded = this.loaded || {};\n            this.loaded[uid] = workerTile;\n        });\n    }\n\n    /**\n     * Implements {@link WorkerSource#reloadTile}.\n     */\n    reloadTile(params: WorkerTileParameters, callback: WorkerTileCallback) {\n        const loaded = this.loaded,\n            uid = params.uid,\n            vtSource = this;\n        if (loaded && loaded[uid]) {\n            const workerTile = loaded[uid];\n            workerTile.showCollisionBoxes = params.showCollisionBoxes;\n\n            const done = (err, data) => {\n                const reloadCallback = workerTile.reloadCallback;\n                if (reloadCallback) {\n                    delete workerTile.reloadCallback;\n                    workerTile.parse(workerTile.vectorTile, vtSource.layerIndex, vtSource.actor, reloadCallback);\n                }\n                callback(err, data);\n            };\n\n            if (workerTile.status === 'parsing') {\n                workerTile.reloadCallback = done;\n            } else if (workerTile.status === 'done') {\n                // if there was no vector tile data on the initial load, don't try and re-parse tile\n                if (workerTile.vectorTile) {\n                    workerTile.parse(workerTile.vectorTile, this.layerIndex, this.actor, done);\n                } else {\n                    done();\n                }\n            }\n        }\n    }\n\n    /**\n     * Implements {@link WorkerSource#abortTile}.\n     *\n     * @param params\n     * @param params.uid The UID for this tile.\n     */\n    abortTile(params: TileParameters, callback: WorkerTileCallback) {\n        const loading = this.loading,\n            uid = params.uid;\n        if (loading && loading[uid] && loading[uid].abort) {\n            loading[uid].abort();\n            delete loading[uid];\n        }\n        callback();\n    }\n\n    /**\n     * Implements {@link WorkerSource#removeTile}.\n     *\n     * @param params\n     * @param params.uid The UID for this tile.\n     */\n    removeTile(params: TileParameters, callback: WorkerTileCallback) {\n        const loaded = this.loaded,\n            uid = params.uid;\n        if (loaded && loaded[uid]) {\n            delete loaded[uid];\n        }\n        callback();\n    }\n}\n\nexport default VectorTileWorkerSource;\n","// @flow\n\nimport DEMData from '../data/dem_data';\n\nimport type Actor from '../util/actor';\nimport type {\n    WorkerDEMTileParameters,\n    WorkerDEMTileCallback,\n    TileParameters\n} from './worker_source';\n\n\nclass RasterDEMTileWorkerSource {\n    actor: Actor;\n    loaded: {[string]: DEMData};\n\n    constructor() {\n        this.loaded = {};\n    }\n\n    loadTile(params: WorkerDEMTileParameters, callback: WorkerDEMTileCallback) {\n        const {uid, encoding, rawImageData} = params;\n        const dem = new DEMData(uid, rawImageData, encoding);\n\n        this.loaded = this.loaded || {};\n        this.loaded[uid] = dem;\n        callback(null, dem);\n    }\n\n    removeTile(params: TileParameters) {\n        const loaded = this.loaded,\n            uid = params.uid;\n        if (loaded && loaded[uid]) {\n            delete loaded[uid];\n        }\n    }\n}\n\nexport default RasterDEMTileWorkerSource;\n","module.exports.RADIUS = 6378137;\nmodule.exports.FLATTENING = 1/298.257223563;\nmodule.exports.POLAR_RADIUS = 6356752.3142;\n","var wgs84 = require('wgs84');\n\nmodule.exports.geometry = geometry;\nmodule.exports.ring = ringArea;\n\nfunction geometry(_) {\n    var area = 0, i;\n    switch (_.type) {\n        case 'Polygon':\n            return polygonArea(_.coordinates);\n        case 'MultiPolygon':\n            for (i = 0; i < _.coordinates.length; i++) {\n                area += polygonArea(_.coordinates[i]);\n            }\n            return area;\n        case 'Point':\n        case 'MultiPoint':\n        case 'LineString':\n        case 'MultiLineString':\n            return 0;\n        case 'GeometryCollection':\n            for (i = 0; i < _.geometries.length; i++) {\n                area += geometry(_.geometries[i]);\n            }\n            return area;\n    }\n}\n\nfunction polygonArea(coords) {\n    var area = 0;\n    if (coords && coords.length > 0) {\n        area += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            area -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return area;\n}\n\n/**\n * Calculate the approximate area of the polygon were it projected onto\n *     the earth.  Note that this area will be positive if ring is oriented\n *     clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n *     Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * Returns:\n * {float} The approximate signed geodesic area of the polygon in square\n *     meters.\n */\n\nfunction ringArea(coords) {\n    var p1, p2, p3, lowerIndex, middleIndex, upperIndex, i,\n    area = 0,\n    coordsLength = coords.length;\n\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {// i = N-2\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength -1;\n                upperIndex = 0;\n            } else if (i === coordsLength - 1) {// i = N-1\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            } else { // i = 0 to N-3\n                lowerIndex = i;\n                middleIndex = i+1;\n                upperIndex = i+2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            area += ( rad(p3[0]) - rad(p1[0]) ) * Math.sin( rad(p2[1]));\n        }\n\n        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;\n    }\n\n    return area;\n}\n\nfunction rad(_) {\n    return _ * Math.PI / 180;\n}","var geojsonArea = require('@mapbox/geojson-area');\n\nmodule.exports = rewind;\n\nfunction rewind(gj, outer) {\n    switch ((gj && gj.type) || null) {\n        case 'FeatureCollection':\n            gj.features = gj.features.map(curryOuter(rewind, outer));\n            return gj;\n        case 'GeometryCollection':\n            gj.geometries = gj.geometries.map(curryOuter(rewind, outer));\n            return gj;\n        case 'Feature':\n            gj.geometry = rewind(gj.geometry, outer);\n            return gj;\n        case 'Polygon':\n        case 'MultiPolygon':\n            return correct(gj, outer);\n        default:\n            return gj;\n    }\n}\n\nfunction curryOuter(a, b) {\n    return function(_) { return a(_, b); };\n}\n\nfunction correct(_, outer) {\n    if (_.type === 'Polygon') {\n        _.coordinates = correctRings(_.coordinates, outer);\n    } else if (_.type === 'MultiPolygon') {\n        _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));\n    }\n    return _;\n}\n\nfunction correctRings(_, outer) {\n    outer = !!outer;\n    _[0] = wind(_[0], outer);\n    for (var i = 1; i < _.length; i++) {\n        _[i] = wind(_[i], !outer);\n    }\n    return _;\n}\n\nfunction wind(_, dir) {\n    return cw(_) === dir ? _ : _.reverse();\n}\n\nfunction cw(_) {\n    return geojsonArea.ring(_) >= 0;\n}\n","// @flow\n\nimport Point from '@mapbox/point-geometry';\n\nimport mvt from '@mapbox/vector-tile';\nconst toGeoJSON = mvt.VectorTileFeature.prototype.toGeoJSON;\nimport EXTENT from '../data/extent';\n\n// The feature type used by geojson-vt and supercluster. Should be extracted to\n// global type and used in module definitions for those two modules.\ntype Feature = {\n    type: 1,\n    id: mixed,\n    tags: {[string]: string | number | boolean},\n    geometry: Array<[number, number]>,\n} | {\n    type: 2 | 3,\n    id: mixed,\n    tags: {[string]: string | number | boolean},\n    geometry: Array<Array<[number, number]>>,\n}\n\nclass FeatureWrapper implements VectorTileFeature {\n    _feature: Feature;\n\n    extent: number;\n    type: 1 | 2 | 3;\n    id: number;\n    properties: {[string]: string | number | boolean};\n\n    constructor(feature: Feature) {\n        this._feature = feature;\n\n        this.extent = EXTENT;\n        this.type = feature.type;\n        this.properties = feature.tags;\n\n        // If the feature has a top-level `id` property, copy it over, but only\n        // if it can be coerced to an integer, because this wrapper is used for\n        // serializing geojson feature data into vector tile PBF data, and the\n        // vector tile spec only supports integer values for feature ids --\n        // allowing non-integer values here results in a non-compliant PBF\n        // that causes an exception when it is parsed with vector-tile-js\n        if ('id' in feature && !isNaN(feature.id)) {\n            this.id = parseInt(feature.id, 10);\n        }\n    }\n\n    loadGeometry() {\n        if (this._feature.type === 1) {\n            const geometry = [];\n            for (const point of this._feature.geometry) {\n                geometry.push([new Point(point[0], point[1])]);\n            }\n            return geometry;\n        } else {\n            const geometry = [];\n            for (const ring of this._feature.geometry) {\n                const newRing = [];\n                for (const point of ring) {\n                    newRing.push(new Point(point[0], point[1]));\n                }\n                geometry.push(newRing);\n            }\n            return geometry;\n        }\n    }\n\n    toGeoJSON(x: number, y: number, z: number) {\n        return toGeoJSON.call(this, x, y, z);\n    }\n}\n\nclass GeoJSONWrapper implements VectorTile, VectorTileLayer {\n    layers: {[string]: VectorTileLayer};\n    name: string;\n    extent: number;\n    length: number;\n    _features: Array<Feature>;\n\n    constructor(features: Array<Feature>) {\n        this.layers = { '_geojsonTileLayer': this };\n        this.name = '_geojsonTileLayer';\n        this.extent = EXTENT;\n        this.length = features.length;\n        this._features = features;\n    }\n\n    feature(i: number): VectorTileFeature {\n        return new FeatureWrapper(this._features[i]);\n    }\n}\n\nexport default GeoJSONWrapper;\n","'use strict'\n\nvar Point = require('@mapbox/point-geometry')\nvar VectorTileFeature = require('@mapbox/vector-tile').VectorTileFeature\n\nmodule.exports = GeoJSONWrapper\n\n// conform to vectortile api\nfunction GeoJSONWrapper (features, options) {\n  this.options = options || {}\n  this.features = features\n  this.length = features.length\n}\n\nGeoJSONWrapper.prototype.feature = function (i) {\n  return new FeatureWrapper(this.features[i], this.options.extent)\n}\n\nfunction FeatureWrapper (feature, extent) {\n  this.id = typeof feature.id === 'number' ? feature.id : undefined\n  this.type = feature.type\n  this.rawGeometry = feature.type === 1 ? [feature.geometry] : feature.geometry\n  this.properties = feature.tags\n  this.extent = extent || 4096\n}\n\nFeatureWrapper.prototype.loadGeometry = function () {\n  var rings = this.rawGeometry\n  this.geometry = []\n\n  for (var i = 0; i < rings.length; i++) {\n    var ring = rings[i]\n    var newRing = []\n    for (var j = 0; j < ring.length; j++) {\n      newRing.push(new Point(ring[j][0], ring[j][1]))\n    }\n    this.geometry.push(newRing)\n  }\n  return this.geometry\n}\n\nFeatureWrapper.prototype.bbox = function () {\n  if (!this.geometry) this.loadGeometry()\n\n  var rings = this.geometry\n  var x1 = Infinity\n  var x2 = -Infinity\n  var y1 = Infinity\n  var y2 = -Infinity\n\n  for (var i = 0; i < rings.length; i++) {\n    var ring = rings[i]\n\n    for (var j = 0; j < ring.length; j++) {\n      var coord = ring[j]\n\n      x1 = Math.min(x1, coord.x)\n      x2 = Math.max(x2, coord.x)\n      y1 = Math.min(y1, coord.y)\n      y2 = Math.max(y2, coord.y)\n    }\n  }\n\n  return [x1, y1, x2, y2]\n}\n\nFeatureWrapper.prototype.toGeoJSON = VectorTileFeature.prototype.toGeoJSON\n","var Pbf = require('pbf')\nvar GeoJSONWrapper = require('./lib/geojson_wrapper')\n\nmodule.exports = fromVectorTileJs\nmodule.exports.fromVectorTileJs = fromVectorTileJs\nmodule.exports.fromGeojsonVt = fromGeojsonVt\nmodule.exports.GeoJSONWrapper = GeoJSONWrapper\n\n/**\n * Serialize a vector-tile-js-created tile to pbf\n *\n * @param {Object} tile\n * @return {Buffer} uncompressed, pbf-serialized tile data\n */\nfunction fromVectorTileJs (tile) {\n  var out = new Pbf()\n  writeTile(tile, out)\n  return out.finish()\n}\n\n/**\n * Serialized a geojson-vt-created tile to pbf.\n *\n * @param {Object} layers - An object mapping layer names to geojson-vt-created vector tile objects\n * @param {Object} [options] - An object specifying the vector-tile specification version and extent that were used to create `layers`.\n * @param {Number} [options.version=1] - Version of vector-tile spec used\n * @param {Number} [options.extent=4096] - Extent of the vector tile\n * @return {Buffer} uncompressed, pbf-serialized tile data\n */\nfunction fromGeojsonVt (layers, options) {\n  options = options || {}\n  var l = {}\n  for (var k in layers) {\n    l[k] = new GeoJSONWrapper(layers[k].features, options)\n    l[k].name = k\n    l[k].version = options.version\n    l[k].extent = options.extent\n  }\n  return fromVectorTileJs({layers: l})\n}\n\nfunction writeTile (tile, pbf) {\n  for (var key in tile.layers) {\n    pbf.writeMessage(3, writeLayer, tile.layers[key])\n  }\n}\n\nfunction writeLayer (layer, pbf) {\n  pbf.writeVarintField(15, layer.version || 1)\n  pbf.writeStringField(1, layer.name || '')\n  pbf.writeVarintField(5, layer.extent || 4096)\n\n  var i\n  var context = {\n    keys: [],\n    values: [],\n    keycache: {},\n    valuecache: {}\n  }\n\n  for (i = 0; i < layer.length; i++) {\n    context.feature = layer.feature(i)\n    pbf.writeMessage(2, writeFeature, context)\n  }\n\n  var keys = context.keys\n  for (i = 0; i < keys.length; i++) {\n    pbf.writeStringField(3, keys[i])\n  }\n\n  var values = context.values\n  for (i = 0; i < values.length; i++) {\n    pbf.writeMessage(4, writeValue, values[i])\n  }\n}\n\nfunction writeFeature (context, pbf) {\n  var feature = context.feature\n\n  if (feature.id !== undefined) {\n    pbf.writeVarintField(1, feature.id)\n  }\n\n  pbf.writeMessage(2, writeProperties, context)\n  pbf.writeVarintField(3, feature.type)\n  pbf.writeMessage(4, writeGeometry, feature)\n}\n\nfunction writeProperties (context, pbf) {\n  var feature = context.feature\n  var keys = context.keys\n  var values = context.values\n  var keycache = context.keycache\n  var valuecache = context.valuecache\n\n  for (var key in feature.properties) {\n    var keyIndex = keycache[key]\n    if (typeof keyIndex === 'undefined') {\n      keys.push(key)\n      keyIndex = keys.length - 1\n      keycache[key] = keyIndex\n    }\n    pbf.writeVarint(keyIndex)\n\n    var value = feature.properties[key]\n    var type = typeof value\n    if (type !== 'string' && type !== 'boolean' && type !== 'number') {\n      value = JSON.stringify(value)\n    }\n    var valueKey = type + ':' + value\n    var valueIndex = valuecache[valueKey]\n    if (typeof valueIndex === 'undefined') {\n      values.push(value)\n      valueIndex = values.length - 1\n      valuecache[valueKey] = valueIndex\n    }\n    pbf.writeVarint(valueIndex)\n  }\n}\n\nfunction command (cmd, length) {\n  return (length << 3) + (cmd & 0x7)\n}\n\nfunction zigzag (num) {\n  return (num << 1) ^ (num >> 31)\n}\n\nfunction writeGeometry (feature, pbf) {\n  var geometry = feature.loadGeometry()\n  var type = feature.type\n  var x = 0\n  var y = 0\n  var rings = geometry.length\n  for (var r = 0; r < rings; r++) {\n    var ring = geometry[r]\n    var count = 1\n    if (type === 1) {\n      count = ring.length\n    }\n    pbf.writeVarint(command(1, count)) // moveto\n    // do not write polygon closing path as lineto\n    var lineCount = type === 3 ? ring.length - 1 : ring.length\n    for (var i = 0; i < lineCount; i++) {\n      if (i === 1 && type !== 1) {\n        pbf.writeVarint(command(2, lineCount - 1)) // lineto\n      }\n      var dx = ring[i].x - x\n      var dy = ring[i].y - y\n      pbf.writeVarint(zigzag(dx))\n      pbf.writeVarint(zigzag(dy))\n      x += dx\n      y += dy\n    }\n    if (type === 3) {\n      pbf.writeVarint(command(7, 1)) // closepath\n    }\n  }\n}\n\nfunction writeValue (value, pbf) {\n  var type = typeof value\n  if (type === 'string') {\n    pbf.writeStringField(1, value)\n  } else if (type === 'boolean') {\n    pbf.writeBooleanField(7, value)\n  } else if (type === 'number') {\n    if (value % 1 !== 0) {\n      pbf.writeDoubleField(3, value)\n    } else if (value < 0) {\n      pbf.writeSVarintField(6, value)\n    } else {\n      pbf.writeVarintField(5, value)\n    }\n  }\n}\n","// @flow\n\nimport Texture from './texture';\nimport Color from '../style-spec/util/color';\nimport DepthMode from '../gl/depth_mode';\nimport StencilMode from '../gl/stencil_mode';\nimport ColorMode from '../gl/color_mode';\nimport CullFaceMode from '../gl/cull_face_mode';\nimport {\n    heatmapUniformValues,\n    heatmapTextureUniformValues\n} from './program/heatmap_program';\n\nimport type Painter from './painter';\nimport type SourceCache from '../source/source_cache';\nimport type HeatmapStyleLayer from '../style/style_layer/heatmap_style_layer';\nimport type HeatmapBucket from '../data/bucket/heatmap_bucket';\nimport type {OverscaledTileID} from '../source/tile_id';\n\nexport default drawHeatmap;\n\nfunction drawHeatmap(painter: Painter, sourceCache: SourceCache, layer: HeatmapStyleLayer, coords: Array<OverscaledTileID>) {\n    if (layer.paint.get('heatmap-opacity') === 0) {\n        return;\n    }\n\n    if (painter.renderPass === 'offscreen') {\n        const context = painter.context;\n        const gl = context.gl;\n\n        const depthMode = painter.depthModeForSublayer(0, DepthMode.ReadOnly);\n        // Allow kernels to be drawn across boundaries, so that\n        // large kernels are not clipped to tiles\n        const stencilMode = StencilMode.disabled;\n        // Turn on additive blending for kernels, which is a key aspect of kernel density estimation formula\n        const colorMode = new ColorMode([gl.ONE, gl.ONE], Color.transparent, [true, true, true, true]);\n\n        bindFramebuffer(context, painter, layer);\n\n        context.clear({ color: Color.transparent });\n\n        for (let i = 0; i < coords.length; i++) {\n            const coord = coords[i];\n\n            // Skip tiles that have uncovered parents to avoid flickering; we don't need\n            // to use complex tile masking here because the change between zoom levels is subtle,\n            // so it's fine to simply render the parent until all its 4 children are loaded\n            if (sourceCache.hasRenderableParent(coord)) continue;\n\n            const tile = sourceCache.getTile(coord);\n            const bucket: ?HeatmapBucket = (tile.getBucket(layer): any);\n            if (!bucket) continue;\n\n            const programConfiguration = bucket.programConfigurations.get(layer.id);\n            const program = painter.useProgram('heatmap', programConfiguration);\n            const {zoom} = painter.transform;\n\n            program.draw(context, gl.TRIANGLES, depthMode, stencilMode, colorMode, CullFaceMode.disabled,\n                heatmapUniformValues(coord.posMatrix,\n                    tile, zoom, layer.paint.get('heatmap-intensity')),\n                layer.id, bucket.layoutVertexBuffer, bucket.indexBuffer,\n                bucket.segments, layer.paint, painter.transform.zoom,\n                programConfiguration);\n        }\n\n        context.viewport.set([0, 0, painter.width, painter.height]);\n\n    } else if (painter.renderPass === 'translucent') {\n        painter.context.setColorMode(painter.colorModeForRenderPass());\n        renderTextureToMap(painter, layer);\n    }\n}\n\nfunction bindFramebuffer(context, painter, layer) {\n    const gl = context.gl;\n    context.activeTexture.set(gl.TEXTURE1);\n\n    // Use a 4x downscaled screen texture for better performance\n    context.viewport.set([0, 0, painter.width / 4, painter.height / 4]);\n\n    let fbo = layer.heatmapFbo;\n\n    if (!fbo) {\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\n        fbo = layer.heatmapFbo = context.createFramebuffer(painter.width / 4, painter.height / 4);\n\n        bindTextureToFramebuffer(context, painter, texture, fbo);\n\n    } else {\n        gl.bindTexture(gl.TEXTURE_2D, fbo.colorAttachment.get());\n        context.bindFramebuffer.set(fbo.framebuffer);\n    }\n}\n\nfunction bindTextureToFramebuffer(context, painter, texture, fbo) {\n    const gl = context.gl;\n    // Use the higher precision half-float texture where available (producing much smoother looking heatmaps);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, painter.width / 4, painter.height / 4, 0, gl.RGBA,\n        context.extTextureHalfFloat ? context.extTextureHalfFloat.HALF_FLOAT_OES : gl.UNSIGNED_BYTE, null);\n\n    fbo.colorAttachment.set(texture);\n\n    // If using half-float texture as a render target is not supported, fall back to a low precision texture\n    if (context.extTextureHalfFloat && gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {\n        context.extTextureHalfFloat = null;\n        fbo.colorAttachment.setDirty();\n        bindTextureToFramebuffer(context, painter, texture, fbo);\n    }\n}\n\nfunction renderTextureToMap(painter, layer) {\n    const context = painter.context;\n    const gl = context.gl;\n\n    // Here we bind two different textures from which we'll sample in drawing\n    // heatmaps: the kernel texture, prepared in the offscreen pass, and a\n    // color ramp texture.\n    const fbo = layer.heatmapFbo;\n    if (!fbo) return;\n    context.activeTexture.set(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, fbo.colorAttachment.get());\n\n    context.activeTexture.set(gl.TEXTURE1);\n    let colorRampTexture = layer.colorRampTexture;\n    if (!colorRampTexture) {\n        colorRampTexture = layer.colorRampTexture = new Texture(context, layer.colorRamp, gl.RGBA);\n    }\n    colorRampTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);\n\n    painter.useProgram('heatmapTexture').draw(context, gl.TRIANGLES,\n        DepthMode.disabled, StencilMode.disabled, painter.colorModeForRenderPass(), CullFaceMode.disabled,\n        heatmapTextureUniformValues(painter, layer, 0, 1),\n        layer.id, painter.viewportBuffer, painter.quadTriangleIndexBuffer,\n        painter.viewportSegments, layer.paint, painter.transform.zoom);\n}\n","// @flow\n\nimport DepthMode from '../gl/depth_mode';\nimport CullFaceMode from '../gl/cull_face_mode';\nimport Texture from './texture';\nimport {\n    lineUniformValues,\n    linePatternUniformValues,\n    lineSDFUniformValues,\n    lineGradientUniformValues\n} from './program/line_program';\n\nimport type Painter from './painter';\nimport type SourceCache from '../source/source_cache';\nimport type LineStyleLayer from '../style/style_layer/line_style_layer';\nimport type LineBucket from '../data/bucket/line_bucket';\nimport type {OverscaledTileID} from '../source/tile_id';\n\nexport default function drawLine(painter: Painter, sourceCache: SourceCache, layer: LineStyleLayer, coords: Array<OverscaledTileID>) {\n    if (painter.renderPass !== 'translucent') return;\n\n    const opacity = layer.paint.get('line-opacity');\n    const width = layer.paint.get('line-width');\n    if (opacity.constantOr(1) === 0 || width.constantOr(1) === 0) return;\n\n    const depthMode = painter.depthModeForSublayer(0, DepthMode.ReadOnly);\n    const colorMode = painter.colorModeForRenderPass();\n\n    const dasharray = layer.paint.get('line-dasharray');\n    const patternProperty = layer.paint.get('line-pattern');\n    const image = patternProperty.constantOr((1: any));\n\n    const gradient = layer.paint.get('line-gradient');\n    const crossfade = layer.getCrossfadeParameters();\n\n    const programId =\n        dasharray ? 'lineSDF' :\n        image ? 'linePattern' :\n        gradient ? 'lineGradient' : 'line';\n\n    const context = painter.context;\n    const gl = context.gl;\n\n    let firstTile = true;\n\n    if (gradient) {\n        context.activeTexture.set(gl.TEXTURE0);\n\n        let gradientTexture = layer.gradientTexture;\n        if (!layer.gradient) return;\n        if (!gradientTexture) gradientTexture = layer.gradientTexture = new Texture(context, layer.gradient, gl.RGBA);\n        gradientTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);\n    }\n\n    for (const coord of coords) {\n        const tile = sourceCache.getTile(coord);\n\n        if (image && !tile.patternsLoaded()) continue;\n\n        const bucket: ?LineBucket = (tile.getBucket(layer): any);\n        if (!bucket) continue;\n\n        const programConfiguration = bucket.programConfigurations.get(layer.id);\n        const prevProgram = painter.context.program.get();\n        const program = painter.useProgram(programId, programConfiguration);\n        const programChanged = firstTile || program.program !== prevProgram;\n\n        const constantPattern = patternProperty.constantOr(null);\n        if (constantPattern && tile.imageAtlas) {\n            const posTo = tile.imageAtlas.patternPositions[constantPattern.to];\n            const posFrom = tile.imageAtlas.patternPositions[constantPattern.from];\n            if (posTo && posFrom) programConfiguration.setConstantPatternPositions(posTo, posFrom);\n        }\n\n        const uniformValues = dasharray ? lineSDFUniformValues(painter, tile, layer, dasharray, crossfade) :\n            image ? linePatternUniformValues(painter, tile, layer, crossfade) :\n            gradient ? lineGradientUniformValues(painter, tile, layer) :\n            lineUniformValues(painter, tile, layer);\n\n        if (dasharray && (programChanged || painter.lineAtlas.dirty)) {\n            context.activeTexture.set(gl.TEXTURE0);\n            painter.lineAtlas.bind(context);\n        } else if (image) {\n            context.activeTexture.set(gl.TEXTURE0);\n            tile.imageAtlasTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);\n            programConfiguration.updatePatternPaintBuffers(crossfade);\n        }\n\n        program.draw(context, gl.TRIANGLES, depthMode,\n            painter.stencilModeForClipping(coord), colorMode, CullFaceMode.disabled, uniformValues,\n            layer.id, bucket.layoutVertexBuffer, bucket.indexBuffer, bucket.segments,\n            layer.paint, painter.transform.zoom, programConfiguration);\n\n        firstTile = false;\n        // once refactored so that bound texture state is managed, we'll also be able to remove this firstTile/programChanged logic\n    }\n}\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","import VectorTileSource from 'mapbox-gl/src/source/vector_tile_source'\nimport pako from 'pako/lib/inflate'\nimport base64js from 'base64-js'\nimport Database from './database'\n\nclass MBTilesSource extends VectorTileSource {\n\n    constructor(id, options, dispatcher, eventedParent) {\n        super(id, options, dispatcher, eventedParent);\n        this.type = \"mbtiles\";\n        this.db = this.openDatabase(options.path);\n    }\n\n    openDatabase(dbLocation) {\n        return Database.openDatabase(dbLocation)\n    }\n\n    copyDatabaseFile(dbLocation, dbName, targetDir) {\n        return Database.copyDatabaseFile(dbLocation, dbName, targetDir)\n    }\n\n    readTile(z, x, y, callback) {\n        const query = 'SELECT BASE64(tile_data) AS base64_tile_data FROM tiles WHERE zoom_level=? AND tile_column=? AND tile_row=?';\n        const params = [z, x, y];\n        this.db.then(function(db) {\n            db.transaction(function (txn) {\n                txn.executeSql(query, params, function (tx, res) {\n                    if (res.rows.length) {\n                        const base64Data = res.rows.item(0).base64_tile_data;\n                        if (!base64Data) {\n                          callback(undefined, '');\n                          return;\n                        }\n\n                        try {\n                          const rawData = pako.inflate(base64js.toByteArray(base64Data));\n                          callback(undefined, base64js.fromByteArray(rawData)); // Tile contents read, callback success.\n                        } catch(err) {\n                          // The tile maybe was not compressed?\n                          callback(undefined, base64Data);\n                        }\n                    } else {\n                        callback(new Error('tile ' + params.join(',') + ' not found'));\n                    }\n                });\n            }, function (error) {\n                callback(error); // Error executing SQL\n            });\n        }).catch(function(err) {\n            callback(err);\n        });\n    }\n\n    loadTile(tile, callback) {\n        const coord = tile.tileID.canonical;\n        const overscaling = coord.z > this.maxzoom ? Math.pow(2, coord.z - this.maxzoom) : 1;\n\n        const z = Math.min(coord.z, this.maxzoom || coord.z); // Don't try to get data over maxzoom\n        const x = coord.x;\n        const y = Math.pow(2,z)-coord.y-1; // Tiles on database are tms (inverted y axis)\n\n        this.readTile(z, x, y, dispatch.bind(this));\n\n        function dispatch(err, base64Data) {\n            if (err) {\n                if (this.url && window.allowMapboxOfflineMapOnlineTile) {\n                  return super.loadTile(tile, callback);\n                } else {\n                  return callback(err);\n                }\n            }\n            if (base64Data === undefined) {\n              return callback(new Error(\"empty data\"));\n            }\n\n            const params = {\n                request: { url: \"data:application/x-protobuf;base64,\" + base64Data },\n                uid: tile.uid,\n                tileID: tile.tileID,\n                zoom: coord.z,\n                tileSize: this.tileSize * overscaling,\n                type: this.type,\n                source: this.id,\n                pixelRatio: window.devicePixelRatio || 1,\n                overscaling: overscaling,\n                showCollisionBoxes: this.map.showCollisionBoxes\n            };\n\n            if (!tile.workerID || tile.state === 'expired') {\n                tile.workerID = this.dispatcher.send('loadTile', params, done.bind(this));\n            } else if (tile.state === 'loading') {\n                // schedule tile reloading after it has been loaded\n                tile.reloadCallback = callback;\n            } else {\n                this.dispatcher.send('reloadTile', params, done.bind(this), tile.workerID);\n            }\n\n            function done(err, data) {\n                if (tile.aborted)\n                    return;\n\n                if (err) {\n                    return callback(err);\n                }\n\n                if (this.map._refreshExpiredTiles) tile.setExpiryData(data);\n                tile.loadVectorData(data, this.map.painter);\n\n                callback(null);\n\n                if (tile.reloadCallback) {\n                    this.loadTile(tile, tile.reloadCallback);\n                    tile.reloadCallback = null;\n                }\n            }\n        }\n    }\n}\n\nexport default MBTilesSource;\n","// @flow\n\n'use strict';\n\nimport MBTilesSource from './mbtiles_source'\nimport RasterTileSourceOffline from \"./raster_tile_offline_source\"\nimport RasterDEMTileSourceOffline from \"./raster_dem_offline_tile_source\"\nimport Map from 'mapbox-gl/src/ui/map'\nimport {extend} from 'mapbox-gl/src/util/util'\n//import window from 'mapbox-gl/src/util/window'\n\nconst readJSON = (url) => new Promise((resolve, reject) => {\n    const xhr = new window.XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.setRequestHeader('Accept', 'application/json');\n    xhr.onerror = (e) => reject(e);\n    xhr.onload = () => {\n        const isFile = xhr.responseURL.indexOf('file://') === 0;\n        if (((xhr.status >= 200 && xhr.status < 300) || isFile) && xhr.response) {\n            try {\n                resolve(JSON.parse(xhr.response));\n            } catch (err) {\n                reject(err);\n            }\n        } else {\n            reject(new Error(xhr.statusText, xhr.status));\n        }\n    };\n    xhr.send();\n    return xhr;\n});\n\nconst originalFetch = window.fetch;\nfunction newFetch(resource, init) {\n  if (typeof(resource.url) == 'string' && resource.url.match(/^file:/)) {\n    return readJSON(resource.url).then(function (data) {\n      return {\n        ok: true,\n        json: () => Promise.resolve(data),\n        headers: {\n          get: () => ''\n        }\n      };\n    });\n  }\n  return originalFetch(resource, init);\n}\nwindow.fetch = newFetch;\n\nconst dereferenceStyle = (options) => {\n    if (typeof options.style === 'string' || options.style instanceof String) {\n        return readJSON(options.style).then((style) => extend({}, options, {style: style}));\n    } else {\n        return Promise.resolve(options);\n    }\n};\n\nconst absoluteSpriteUrl = (options) => {\n    const style = options.style;\n    const hasProtocol = /^.+:\\/\\//;\n    const path = window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/');\n\n    if (('sprite' in style) && !style.sprite.match(hasProtocol) &&\n        ('glyphs' in style) && !style.glyphs.match(hasProtocol)) {\n        style.sprite = path + '/' +  style.sprite; // eslint-disable-line prefer-template\n        style.glyphs = path + '/' +  style.glyphs; // eslint-disable-line prefer-template\n    }\n    return options;\n};\n\nconst createEmptyMap = (options) => new Promise((resolve) => {\n    const emptyMapStyle = extend({}, options.style, {\n        sources: {},\n        layers: []\n    });\n    const emptyMapOptions = extend({}, options, {style: emptyMapStyle});\n    const map = new Map(emptyMapOptions);\n    map.once('load', () => {\n        let mbTilesSourceLoaded = new Promise((resolve) => {\n            map.addSourceType('mbtiles', MBTilesSource, () => resolve())\n        });\n        let rasterOfflineSourceLoaded = new Promise((resolve) => {\n            map.addSourceType('rasteroffline', RasterTileSourceOffline, () => resolve())\n        });\n        let rasterDEMOfflineSourceLoaded = new Promise((resolve) => {\n            map.addSourceType('raster-dem-offline', RasterDEMTileSourceOffline, () => resolve())\n        });\n\n        Promise.all([\n\t  mbTilesSourceLoaded,\n\t  rasterOfflineSourceLoaded,\n\t  rasterDEMOfflineSourceLoaded\n\t]).then(() => resolve(map))\n    });\n});\n\nconst loadSources = (style) => (map) => {\n    Object.keys(style.sources).map((sourceName) => map.addSource(sourceName, style.sources[sourceName]));\n    return map;\n};\n\nconst loadLayers = (style) => (map) => {\n    style.layers.map((layer) => map.addLayer(layer));\n    return map;\n};\n\nconst OfflineMap = (options) =>\n    dereferenceStyle(options).then(absoluteSpriteUrl).then((newOptions) =>\n        createEmptyMap(newOptions)\n            .then(loadSources(newOptions.style))\n            .then(loadLayers(newOptions.style))\n    );\n\nexport default OfflineMap\n","import mapboxgl from 'mapbox-gl/src/index'\n\nimport offlineMap from './offline_map'\nimport language from './openmaptiles-language.js'\nimport Database from './database.js'\n\nmapboxgl.Database = Database;\nmapboxgl.OfflineMap = offlineMap;\nlanguage(mapboxgl);\n\nexport default mapboxgl\n","import Map from 'mapbox-gl/src/ui/map'\n\n/* @preserve\n * derived from * https://github.com/klokantech/openmaptiles-language\n * (c) 2018 Klokan Technologies GmbH\n */\nconst language = () => {\n  var langFallbackDecorate = function(style, cfg) {\n    var layers = style.layers;\n    var lf = cfg['layer-filter'];\n    var decorators = cfg['decorators'];\n    var lfProp = lf[1];\n    var lfValues = lf.slice(2);\n\n    for (var i = layers.length-1; i >= 0; i--) {\n      var layer = layers[i];\n      if(!(\n          lf[0]==='in'\n          && lfProp==='layout.text-field'\n          && layer.layout && layer.layout['text-field']\n          && lfValues.indexOf(layer.layout['text-field'])>=0\n      )) {\n        continue;\n      }\n      for (var j = decorators.length-1; j >= 0; j--) {\n        var decorator = decorators[j];\n        var postfix = decorator['layer-name-postfix'] || '';\n        postfix = postfix.replace(/(^-+|-+$)/g, '');\n\n        if(j>0) {\n          var newLayer = JSON.parse(JSON.stringify(layer));\n          layers.splice(i+1, 0, newLayer);\n        } else {\n          newLayer = layer;\n        }\n        newLayer.id += postfix ? '-'+postfix : '';\n        newLayer.layout['text-field'] = decorator['layout.text-field'];\n        if(newLayer.layout['symbol-placement']==='line') {\n          newLayer.layout['text-field'] =\n              newLayer.layout['text-field'].replace('\\n', ' ');\n        }\n        var filterPart = decorator['filter-all-part'].concat();\n        if(!newLayer.filter) {\n          newLayer.filter = filterPart;\n        } else if(newLayer.filter[0]=='all') {\n          newLayer.filter.push(filterPart);\n        } else {\n          newLayer.filter = [\n            'all',\n            newLayer.filter,\n            filterPart\n          ];\n        }\n      }\n    }\n  };\n\n  var setStyleMutex = false;\n  var origSetStyle = Map.prototype.setStyle;\n  Map.prototype.setStyle = function() {\n    origSetStyle.apply(this, arguments);\n\n    if (!setStyleMutex) {\n      if (this.styleUndecorated) {\n        this.styleUndecorated = undefined;\n      }\n      this.once('styledata', function() {\n        if (this.languageOptions) {\n          this.setLanguage(\n            this.languageOptions.language,\n            this.languageOptions.noAlt\n          );\n        }\n      }.bind(this));\n    }\n  };\n\n  Map.prototype.setLanguage = function(language, noAlt) {\n    this.languageOptions = {\n      language: language,\n      noAlt: noAlt\n    };\n    if (!this.styleUndecorated) {\n      try {\n        this.styleUndecorated = this.getStyle();\n      } catch (e) {}\n    }\n    if (!this.styleUndecorated) {\n      return;\n    }\n\n    var isNonlatin = [\n      'ar', 'hy', 'be', 'bg', 'zh', 'ka', 'el', 'he',\n      'ja', 'ja_kana', 'kn', 'kk', 'ko', 'mk', 'ru', 'sr',\n      'th', 'uk'\n    ].indexOf(language) >= 0;\n\n    var style = JSON.parse(JSON.stringify(this.styleUndecorated));\n    var langCfg = {\n      \"layer-filter\": [\n        \"in\",\n        \"layout.text-field\",\n        \"{name}\",\n        \"{name_de}\",\n        \"{name_en}\",\n        \"{name:latin}\",\n        \"{name:latin} {name:nonlatin}\",\n        \"{name:latin}\\n{name:nonlatin}\"\n      ],\n      \"decorators\": [\n        {\n          \"layout.text-field\": \"{name:latin}\" + (noAlt ? \"\" : \"\\n{name:nonlatin}\"),\n          \"filter-all-part\": [\n            \"!has\",\n            \"name:\" + language\n          ]\n        },\n        {\n          \"layer-name-postfix\": language,\n          \"layout.text-field\": \"{name:\" + language + \"}\" + (noAlt ? \"\" : \"\\n{name:\" + (isNonlatin ? 'latin' : 'nonlatin') + \"}\"),\n          \"filter-all-part\": [\n            \"has\",\n            \"name:\" + language\n          ]\n        }\n      ]\n    };\n    if (language == 'native') {\n      langCfg['decorators'] = [\n        {\n          \"layout.text-field\": \"{name}\",\n          \"filter-all-part\": [\"all\"]\n        }\n      ];\n    }\n    langFallbackDecorate(style, langCfg);\n\n    setStyleMutex = true;\n    this.setStyle(style);\n    setStyleMutex = false;\n  };\n\n  Map.prototype.autodetectLanguage = function(opt_fallback) {\n    this.setLanguage(navigator.language.split('-')[0] || opt_fallback || 'native');\n  };\n};\nexport default language;\n","//\n// Our custom intro provides a specialized \"define()\" function, called by the\n// AMD modules below, that sets up the worker blob URL and then executes the\n// main module, storing its exported value as 'mapboxgl'\n\n// The three \"chunks\" imported here are produced by a first Rollup pass,\n// which outputs them as AMD modules.\n\n// Shared dependencies, i.e.:\n/*\ndefine(['exports'], function (exports) {\n    // Code for all common dependencies\n    // Each module's exports are attached attached to 'exports' (with\n    // names rewritten to avoid collisions, etc.)\n})\n*/\nimport './build/mapboxgl/shared';\n\n// Worker and its unique dependencies, i.e.:\n/*\ndefine(['./shared.js'], function (__shared__js) {\n    //  Code for worker script and its unique dependencies.\n    //  Expects the output of 'shared' module to be passed in as an argument,\n    //  since all references to common deps look like, e.g.,\n    //  __shared__js.shapeText().\n});\n*/\n// When this wrapper function is passed to our custom define() above,\n// it gets stringified, together with the shared wrapper (using\n// Function.toString()), and the resulting string of code is made into a\n// Blob URL that gets used by the main module to create the web workers.\nimport './build/mapboxgl/worker';\n\n// Main module and its unique dependencies\n/*\ndefine(['./shared.js'], function (__shared__js) {\n    //  Code for main GL JS module and its unique dependencies.\n    //  Expects the output of 'shared' module to be passed in as an argument,\n    //  since all references to common deps look like, e.g.,\n    //  __shared__js.shapeText().\n    //\n    //  Returns the actual mapboxgl (i.e. src/index.js)\n});\n*/\nimport './build/mapboxgl/index';\n\nexport default mapboxgl;\n"],"names":["Bytes","readFloat","this","end","arr","readPackedDouble","type","readDouble","readPackedEnd","pos","Pbf","push","readFixed32","readPackedSFixed32","readSFixed32","readPackedFixed64","readFixed64","readPackedSFixed64","readSFixed64","val","readVarint","Fixed32","Error","writeTag","length","Uint8Array","buf","finish","realloc","writeInt32","pbf","low","high","writeBigVarintLow","lsb","writeBigVarintHigh","writeSVarint","writeVarint","Boolean","str","String","startPos","i","charCodeAt","lead","c","writeUtf8","len","makeRoomForExtraLength","ieee754","buffer","fn","obj","writeMessage","tag","writePackedFloat","writePackedDouble","writePackedFixed32","writePackedSFixed32","writePackedFixed64","writePackedSFixed64","writeBytesField","writeFixed32Field","Fixed64","Varint","writeStringField","const","glyphs","id","advance","metrics","height","top","constructor","mapId","callbackID","target","addEventListener","x","y","Math","PI","resolution","callback","receive","data","done","postMessage","serialize","deserialize","cancelable","sourceMapId","keys","params","remove","LngLatBounds","sw","ne","setNorthEast","setSouthWest","_ne","LngLat","lng","lat","convert","every","extend","_sw","sw2","max","ne2","getSouthWest","getSouthEast","getEast","toArray","toString","input","isNaN","latitude","altitude","circumferenceAtLatitude","y2","wrap","cos","lngAccuracy","latAccuracy","Number","isArray","z","MercatorCoordinate","fromLngLat","lngLatLike","lngLat","toLngLat","latFromMercatorY","CanonicalTileID","key","calculateKey","equals","url","min","pow","getMercCoords","quadkey","let","mask","getQuadkey","replace","getTilePoint","coord","EXTENT","tilesAtZoom","overscaledZ","targetZ","canonical","OverscaledTileID","zDifference","parent","sourceMaxZoom","rhs","overscaleFactor","toUnwrapped","UnwrappedTileID","register","omit","bounds","minzoom","maxzoom","TileBounds","validateBounds","tileID","worldSize","mercatorXfromLng","getNorth","level","mercatorYfromLat","getSouth","super","dispatcher","_transformRequest","err","tileJSON","fire","tileBounds","postTurnstileEvent","postMapLoadEvent","map","sourceDataType","onAdd","_tileJSONRequest","contains","loadTile","tileSize","ResourceType","Tile","request","tile","aborted","state","img","getTileTexture","texture","useMipmap","bind","gl","CLAMP_TO_EDGE","context","extTextureFilterAnisotropic","abortTile","unloadTile","painter","hasTransition","Evented","uid","encoding","dim","stride","pixels","j","set","get","value","_idx","DEMData","_unpackMapbox","g","r","getPixels","RGBAImage","width","borderTile","yMax","dx","xMin","xMax","dy","yMin","oy","eventedParent","_refreshExpiredTiles","getImageData","workerID","dem","px","nx","nxw","neighboringTiles","pxw","backfilled","stringify","JSON","Array","Object","sort","getKey","layer","refProperties","StyleLayerIndex","layerConfigs","checkMaxAngle","line","anchor","labelLength","windowSize","maxAngle","undefined","segment","p","index","anchorDistance","dist","recentCorners","recentAngleDelta","prev","current","next","angleDelta","angleTo","abs","distance","shift","getLineLength","lineLength","k","getAngleWindowSize","shapedText","glyphSize","boxScale","getShapedLabelLength","shapedIcon","right","left","getCenterAnchor","angleWindowSize","prevDistance","centerDistance","a","b","segmentDistance","t","interpolate","Anchor","_round","getAnchors","spacing","overscaling","tileExtent","shapedLabelLength","isLineContinued","resample","offset","placeAtMiddle","halfLabelLength","markedDistance","anchors","segmentDist","angle","_layerConfigs","_layers","update","removedIds","layerConfig","createStyleLayer","_featureFilter","featureFilter","filter","familiesBySource","layers","groups","group","result","groupByLayout","values","visibility","sourceId","source","sourceGroup","sourceLayerId","sourceLayer","sourceLayerFamilies","CollisionFeature","collisionBoxArray","featureIndex","sourceLayerIndex","bucketIndex","shaped","padding","alignLine","rotate","y1","bottom","x1","x2","boxStartIndex","_addLineCollisionCircles","tl","Point","tr","bl","br","rotateRadians","_rotate","emplaceBack","boxEndIndex","boxSize","step","nBoxes","floor","overscalingPaddingFactor","log","LN2","nPitchPaddingBoxes","firstBoxOffset","labelStartDistance","paddingStartDistance","segmentLength","boxOffset","boxDistanceToAnchor","segmentBoxDistance","p0","boxAnchorPoint","sub","_unit","_mult","_add","paddedAnchorDistance","TinyQueue","compare","defaultCompare","_down","polygon","area","points","f","Cell","compareMax","h","d","inside","minDistSq","Infinity","ring","distToSegmentSquared","sqrt","pointToPolygonDist","SQRT2","item","_up","pop","peek","halfLength","best","module","seed","remainder","bytes","h1","h1b","c1","c2","k1","l","murmur3","murmur2","performSymbolLayout","bucket","glyphMap","glyphPositions","imageMap","imagePositions","showCollisionBoxes","createArrays","tilePixelRatio","compareText","iconsNeedLinear","layout","unevaluatedLayoutValues","_unevaluatedLayout","_values","sizes","textSizeData","functionType","zoomRange","compositeTextSizes","possiblyEvaluate","EvaluationParameters","iconSizeData","compositeIconSizes","layoutTextSize","zoom","layoutIconSize","textMaxSize","lineHeight","textAlongLine","keepUpright","features","feature","fontstack","evaluate","join","glyphPositionMap","shapedTextOrientations","text","unformattedText","textOffset","spacingIfAllowed","allowsLetterSpacing","textAnchor","textJustify","maxWidth","horizontal","shapeText","WritingMode","allowsVerticalWritingMode","vertical","icon","image","shapeIcon","sdfIcons","sdf","warnOnce","pixelRatio","constantOr","addFeature","generateCollisionDebugBuffers","iconOffset","fontScale","textBoxScale","textMaxBoxScale","iconBoxScale","symbolMinDistance","textPadding","iconPadding","textMaxAngle","iconAlongLine","symbolPlacement","textRepeatDistance","addSymbolAtAnchor","textCollisionFeature","iconCollisionFeature","lineArray","addToLineVertexArray","numIconVertices","numGlyphVertices","numVerticalGlyphVertices","placedTextSymbolIndices","textRotate","addTextVertices","horizontalOnly","textBoxStartIndex","textBoxEndIndex","iconQuads","alongLine","iconWidth","iconHeight","size","textLeft","textRight","textTop","textWidth","textHeight","padT","padR","padB","padL","offsetY","offsetX","sin","matrix","_matMult","tex","paddedRect","writingMode","glyphOffset","getIconQuads","iconRotate","sizeData","SIZE_PACK_FACTOR","MAX_PACKED_SIZE","layerIds","addSymbols","lineStartIndex","iconBoxStartIndex","iconBoxEndIndex","glyphOffsetArray","SymbolBucket","MAX_GLYPHS","symbolInstances","addSymbol","lines","clippedLines","clippedLine","p1","clipLine","geometry","anchorIsTooClose","classifyRings","poi","findPoleOfInaccessibility","point","glyphQuads","shaping","positions","positionedGlyphs","quads","positionedGlyph","fontStack","glyph","rect","rectBuffer","GLYPH_PBF_BORDER","halfAdvance","scale","builtInOffset","w","center","verticalRotation","xOffsetCorrection","_rotateAround","getGlyphQuads","placedSymbolArray","repeatDistance","otherAnchors","GlyphAtlas","stacks","bins","stack","stackPositions","src","bitmap","bin","potpack","AlphaImage","copy","WorkerTile","collectResourceTiming","returnDependencies","recalculateLayers","parameters","recalculate","parse","layerIndex","actor","status","CollisionBoxArray","sourceLayerCoder","DictionaryCoder","FeatureIndex","bucketLayerIDs","error","iconMap","patternMap","buckets","options","layerFamilies","version","encode","family","createBucket","sourceID","populate","mapObject","glyphDependencies","send","maybePrepare","call","icons","iconDependencies","patterns","patternDependencies","glyphAtlas","imageAtlas","ImageAtlas","hasOwnProperty","iconPositions","hasPattern","LineBucket","FillBucket","FillExtrusionBucket","addFeatures","patternPositions","isEmpty","glyphAtlasImage","performanceExists","performance","wrapper","getEntriesByName","name","mark","startMark","endMark","measure","clearMarks","clearMeasures","Performance","_marks","start","loadVectorTile","getArrayBuffer","cacheControl","expires","vectorTile","vt","VectorTile","Protobuf","rawData","cancel","resourceTimingData","VectorTileWorkerSource","loadVectorData","loading","loaded","perf","workerTile","abort","response","rawTileData","resourceTiming","slice","reloadTile","vtSource","reloadCallback","removeTile","RasterDEMTileWorkerSource","rawImageData","polygonArea","coords","ringArea","p2","lowerIndex","middleIndex","upperIndex","coordsLength","rad","wgs84","RADIUS","_","coordinates","geometries","rewind","gj","outer","curryOuter","correctRings","correct","wind","dir","geojsonArea","cw","reverse","toGeoJSON","mvt","VectorTileFeature","prototype","FeatureWrapper","_feature","extent","properties","tags","parseInt","loadGeometry","newRing","GeoJSONWrapper","_geojsonTileLayer","_features","require","rawGeometry","rings","bbox","fromVectorTileJs","out","writeLayer","writeTile","writeVarintField","keycache","valuecache","writeFeature","writeValue","bindTextureToFramebuffer","fbo","color","Color","transparent","sourceCache","useProgram","TRIANGLES","posMatrix","layoutVertexBuffer","indexBuffer","renderPass","TEXTURE0","colorRampTexture","StencilMode","heatmapTextureUniformValues","viewportSegments","paint","renderTextureToMap","opacity","colorMode","dasharray","gradient","getCrossfadeParameters","gradientTexture","RGBA","programConfigurations","program","programChanged","patternProperty","constantPattern","to","posTo","posFrom","uniformValues","crossfade","activeTexture","lineAtlas","revLookup","b64","curByte","tmp","len2","parts","encodeChunk","uint8","extraBytes","lookup","Arr","code","validLen","output","num","MBTilesSource","db","path","Database","dbLocation","executeSql","res","rows","base64_tile_data","pako","inflate","base64js","toByteArray","base64Data","catch","readTile","setExpiryData","VectorTileSource","readJSON","resolve","reject","xhr","XMLHttpRequest","setRequestHeader","e","onload","responseURL","init","resource","then","json","originalFetch","location","window","match","hasProtocol","style","mapboxgl","Promise","dereferenceStyle","absoluteSpriteUrl","newOptions","emptyMapOptions","emptyMapStyle","Map","once","mbTilesSourceLoaded","addSourceType","rasterOfflineSourceLoaded","sources","addSource","sourceName","loadLayers","origSetStyle","setStyle","noAlt","languageOptions","language","getStyle","indexOf","langCfg","layout.text-field","filter-all-part","cfg","lf","decorators","lfProp","newLayer","decorator","filterPart","opt_fallback","setLanguage","split"],"mappings":"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"}